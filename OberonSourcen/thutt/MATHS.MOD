MODULE Maths;
(*	Module Information.
			This module provides a basic math library for REALs. 						Please send bug reports, enhancements, and general comments to:				Alan D. Freed								          	E-Mail:	   al@sarah.lerc.nasa.gov				Computational Materials Laboratory	phone:		(216)-433-8747				NASA Lewis Research Center			    	fax:            	(216)-433-5033				Cleveland, Ohio			Modification Record:							Version #		Author		Date	     	Comments 							1.0			  	ADF		  	Oct '94		Original version	*)IMPORT 	Math,	Out;	(* For printout of warning/error messages to System.Log. *)CONST	e- 		= 2.7182818E+00; 	pi- 		= 3.1415927E+00;	loge 	= 4.3429448E-01; 	twoPi 	= 6.2831853E+00;	piBy2 	= 1.5707963E+00; VAR	xx:				REAL;	epsilon-:		REAL;	lnEpsilon:		REAL;	sqrtEpsilon:	REAL;	nolispe:		REAL;	infinity-:		REAL;	lnInfinity:		REAL; 		sqrtInfinity:	REAL;	zero-:			REAL;	cothMax:		REAL;	tanhMax:		REAL;(* Algebraic Functions *)PROCEDURE Max* (x, y: REAL): REAL; BEGIN	IF x > y THEN RETURN x ELSE RETURN y ENDEND Max; PROCEDURE Min* (x, y: REAL): REAL; BEGIN	IF x < y THEN RETURN x ELSE RETURN y ENDEND Min; PROCEDURE Round* (x: REAL): LONGINT;BEGIN	RETURN ENTIER(x + 0.5)END Round; PROCEDURE Sqr* (x: REAL): REAL; BEGIN	RETURN x*xEND Sqr; PROCEDURE Sqrt* (x: REAL): REAL; BEGIN	RETURN Math.sqrt(ABS(x))END Sqrt; PROCEDURE Power* (x: REAL; power: INTEGER): REAL; VAR	z:					REAL;	xTo2: 				REAL;	xTo4: 				REAL;	xTo8: 				REAL; 	n: 					INTEGER;	powerIsNegative: BOOLEAN; BEGIN	n := power; 	z := 1; 	IF n # 0 THEN 		IF n > 0 THEN			powerIsNegative := FALSE 		ELSE			n := -n; powerIsNegative := TRUE		END; 		IF ODD(n) THEN z := z*x; DEC(n) END;		IF n > 1 THEN xTo2 := Sqr(x) END; 		IF n > 3 THEN xTo4 := Sqr(xTo2) END;		IF n > 7 THEN xTo8 := Sqr(xTo4) END;		WHILE n > 0 DO			IF n > 7 THEN z := z*xTo8; n := n - 8				ELSIF n > 3 THEN z := z*xTo4; n := n - 4 				ELSE z := z*xTo2; n := n - 2			END		END; 		IF powerIsNegative THEN 			IF ABS(z) < zero THEN 				IF z < 0 THEN z := -zero ELSE z := zero END;				Out.String("WARNING - Attempted to raise  0  to a negative integer.");				Out.Ln; Out.String("   The result was clipped at "); Out.Real(1/z,11); Out.Ln			END; 			z := 1/z		END 	END; 	RETURN z END Power; PROCEDURE Expon* (x, exponent: REAL): REAL; VAR 	z: REAL; BEGIN	IF x > zero THEN 		z := Min(infinity, Math.exp(exponent*Math.ln(x)))	ELSIF x > 0 THEN		IF exponent > 1 THEN			z := 0		ELSIF exponent > -1 THEN			z := Min(infinity, Math.exp(exponent*Math.ln(x)))		ELSE			z := infinity;			Out.String("WARNING - Attempted to raise  0  to a negative real."); Out.Ln;			Out.String("   The result was clipped at "); Out.Real(z,11); Out.Ln		END	ELSIF x = 0 THEN		IF exponent = 0 THEN z := 1 ELSE z := 0 END	ELSE		z := Power(x, SHORT(Round(exponent))); 		Out.String("WARNING - Attempted to raise a negative number ");		Out.String("to a real-valued exponent."); Out.Ln;		Out.String("   Calculated  Power(x, Round(exponent))  instead."); Out.Ln	END; 	RETURN zEND Expon; (* Exponential/Logarithmic Functions *)PROCEDURE Ln* (x: REAL): REAL; BEGIN 	RETURN Math.ln(x)END Ln; PROCEDURE Log* (x: REAL): REAL; BEGIN	RETURN loge*Math.ln(x)END Log; PROCEDURE Exp* (x: REAL): REAL; BEGIN	RETURN Math.exp(x) END Exp; (* Trigonometric Functions *) PROCEDURE Sin* (x: REAL): REAL; 	(** Domain [-pi, pi]  =>  Range [-1, 1] **)VAR	X: REAL;BEGIN	X := x;	IF x < -pi THEN 		REPEAT X := X + twoPi UNTIL X > -pi	ELSIF x > pi THEN		REPEAT X := X - twoPi UNTIL X < pi	ELSE END;	RETURN Math.sin(X)END Sin; PROCEDURE Cos* (x: REAL): REAL; 	(** Domain [-pi, pi]  =>  Range [-1, 1] **)VAR	X:	REAL;BEGIN 	X := x;	IF x < -pi THEN 		REPEAT X := X + twoPi UNTIL X > -pi	ELSIF x > pi THEN		REPEAT X := X - twoPi UNTIL X < pi	ELSE END;	RETURN Math.cos(X)END Cos; PROCEDURE Tan* (x: REAL): REAL; 	(** Domain [-pi, pi]  =>  Range (-Infinity, Infinity) **)VAR	X:	REAL;	tan:	REAL;	sin:	REAL;	cos:	REAL;BEGIN	X := x;	IF x < -pi THEN 		REPEAT X := X + twoPi UNTIL X > -pi	ELSIF x > pi THEN		REPEAT X := X - twoPi UNTIL X < pi	ELSE END;	sin  := Math.sin(X);	cos := Math.cos(X);	IF (cos > -epsilon) & (cos < epsilon) THEN		IF cos < 0 THEN tan := -sin/epsilon ELSE tan := sin/epsilon END; 		Out.String("WARNING - Tan(x) was clipped to "); Out.Real(tan,11); 		Out.String("."); Out.Ln	ELSE		tan := sin/cos	END;	RETURN tanEND Tan; PROCEDURE Sec* (x: REAL): REAL; 	(** Domain [-pi, pi] => Range (-Infinity, -1]  [1, Infinity) **)VAR	X:	REAL;	sec:	REAL;	cos:	REAL;BEGIN	X := x;	IF x < -pi THEN 		REPEAT X := X + twoPi UNTIL X > -pi	ELSIF x > pi THEN		REPEAT X := X - twoPi UNTIL X < pi	ELSE END;	cos := Math.cos(X);	IF (cos > -epsilon) & (cos < epsilon) THEN		IF cos < 0 THEN sec := -nolispe ELSE sec := nolispe END;		Out.String("WARNING - Sec(x) was clipped to "); Out.Real(sec,11); 		Out.String("."); Out.Ln	ELSE		sec := 1/cos	END;	RETURN secEND Sec; PROCEDURE Csc* (x: REAL): REAL;	(** Domain [-pi, pi] => Range (-Infinity, -1]  [1, Infinity) **)VAR	X:	REAL;	csc:	REAL;	sin:	REAL;BEGIN	X := x;	IF x < -pi THEN 		REPEAT X := X + twoPi UNTIL X > -pi	ELSIF x > pi THEN 		REPEAT X := X - twoPi UNTIL X < pi	ELSE END;	sin := Math.sin(X);	IF (sin > -epsilon) & (sin < epsilon) THEN		IF sin < 0 THEN csc := -nolispe ELSE csc := nolispe END;		Out.String("WARNING - Csc(x) was clipped to "); Out.Real(csc,11); 		Out.String("."); Out.Ln	ELSE		csc := 1/sin	END;	RETURN cscEND Csc; PROCEDURE Cot* (x: REAL): REAL; 	(** Domain [-pi, pi]  =>  Range (-Infinity, Infinity) **)VAR	X:	REAL;	cot:	REAL;	sin:	REAL;	cos:	REAL;BEGIN	X := x;	IF x < -pi THEN 		REPEAT X := X + twoPi UNTIL X > -pi	ELSIF x > pi THEN		REPEAT X := X - twoPi UNTIL X < pi	ELSE END;	sin  := Math.sin(X);	cos := Math.cos(X);	IF (sin > -epsilon) & (sin < epsilon) THEN		IF sin < 0 THEN cot := -cos/epsilon ELSE cot := cos/epsilon END;		Out.String("WARNING - Cot(x) was clipped to "); Out.Real(cot,11); 		Out.String("."); Out.Ln	ELSE		cot := cos/sin	END;	RETURN cotEND Cot; (* Inverse Trigonometric Functions *)PROCEDURE ArcTan* (x: REAL): REAL; 	(** Returns the root in [-pi/2, pi/2]. **)BEGIN 	RETURN Math.arctan(x)END ArcTan; PROCEDURE ArcCot* (x: REAL): REAL; 	(** Returns the root in [0, pi]. **)VAR 	arcCot: REAL; BEGIN	IF x < (1 - nolispe) THEN		arcCot := pi	ELSIF x > (nolispe - 1) THEN		arcCot := 0	ELSE		arcCot := piBy2 - Math.arctan(x)	END;	RETURN arcCotEND ArcCot; PROCEDURE ArcCos* (x: REAL): REAL; 	(** Returns the root in [0, pi]. **)VAR	arcCos: REAL; BEGIN	IF (x < -1) OR (x > 1) THEN		IF x < 0 THEN arcCos := pi ELSE arcCos := 0 END; 		Out.String("ERROR - Argument lay outside the domain  [-1, 1]  for ArcCos.");		Out.Ln; Out.String("   The assigned value for ArcCos("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcCos,11); Out.String("."); Out.Ln	ELSIF x < -0.33 THEN		arcCos := pi + Math.arctan(Math.sqrt(1 - Sqr(x))/x)	ELSIF x < 0.33 THEN		arcCos := piBy2 - Math.arctan(x/Math.sqrt(1 - Sqr(x)))	ELSE		arcCos := Math.arctan(Math.sqrt(1 - Sqr(x))/x)	END;	RETURN arcCosEND ArcCos; PROCEDURE ArcSin* (x: REAL): REAL; 	(** Returns the root in [-pi/2, pi/2]. **)VAR 	arcSin: REAL; BEGIN	IF (x < -1) OR (x > 1) THEN		IF x < 0 THEN arcSin := -piBy2 ELSE arcSin := piBy2 END;		Out.String("ERROR - Argument lay outside the domain  [-1, 1]  for ArcSin.");		Out.Ln; Out.String("   The assigned value for ArcSin("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcSin,11); Out.String("."); Out.Ln	ELSE		arcSin := piBy2 - ArcCos(x)	END;	RETURN arcSinEND ArcSin; PROCEDURE ArcSec* (x: REAL): REAL; 	(** Returns the root in [-pi, -pi/2] for x <= -1 and in [0, pi/2] for x >= 1. **)VAR	arcSec: REAL; BEGIN	IF x < (1 - nolispe) THEN		arcSec := -piBy2	ELSIF x < (-1 - epsilon) THEN		arcSec := -ArcCos(1/x)	ELSIF x < (-1 + epsilon) THEN		arcSec := -pi	ELSIF x > (nolispe - 1) THEN		arcSec := piBy2	ELSIF x > (1 + epsilon) THEN		arcSec := ArcCos(1/x) 	ELSIF x > (1 - epsilon) THEN		arcSec := 0	ELSE		IF x < 0 THEN arcSec := -pi ELSE arcSec := 0 END;		Out.String("ERROR - Argument lay outside the domain  (-Infinity, -1] ");		Out.String(" [1, Infinity)  for ArcSec."); Out.Ln;		Out.String("   The assigned value for ArcSec("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcSec,11); Out.String("."); Out.Ln	END;	RETURN arcSecEND ArcSec; PROCEDURE ArcCsc* (x: REAL): REAL; 	(** Returns the root in [-pi, -pi/2] for x <= -1 and in [0, pi/2] for x >= 1. **)VAR	arcCsc: REAL; BEGIN	IF x < (1 - nolispe) THEN		arcCsc := -pi 	ELSIF x < (-1 - epsilon) THEN		arcCsc := -pi -ArcSin(1/x)	ELSIF x < (-1 + epsilon) THEN 		arcCsc := -piBy2	ELSIF x > (nolispe - 1) THEN		arcCsc := 0	ELSIF x > (1 + epsilon) THEN		arcCsc := ArcSin(1/x)	ELSIF x > (1 - epsilon) THEN 		arcCsc := piBy2	ELSE		IF x < 0 THEN arcCsc := -piBy2 ELSE arcCsc := piBy2 END;		Out.String("ERROR - Argument lay outside the domain  (-Infinity, -1] ");		Out.String(" [1, Infinity)  for ArcCsc."); Out.Ln;		Out.String("   The assigned value for ArcCsc("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcCsc,11); Out.String("."); Out.Ln	END;	RETURN arcCscEND ArcCsc;(* Hyperbolic Functions *)PROCEDURE Sinh* (x: REAL): REAL; 	(** Domain (-Infinity, Infinity)  =>  Range (-Infinity, Infinity) **)VAR	sinh: REAL;BEGIN 	IF ABS(x) > lnInfinity THEN 		IF x > 0 THEN sinh := Math.exp(lnInfinity)/2 ELSE sinh := -Math.exp(lnInfinity)/2 END;		Out.String("WARNING - Sinh(x) was clipped to "); Out.Real(sinh,11); 		Out.String("."); Out.Ln	ELSIF ABS(x) > lnEpsilon THEN		IF x > 0 THEN sinh := Math.exp(x)/2 ELSE sinh := -Math.exp(-x)/2 END	ELSE		sinh := (Math.exp(x) - Math.exp(-x))/2	END;	RETURN sinhEND Sinh; PROCEDURE Cosh* (x: REAL): REAL; 	(** Domain (-Infinity, Infinity)  =>  Range [1, Infinity) **)VAR	X:	REAL;	cosh: REAL;BEGIN 	X := ABS(x); 	IF X > lnInfinity THEN 		cosh := Math.exp(lnInfinity)/2;		Out.String("WARNING - Cosh(x) was clipped to "); Out.Real(cosh,11); 		Out.String("."); Out.Ln	ELSIF X > lnEpsilon THEN		cosh := Math.exp(X)/2	ELSE		cosh := (Math.exp(X) + Math.exp(-X))/2	END;	RETURN coshEND Cosh; PROCEDURE Tanh* (x: REAL): REAL; 	(** Domain (-Infinity, Infinity)  =>  Range (-1, 1) **)VAR	tanh: REAL;BEGIN	IF ABS(x) > tanhMax THEN		IF x > 0 THEN tanh := 1 - epsilon ELSE tanh := epsilon - 1 END	ELSE		tanh := Sinh(x)/Cosh(x)	END;	RETURN tanhEND Tanh; PROCEDURE Sech* (x: REAL): REAL; 	(** Domain (-Infinity, Infinity)  =>  Range (0, 1] **)BEGIN	RETURN 1/Cosh(x)END Sech; PROCEDURE Csch* (x: REAL): REAL; 	(** Domain (-Infinity, 0) (0, Infinity)  =>  Range (-Infinity, 0) (0, Infinity) **)VAR	csch:	REAL;	sinh:	REAL;BEGIN	sinh := Sinh(x);	IF (sinh > -epsilon) & (sinh < epsilon) THEN		IF sinh < 0 THEN csch := -nolispe ELSE csch := nolispe END;		Out.String("WARNING - Csch(x) was clipped to "); Out.Real(csch,11); 		Out.String("."); Out.Ln	ELSE		csch := 1/sinh	END;	RETURN cschEND Csch; PROCEDURE Coth* (x: REAL): REAL; 	(** Domain (-Infinity, 0) (0, Infinity)  =>  Range (-Infinity, -1) (1, Infinity) **)VAR	coth:	REAL;	cosh:	REAL;	sinh:	REAL;BEGIN	cosh := Cosh(x);	sinh  := Sinh(x);	IF ABS(x) > tanhMax THEN		IF x > 0 THEN coth := 1 + epsilon ELSE coth := -1 - epsilon END	ELSIF ABS(sinh) < epsilon THEN		IF x < 0 THEN coth := -cosh/epsilon ELSE coth := cosh/epsilon END;		Out.String("WARNING - Coth(x) was clipped to "); Out.Real(coth,11); 		Out.String("."); Out.Ln	ELSE		coth := cosh/sinh	END;	RETURN cothEND Coth; (* Inverse Hyperbolic Functions *)PROCEDURE ArcSinh* (x: REAL): REAL; VAR	arcSinh: REAL;BEGIN	IF ABS(x) > sqrtInfinity/2 THEN 		IF x > 0 THEN arcSinh := Math.ln(sqrtInfinity) ELSE arcSinh := -Math.ln(sqrtInfinity) END;		Out.String("WARNING - ArcSinh(x) was clipped to "); Out.Real(arcSinh,11); 		Out.String("."); Out.Ln	ELSIF x < 0 THEN		arcSinh := -Math.ln(-x + Math.sqrt(Sqr(x) + 1))	ELSE		arcSinh := Math.ln(x + Math.sqrt(Sqr(x) + 1))	END;	RETURN arcSinhEND ArcSinh; PROCEDURE ArcCsch* (x: REAL): REAL; VAR	arcCsch: REAL;BEGIN	IF ABS(x) < 2/sqrtInfinity THEN		IF x < 0 THEN arcCsch := -Math.ln(sqrtInfinity) ELSE arcCsch := Math.ln(sqrtInfinity) END;		Out.String("WARNING - ArcCsch(x) was clipped to "); Out.Real(arcCsch,11); 		Out.String("."); Out.Ln	ELSE		arcCsch := ArcSinh(1/x)	END;	RETURN arcCschEND ArcCsch; PROCEDURE ArcCosh* (x: REAL): REAL; 	(** Returns the positive root only. **)VAR	arcCosh: REAL;BEGIN	IF x < 1 THEN		arcCosh := 0;		Out.String("ERROR - Argument lay outside the domain  [1, Infinity) "); 		Out.String(" for ArcCosh."); Out.Ln; 		Out.String("   The assigned value for ArcCosh("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcCosh,11); Out.String("."); Out.Ln	ELSIF x > sqrtInfinity/2 THEN 		arcCosh := Math.ln(sqrtInfinity);		Out.String("WARNING - ArcCosh(x) was clipped to "); Out.Real(arcCosh,11); 		Out.String("."); Out.Ln	ELSE		arcCosh := Math.ln(x + Math.sqrt(Sqr(x) - 1))	END;	RETURN arcCoshEND ArcCosh; PROCEDURE ArcSech* (x: REAL): REAL; 	(** Returns the positive root only. **)VAR	arcSech: REAL; BEGIN	IF (x <= 0) OR (x > 1) THEN		IF x > 1 THEN arcSech := 0 ELSE arcSech := Math.ln(sqrtInfinity) END;		Out.String("ERROR - Argument lay outside the domain (0, 1] for ArcSech.");		Out.Ln; Out.String("   The assigned value for ArcSech("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcSech,11); Out.String("."); Out.Ln	ELSIF x < 2/sqrtInfinity THEN 		arcSech := Math.ln(sqrtInfinity);		Out.String("WARNING - ArcSech(x) was clipped to "); Out.Real(arcSech,11); 		Out.String("."); Out.Ln	ELSE		arcSech := ArcCosh(1/x)	END; 	RETURN arcSechEND ArcSech; PROCEDURE ArcTanh* (x: REAL): REAL; VAR	arcTanh: REAL;BEGIN 	IF (x >= 1) OR (x <= -1) THEN 		IF x < 0 THEN arcTanh := -tanhMax ELSE arcTanh := tanhMax END;		Out.String("ERROR - Argument lay outside the domain  (-1, 1)  for ArcTanh.");		Out.Ln; Out.String("   The assigned value for ArcTanh("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcTanh,11); Out.String("."); Out.Ln	ELSIF (x > (1 - 2*epsilon)) OR (x < (2*epsilon - 1)) THEN 		IF x > 0 THEN arcTanh := tanhMax ELSE arcTanh := -tanhMax END;		Out.String("WARNING - ArcTanh(x) was clipped to "); Out.Real(arcTanh,11); 		Out.String("."); Out.Ln	ELSE		arcTanh := ArcSinh(x/Math.sqrt(1 - Sqr(x)));		IF ABS(x) > Tanh(5.9) THEN			Out.String("WARNING - At best, 3 significant figures ");			Out.String("of accuracy for ArcTanh."); Out.Ln		END	END;	RETURN arcTanhEND ArcTanh; PROCEDURE ArcCoth* (x: REAL): REAL; VAR	arcCoth: REAL;BEGIN	IF ABS(x) <= 1 THEN		IF x < 0 THEN arcCoth := -cothMax ELSE arcCoth := cothMax END;		Out.String("ERROR - Argument lay outside the domain  (-Infinity, -1) ");		Out.String(" (1, Infinity)  for ArcCoth."); Out.Ln;		Out.String("   The assigned value for ArcCoth("); Out.Real(x,11); 		Out.String(") was "); Out.Real(arcCoth,11); Out.String("."); Out.Ln	ELSIF (x > 0) & (x < (1 + 2*epsilon)) THEN		arcCoth := cothMax;		Out.String("WARNING - ArcCoth(x) was clipped to "); Out.Real(arcCoth,11); 		Out.String("."); Out.Ln	ELSIF (x < 0) & (x > (-1 - 2*epsilon)) THEN		arcCoth := -cothMax;		Out.String("WARNING - ArcCoth(x) was clipped to "); Out.Real(arcCoth,11); 		Out.String("."); Out.Ln	ELSE		IF x > 0 THEN 			arcCoth := ArcCosh(x/Math.sqrt(Sqr(x) - 1)) 		ELSE			arcCoth := -ArcCosh(-x/Math.sqrt(Sqr(x) - 1))		END;		IF ABS(x) < Coth(6.4) THEN 			Out.String("WARNING - At best, 3 significant figures ");			Out.String("of accuracy for ArcCoth."); Out.Ln		END	END;	RETURN arcCothEND ArcCoth; BEGIN	epsilon := 1.0E+00;	LOOP		xx := 1.0E+00 + epsilon;		IF xx = 1.0E+00 THEN EXIT END;		epsilon := epsilon/10	END;	epsilon			:= 10*epsilon;				(** Largest number such that 1 + epsilon > 1.0 **)	lnEpsilon		:= ABS(Math.ln(epsilon)); 	sqrtEpsilon	:= Math.sqrt(epsilon);	nolispe			:= 1/epsilon;	infinity			:= MAX(REAL)/100;	lnInfinity		:= Math.ln(infinity); 	sqrtInfinity	:= Math.sqrt(infinity);	zero				:= 1/infinity;			 		(** Interval [-zero, zero] is numerical  0. **)	xx				:= (1 + epsilon)/sqrtEpsilon;	cothMax		:= Math.ln(xx + Math.sqrt(xx*xx - 1));	xx				:= (1 - epsilon)/sqrtEpsilon;	tanhMax		:= Math.ln(xx + Math.sqrt(xx*xx + 1))END Maths. 