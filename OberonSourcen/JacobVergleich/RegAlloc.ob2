  (**************************************************************) 
  (*   This module was generated by BEG V1.75        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
 MODULE RegAlloc;


(******* empty insertion IpInOut *******)
 IMPORT ConsBase,SYSTEM,IR,InOut,GcgTab;
(******* empty insertion IpText *******)
(******* empty insertion IpTypes *******)
(******* empty insertion IpRegAlloc_i *******)
 TYPE  Action*=SHORTINT;
 CONST aLr*=0; aRestore*=1; MAX_Action*=aRestore;
 
 TYPE  Spilllocation* = LONGINT;
 	AllocIndex*=INTEGER;
 CONST MAX_AllocIndex*= 4096;
  TYPE AllocDescr*    = RECORD 
 	    reg*           : IR.Register;
           actionafter*   : BOOLEAN;  (* he 08/91 *)
 	    spilllocation* : Spilllocation;
           regmove*       : IR.Register;  (* he 08/91 *)
 	    op*            : ARRAY IR.MaxPscArity+1 OF IR.Register;
	    scr*           : ARRAY IR.MaxScratch+1 OF IR.Register;
 	    num*           :SHORTINT; 
 	    a*             : ARRAY IR.MaxPscArity+2 OF RECORD
 	       action* : Action;
              regto*, regfrom*  : IR.Register;
 	       reg             : IR.Register;
     		             spilllocation*   : Spilllocation;
 	    END;
 	 END;
 VAR    ai*         : AllocIndex;
        allocation* : ARRAY MAX_AllocIndex+2 OF AllocDescr;
        UsedReg*    : IR.RegisterSet;
 VAR    
      r,r1,targetregister : IR.Register;
      av, lav             : IR.RegisterSet;
      ga                  : IR.ExprAttributes;
      i                   :LONGINT; 
 VAR 
     s : Spilllocation; 
     ch : IR.RegisterSet;
     emptyset : IR.RegisterSet;
     lowpriority : IR.Register;   (* he 8/91 *)

 PROCEDURE^PrintAllocation* (i : AllocIndex);

 PROCEDURE  RegAllo* ( e : IR.Expression; localavail : IR.RegisterSet );
 VAR    
        ActSpilllocation : Spilllocation;
 PROCEDURE NewSpilllocation () : Spilllocation;
 BEGIN
    ActSpilllocation := ActSpilllocation+1;
    RETURN (ActSpilllocation);
 END NewSpilllocation;
 
 
 PROCEDURE ActionRestore   (a : AllocIndex; preg : IR.Register;
 			   pspilllocation : Spilllocation);
 BEGIN
       allocation [a].num := allocation [a].num+1;
 	   allocation [a].a[allocation [a].num].action := aRestore;
 	   allocation [a].a[allocation [a].num].regto  := preg;
	   allocation [a].a[allocation [a].num].spilllocation := pspilllocation;
 END ActionRestore;

 PROCEDURE ActionLr   (a : AllocIndex; pregto, pregfrom : IR.Register);
 BEGIN
 (*   InOut.WriteString ('******************************* LR'); InOut.WriteLn;*)
      allocation [a].num := allocation [a].num+1;
 	 allocation [a].a[allocation [a].num].action := aLr;
 	 allocation [a].a[allocation [a].num].regto  := pregto;
 	 allocation [a].a[allocation [a].num].regfrom:= pregfrom;
 END ActionLr;
 
 PROCEDURE Take (s : IR.RegisterSet) : IR.Register;
(******* empty insertion IpProcTake *******)
 VAR r : IR.Register;
     c :LONGINT; 
     bs : SET;
 BEGIN
  bs := s[(lowpriority) DIV 32];  (* he 8/91 *)
     EXCL (s[0], (lowpriority));
;                       (* he 8/91 *)
    IF s[0]#{}   THEN
      c := 0;
      WHILE ~(c IN s[0]) DO INC(c); END;
      r:= SYSTEM.VAL (IR.Register, c+0);
         INCL (UsedReg[0], (r));
;
      RETURN (r);
   END;
  IF (lowpriority) MOD 32 IN bs THEN  (* he 8/91 *)
        INCL (UsedReg[0], (lowpriority));
;
     RETURN (lowpriority);                              (* he 8/91 *)
  END;                                                  (* he 8/91 *)
  (*************** Compiler Error ******************)
  (******** register allocation not possible *******)
  InOut.WriteString ('Registerallocation not possible'); InOut.WriteLn;
  IR.Error('internal error');
  c:=0; c:=c DIV c; HALT(0);
 END Take;
 
 PROCEDURE Closure (s : IR.RegisterSet; VAR r : IR.RegisterSet);
 VAR reg : IR.Register;
     c :LONGINT; 
 BEGIN
       r[0]:={};
    IF s[0]#{}   THEN
      FOR c:=0 TO 30 DO
         IF c IN s[0] THEN 
            reg:= SYSTEM.VAL (IR.Register, c+0);
                  r[0]:=r[0]+GcgTab.RegDestroy[reg][0];      
         END;
      END;
   END;
 END Closure;
 
 
 
 
 
 PROCEDURE RegAllocExpr (
                       e : IR.Expression; rule : IR.Rule;
 			first,
                       second,
                       third      : IR.RegisterSet;
 			VAR oreg    : IR.Register;
 			VAR sp     : Spilllocation;
 			VAR Change : IR.RegisterSet);
 (* Perform Register allocation for e                                 *)
 (* reg is the result register or if reg=RegNil the result is in      *)
 (* memory. Then sp contains the number of the spilllocation.         *)
 (* It is tried to put the result in a register contained in first    *)
 (* It that is not possible second and third are tried. If everything *)
 (* else fails the result is spilled                                  *)
 
 VAR airegister  : AllocIndex;
     change, changelocal : IR.RegisterSet;
 
  PROCEDURE RegAllocAdrMode (e : IR.Expression; rule : IR.Rule);
 
 VAR nextrule : IR.Rule;
     i        ,
     path     :LONGINT; 
     f        : IR.Expression;
     av, av1, av2, av3 : IR.RegisterSet;
     aiact    : AllocIndex;
     r,r1     : IR.Register;
     s        : Spilllocation; 
     ch       : IR.RegisterSet;
     ga       : IR.ExprAttributes;
 BEGIN
    IF ai >= MAX_AllocIndex THEN
	(*************** Compiler Error ******************)
       (************* expression too complex ************)
	IR.Error('expression too complex');
       i:=0; i:=i DIV i; HALT(0);
    END;
    aiact := ai;
    allocation[aiact].num := 0;
    allocation[aiact].actionafter := FALSE;
    ai := ai+1; 
(*<<<<<<<<<<<<<<<
    WITH GcgTab.RuleDescr [rule]. DO
>>>>>>>>>>>>>>>*)
       FOR i:=GcgTab.RuleDescr [rule].pscarity TO 1 BY -1 DO
        f:=e; path := GcgTab.RuleDescr [rule].op[i].path;
        WHILE path#0 DO 
           f:=f^.son [ path MOD 16 ];
           path := path DIV 16;
        END;
 
        nextrule := f^.gcg^.rule[GcgTab.RuleDescr [rule].op[i].nt];
        CASE  GcgTab.RuleDescr [nextrule].register OF 
          GcgTab.RKRegister, GcgTab.RKCalc :       (* he 3/91 *)
                    av3[0] := SYSTEM.VAL(SET, -1)-change[0];      
;
           IF GcgTab.RuleDescr [rule].op[i].calc THEN
              ga := e^.gcg;
                   av2[0]:={};
;
                 INCL (av2[0], (r));
;
                 INCL (localavail[0], (r));
;
                    av1[0]:=av2[0];      
;
              lowpriority := r;
           ELSE
                    av2[0]:=av3[0]*GcgTab.RuleDescr [rule].op[i].regs[0];      
              IF (i=GcgTab.RuleDescr [rule].target) OR (i=GcgTab.RuleDescr [rule].result) THEN 
                 IF GcgTab.RuleDescr [rule].closuretarget THEN 
                    Closure (first,first);
                          av1[0]:=first[0]*av2[0];      
                    IF ( (localavail[0]*av1[0]={})) THEN
                       Closure (second,second);
                             av1[0]:=second[0]*av2[0];      
                       IF ( (localavail[0]*av1[0]={})) THEN 
                          Closure (third,third);
                                av1[0]:=third[0]*av2[0];      
                       END;
                    END;
                 ELSE
                          av1[0]:=first[0]*av2[0];      
                    IF ( (localavail[0]*av1[0]={})) THEN
                             av1[0]:=second[0]*av2[0];      
                       IF ( (localavail[0]*av1[0]={})) THEN 
                                av1[0]:=third[0]*av2[0];      
                       END;
                    END;
                 END;
              ELSE
                 av1 := av2;
              END;
           END;
 
           RegAllocExpr (
                         f, nextrule,
                         av1,
                         av2,
                         av3,
                         r,
                         s,
                         ch);
                 change[0]:=change[0]+ch[0];      
 
           IF (i=GcgTab.RuleDescr [rule].target) OR (i=GcgTab.RuleDescr [rule].result) THEN 
              IF ((i=GcgTab.RuleDescr [rule].result) & (r # ConsBase.RegNil)) OR (   ((r) IN av1[0]) &    ((r) IN localavail[0])) THEN
                 r1 := r;
              ELSE
                       av[0] :=lav[0]-changelocal[0];      
                       av[0]:=av[0]*GcgTab.RuleDescr [rule].op[i].regs[0];      
                 IF ~( (av[0]*first[0]={})) THEN 
                          av[0]:=av[0]*first[0];      
                    r1:= Take (av);
                 ELSIF    ((r) IN av[0]) THEN                (* he 8/91 *)
                    r1 := r;
                 ELSIF ~( (av[0]*second[0]={})) THEN 
                          av[0]:=av[0]*second[0];      
                    r1:= Take (av);
                 ELSIF ~( (av[0]*third[0]={})) THEN 
                          av[0]:=av[0]*third[0];      
                    r1:= Take (av);
                 ELSE
                    r1:= Take (av);
                 END;
              END;
           ELSE (* i#target *)
              IF (r=ConsBase.RegNil) OR ~   ((r) IN av2[0]) THEN 
                 IF GcgTab.RuleDescr [rule].op[i].calc THEN 
                    r1 := Take (av1);
                 ELSE 
                          av[0] :=lav[0]-changelocal[0];      
                          av[0]:=av[0]*GcgTab.RuleDescr [rule].op[i].regs[0];      
                    r1 := Take (av);
                 END; (* -- he 07/91 *)
              ELSE
                 r1 := r;
              END;
           END;
 
           IF r1#r THEN 
              IF r=ConsBase.RegNil THEN 
                 ActionRestore (airegister, r1, s);
              ELSE
                 ActionLr (airegister, r1, r);
              END;   (* he 12/91 *)
                    change[0]:=change[0]+GcgTab.RegDestroy[r1][0];      
           END;
 
           allocation [aiact] . op [i] := r1;
           IF (i=GcgTab.RuleDescr [rule].target) OR (i=GcgTab.RuleDescr [rule].result) THEN 
              IF GcgTab.RuleDescr [rule].closuretarget THEN 
                       av[0]:=GcgTab.RegDestroy[r1][0]*GcgTab.RuleDescr [rule].resregs[0];      
                 targetregister := Take (av);
              ELSE
                 targetregister := r1; 
              END;
           END;
                 changelocal[0]:=changelocal[0]+GcgTab.RegDestroy[r1][0];      
        | GcgTab.RKAdrmode : 
           RegAllocAdrMode (f, nextrule);
        ELSE 
           RegAllocExpr (
           		  f, nextrule,
                         av1,   (* dummy *)
                         av2,   (* dummy *)
                         av3,   (* dummy *)
                         r,   (* dummy *)
                         s,   (* dummy *)
                         ch);
                 change[0]:=change[0]+ch[0];      
        END;
       END;
(*<<<<<<<<<<<<<<<
    END;
>>>>>>>>>>>>>>>*)
 END RegAllocAdrMode;
 
 
 
 		  
 BEGIN
    airegister := ai; allocation[airegister].num := 0;
    IF IR.OptRegAlloc THEN 
       InOut.WriteString ('RegAlloc : ');
       InOut.WriteString ('Rule ='); InOut.WriteInt (rule,1); InOut.WriteLn;
       IF e#NIL THEN 
          IR.PrintAttributes (e^.attr^);
       ELSE 
          InOut.WriteString ('unknown attributes'); InOut.WriteLn;
       END;
       InOut.WriteString ('best   '); IR.PrintRegisterSet (first); InOut.WriteLn;
       InOut.WriteString ('medium '); IR.PrintRegisterSet (second); InOut.WriteLn;
       InOut.WriteString ('worst  '); IR.PrintRegisterSet (third); InOut.WriteLn;
    END;
 
         change[0]:={};
         changelocal[0]:={};
          lav[0]:=localavail[0];      
    RegAllocAdrMode (e,rule);
    
    sp := 0;
(*<<<<<<<<<<<<<<<
    WITH RuleDescr [rule] DO
>>>>>>>>>>>>>>>*)
       IF GcgTab.RuleDescr [rule].register=GcgTab.RKCalc THEN 
 	   ga:=e^.gcg;
             EXCL (localavail[0], (r));
;
          IF    ((r) IN third[0]) THEN 
	      oreg := r;
          ELSIF ~( (lav[0]*first[0]={})) THEN   (* he 08/91 *)
 	            av[0]:=lav[0]*first[0];      
     (* he 08/91 *)
             oreg := Take(av);                   (* he 08/91 *)
                   change[0]:=change[0]+GcgTab.RegDestroy[oreg][0];      
          ELSIF ~( (lav[0]*second[0]={})) THEN  (* he 08/91 *)
 	            av[0]:=lav[0]*second[0];      
    (* he 08/91 *)
             oreg := Take(av);                   (* he 08/91 *)
                   change[0]:=change[0]+GcgTab.RegDestroy[oreg][0];      
 	   ELSE
 	      sp := NewSpilllocation();
 	      oreg := ConsBase.RegNil;
          END;
            allocation[airegister].spilllocation := sp; allocation[airegister].reg := r; allocation[airegister].regmove := oreg;  (* he 08/91 *)
            allocation[airegister].actionafter := (sp#0) OR (oreg#r);  (* he 08/91 *)
                Change[0]:=change[0]+GcgTab.RuleDescr [rule].changeregs[0];      
          RETURN; 
       END;

       IF GcgTab.RuleDescr [rule].register#GcgTab.RKRegister THEN
                Change[0]:=change[0]+GcgTab.RuleDescr [rule].changeregs[0];      
       ELSE 
                av[0]:=lav[0]*GcgTab.RuleDescr [rule].resregs[0];      
          IF (GcgTab.RuleDescr [rule].target#0) OR (GcgTab.RuleDescr [rule].result#0) THEN 
 	      IF    ((targetregister) IN first[0]) OR
 	            ((targetregister) IN second[0]) OR
 	            ((targetregister) IN third[0]) THEN
 	         oreg := targetregister;
             ELSIF ~( (lav[0]*first[0]={})) THEN   (* he 08/91 *)
 	               av[0]:=lav[0]*first[0];      
     (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+GcgTab.RegDestroy[oreg][0];      
             ELSIF ~( (lav[0]*second[0]={})) THEN  (* he 08/91 *)
 	               av[0]:=lav[0]*second[0];      
    (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+GcgTab.RegDestroy[oreg][0];      
 	      ELSE
 	         sp := NewSpilllocation();
 	         oreg := ConsBase.RegNil;
 	      END;
 	      r := targetregister;
          ELSE
             IF GcgTab.RuleDescr [rule].unique THEN       av[0] :=av[0]-changelocal[0];      
; END;
             IF ~( (av[0]*first[0]={})) THEN 
 	               av[0]:=av[0]*first[0];      
 	         r := Take (av); oreg:=r;
             ELSIF ~( (av[0]*second[0]={})) THEN 
 	               av[0]:=av[0]*second[0];      
 	         r := Take (av); oreg:=r;
             ELSIF ~( (av[0]*third[0]={})) THEN 
 	               av[0]:=av[0]*third[0];      
 	         r := Take (av); oreg:=r;
             ELSIF ~( (lav[0]*first[0]={})) THEN   (* he 08/91 *)
                r := Take(av);                      (* he 08/91 *)
 	               av[0]:=lav[0]*first[0];      
     (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+GcgTab.RegDestroy[oreg][0];      
             ELSIF ~( (lav[0]*second[0]={})) THEN  (* he 08/91 *)
                r := Take(av);                      (* he 08/91 *)
 	               av[0]:=lav[0]*second[0];      
    (* he 08/91 *)
                oreg := Take(av);                   (* he 08/91 *)
                      change[0]:=change[0]+GcgTab.RegDestroy[oreg][0];      
             ELSE
 	         r := Take (av);
 	         oreg := ConsBase.RegNil;
 	         sp := NewSpilllocation();
             END;
          END;
          IF GcgTab.RuleDescr [rule].result=0 THEN
                   change[0]:=change[0]+GcgTab.RegDestroy[r][0];      
          END;
                Change[0]:=change[0]+GcgTab.RuleDescr [rule].changeregs[0];      
             allocation[airegister].spilllocation := sp; allocation[airegister].reg := r; allocation[airegister].regmove := oreg;  (* he 08/91 *)
             allocation[airegister].actionafter := (sp#0) OR (oreg#r);               (* he 08/91 *)
       END;
       IF GcgTab.RuleDescr [rule].scrnum#0 THEN 
                lav[0] :=lav[0]-changelocal[0];      
          FOR i:=1 TO GcgTab.RuleDescr [rule].scrnum DO 
                   av[0]:=lav[0]*GcgTab.RuleDescr [rule].scrrs[i][0];      
             r := Take(av);
             allocation[airegister].scr[i] := r;
                   lav[0] :=lav[0]-GcgTab.RegDestroy[r][0];      
;
                   Change[0]:=Change[0]+GcgTab.RegDestroy[r][0];      
;
          END;
       END;
       IF IR.OptRegAlloc THEN 
          InOut.WriteString ('Rule ='); InOut.WriteInt (rule,1); InOut.WriteLn;
          IF e#NIL THEN 
             IR.PrintAttributes (e^.attr^);
          ELSE 
             InOut.WriteString ('unknown attributes'); InOut.WriteLn;
          END;
          InOut.WriteString ('avail  '); IR.PrintRegisterSet (localavail); InOut.WriteLn;
          PrintAllocation (airegister);
       END;
(*<<<<<<<<<<<<<<<
    END;
>>>>>>>>>>>>>>>*)
 END RegAllocExpr;
 
 BEGIN
    lowpriority := ConsBase.RegNil;     (* he 8/91 *)
    ai:=1;
    ActSpilllocation := 1;
    IF e^.gcg^.stmtcost >= IR.infcost THEN 
       (* no code selected, do nothing *)
    ELSE
            emptyset[0]:={};
       RegAllocExpr (e,e^.gcg^.stmtrule,emptyset,emptyset,emptyset, r,s,ch);
    END;
 END RegAllo;
 
 
 
 PROCEDURE PrintAllocation* (i : AllocIndex);
 VAR j :LONGINT; 
 BEGIN
    InOut.WriteString ('ALLOC: '); InOut.WriteInt (i,2); InOut.Write (' ');
    IR.PrintRegister( allocation[i].reg ); 
    IF allocation[i].actionafter THEN  (* ++ he 08/91 *)
       InOut.Write('/');
       IF allocation[i].spilllocation#0 THEN InOut.WriteInt(allocation[i].spilllocation,1); END;
       IF allocation[i].regmove#ConsBase.RegNil THEN IR.PrintRegister(allocation[i].regmove); END;
    END; (* -- he 08/91 *)
    InOut.Write(' ');
    FOR j:=1 TO IR.MaxPscArity DO 
 
       IF (0<=allocation [i].op[j])
 	 & (ConsBase.MAX_BegRegister>=allocation[i].op[j]) THEN 
 	 IR.PrintRegister (allocation[i].op[j]);
       END;
       InOut.Write (' ');
    END;
       FOR j:=1 TO allocation [i].num DO
 	    CASE allocation [i].a[j].action OF 
 	    |  aLr : InOut.WriteString ('LR  ');
 		     IR.PrintRegister (allocation [i].a[j].regto);
 		     InOut.WriteString ('<-');
 		     IR.PrintRegister (allocation [i].a[j].regfrom);
 	    |  aRestore :
 		     InOut.WriteString ('RESTORE ');
 		     IR.PrintRegister (allocation [i].a[j].reg);
 		     InOut.WriteString (' FROM ');
 		     InOut.WriteInt (allocation [i].a[j].spilllocation,1);
 	    END;
 	    InOut.Write (' ');
    END;
    InOut.WriteLn;
 END PrintAllocation;
 
 BEGIN
 END RegAlloc.

