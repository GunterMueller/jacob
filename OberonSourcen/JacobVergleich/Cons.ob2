  (**************************************************************) 
  (*   This module was generated by BEG V1.75        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
 MODULE Cons;
 
 
 IMPORT     IR,
 SYSTEM,Emit,
(******* empty insertion IpIRConsStorage *******)
 Storage,

(******* empty insertion IpNtTypes *******)
(******* empty insertion IpText *******)
(******* empty insertion IpTypes *******)
(*++++++ start insertion IpCons_i ++++++*)
 ConsBase,ADR,ASM,ASMOP,Idents,LIM,LAB,OB,O,OT;
CONST 
      ntBReg         = IR.ntBReg;
      ntWReg         = IR.ntWReg;
      ntLReg         = IR.ntLReg;
      ntReg          = IR.ntReg;
      ntFXReg        = IR.ntFXReg;
      ntFYReg        = IR.ntFYReg;
      ntConstant     = IR.ntConstant;
      ntGv           = IR.ntGv;
      ntIreg         = IR.ntIreg;
      ntBreg         = IR.ntBreg;
      ntBregIreg     = IR.ntBregIreg;
      ntMemory       = IR.ntMemory;
      ntLab          = IR.ntLab;
      ntCond         = IR.ntCond;
      ntBool         = IR.ntBool;
      ntReducedStack = IR.ntReducedStack;
      ntStrCopyArgs  = IR.ntStrCopyArgs;
      ntArgs         = IR.ntArgs;
      ntRetyp        = IR.ntRetyp;
      ntAMem         = IR.ntAMem;
      ntAReg         = IR.ntAReg;
      ntAImm         = IR.ntAImm;
      ntAMemAReg     = IR.ntAMemAReg;
      ntAMemAImm     = IR.ntAMemAImm;
      ntARegAImm     = IR.ntARegAImm;
      ntAMemARegAImm = IR.ntAMemARegAImm;
      ntAVar         = IR.ntAVar;
              VAR    BooleanTab:ARRAY 2 OF LONGINT; 

              TYPE   tSize* = ConsBase.tSize;
              CONST  NoSize* = ConsBase.NoSize;
                     b* = ConsBase.b;
                     w* = ConsBase.w;
                     l* = ConsBase.l;
                     s* = ConsBase.s;
             TYPE    tRelation* = ConsBase.tRelation;
             CONST   NoRelation* = ConsBase.NoRelation;
                     equal* = ConsBase.equal;
                     unequal* = ConsBase.unequal;
                     less* = ConsBase.less;
                     lessORequal* = ConsBase.lessORequal;
                     greater* = ConsBase.greater;
                     greaterORequal* = ConsBase.greaterORequal;

(*------ end   insertion IpCons_d ------*)
 
 TYPE       
   BegRegister* = ConsBase.BegRegister;
CONST 
   RegNil* = ConsBase.RegNil;
   Regal* = ConsBase.Regal;
   Regah* = ConsBase.Regah;
   Regbl* = ConsBase.Regbl;
   Regbh* = ConsBase.Regbh;
   Regcl* = ConsBase.Regcl;
   Regch* = ConsBase.Regch;
   Regdl* = ConsBase.Regdl;
   Regdh* = ConsBase.Regdh;
   Regax* = ConsBase.Regax;
   Regbx* = ConsBase.Regbx;
   Regcx* = ConsBase.Regcx;
   Regdx* = ConsBase.Regdx;
   Regsi* = ConsBase.Regsi;
   Regdi* = ConsBase.Regdi;
   Regeax* = ConsBase.Regeax;
   Regebx* = ConsBase.Regebx;
   Regecx* = ConsBase.Regecx;
   Regedx* = ConsBase.Regedx;
   Regesi* = ConsBase.Regesi;
   Regedi* = ConsBase.Regedi;
   Regebp* = ConsBase.Regebp;
   Regesp* = ConsBase.Regesp;
   Regst* = ConsBase.Regst;
   Regst1* = ConsBase.Regst1;
   Regst2* = ConsBase.Regst2;
   Regst3* = ConsBase.Regst3;
   Regst4* = ConsBase.Regst4;
   Regst5* = ConsBase.Regst5;
   Regst6* = ConsBase.Regst6;
   Regst7* = ConsBase.Regst7;
   

(*------ end   insertion IpCons_i ------*)
 VAR
    FirstExpr, NextExpr, LastExpr    :  IR.Expression;
    FirstAttr, NextAttr, LastAttr    :  IR.Attributes;
    FirstGcg,  NextGcg,  LastGcg     :  IR.ExprAttributes;
 TYPE
     Address* = IR.Expression; 
     Data* = IR.Expression; 
     Label* = IR.Expression; 
     Condition* = IR.Expression; 
     Boolean* = IR.Expression; 
     Arguments* = IR.Expression; 
     StringCopyArguments* = IR.Expression; 
     ShrinkingStack* = IR.Expression; 
     Retype* = IR.Expression; 
 
 PROCEDURE MatchChainRules (e : IR.Expression);
 VAR   fired   : BOOLEAN;
       ga      : IR.ExprAttributes;
 BEGIN
    ga := e^.gcg;
      IF ga^.cost[ntMemory] > ga^.cost[ntGv] THEN
      (* RULE 7/994 *)
      ga^.cost[ntMemory] :=  ga^.cost[ntGv];
      ga^.rule[ntMemory] := 7;
   END;

      IF ga^.cost[ntMemory] > ga^.cost[ntIreg] THEN
      (* RULE 8/995 *)
      ga^.cost[ntMemory] :=  ga^.cost[ntIreg];
      ga^.rule[ntMemory] := 8;
   END;

      IF ga^.cost[ntMemory] > ga^.cost[ntBreg] THEN
      (* RULE 9/996 *)
      ga^.cost[ntMemory] :=  ga^.cost[ntBreg];
      ga^.rule[ntMemory] := 9;
   END;

      IF ga^.cost[ntMemory] > ga^.cost[ntBregIreg] THEN
      (* RULE 10/997 *)
      ga^.cost[ntMemory] :=  ga^.cost[ntBregIreg];
      ga^.rule[ntMemory] := 10;
   END;

      IF ga^.cost[ntAMem] > ga^.cost[ntMemory] THEN
      (* RULE 11/1001 *)
 ga^.AMem.size:=l     ; ;
      ga^.cost[ntAMem] :=  ga^.cost[ntMemory];
      ga^.rule[ntAMem] := 11;
   END;

      IF ga^.cost[ntAImm] > ga^.cost[ntConstant] THEN
      (* RULE 15/1005 *)
 ga^.AImm.size:=e^.gcg^.Constant.size; ;
      ga^.cost[ntAImm] :=  ga^.cost[ntConstant];
      ga^.rule[ntAImm] := 15;
   END;

      IF ga^.cost[ntAMemAReg] > ga^.cost[ntAMem] THEN
      (* RULE 16/1007 *)
 ga^.AMemAReg.size:=e^.gcg^.AMem.size; ;
      ga^.cost[ntAMemAReg] :=  ga^.cost[ntAMem];
      ga^.rule[ntAMemAReg] := 16;
   END;

      IF ga^.cost[ntAMemAImm] > ga^.cost[ntAMem] THEN
      (* RULE 18/1010 *)
 ga^.AMemAImm.size:=e^.gcg^.AMem.size; ;
      ga^.cost[ntAMemAImm] :=  ga^.cost[ntAMem];
      ga^.rule[ntAMemAImm] := 18;
   END;

      IF ga^.cost[ntAMemAImm] > ga^.cost[ntAImm] THEN
      (* RULE 19/1011 *)
 ga^.AMemAImm.size:=e^.gcg^.AImm.size; ;
      ga^.cost[ntAMemAImm] :=  ga^.cost[ntAImm];
      ga^.rule[ntAMemAImm] := 19;
   END;

      IF ga^.cost[ntARegAImm] > ga^.cost[ntAImm] THEN
      (* RULE 21/1014 *)
 ga^.ARegAImm.size:=e^.gcg^.AImm.size; ;
      ga^.cost[ntARegAImm] :=  ga^.cost[ntAImm];
      ga^.rule[ntARegAImm] := 21;
   END;

      IF ga^.cost[ntAMemARegAImm] > ga^.cost[ntAMem] THEN
      (* RULE 22/1016 *)
 ga^.AMemARegAImm.size:=e^.gcg^.AMem.size; ;
      ga^.cost[ntAMemARegAImm] :=  ga^.cost[ntAMem];
      ga^.rule[ntAMemARegAImm] := 22;
   END;

      IF ga^.cost[ntAMemARegAImm] > ga^.cost[ntAImm] THEN
      (* RULE 24/1018 *)
 ga^.AMemARegAImm.size:=e^.gcg^.AImm.size; ;
      ga^.cost[ntAMemARegAImm] :=  ga^.cost[ntAImm];
      ga^.rule[ntAMemARegAImm] := 24;
   END;

      IF ga^.cost[ntLReg] > ga^.cost[ntBregIreg] THEN
      (* RULE 37/1095 *)
      ga^.cost[ntLReg] :=  ga^.cost[ntBregIreg];
      ga^.rule[ntLReg] := 37;
   END;

      IF ga^.cost[ntBReg] > ga^.cost[ntAMemAImm]+2 THEN
      (* RULE 40/1113 *)
   IF  e^.gcg^.AMemAImm.size=b  THEN 
      ga^.cost[ntBReg] :=  ga^.cost[ntAMemAImm]+2;
      ga^.rule[ntBReg] := 40;
   END;
   END;

      IF ga^.cost[ntWReg] > ga^.cost[ntAMemAImm]+2 THEN
      (* RULE 41/1118 *)
   IF  e^.gcg^.AMemAImm.size=w  THEN 
      ga^.cost[ntWReg] :=  ga^.cost[ntAMemAImm]+2;
      ga^.rule[ntWReg] := 41;
   END;
   END;

      IF ga^.cost[ntLReg] > ga^.cost[ntAMemAImm]+2 THEN
      (* RULE 42/1123 *)
   IF  e^.gcg^.AMemAImm.size=l  THEN 
      ga^.cost[ntLReg] :=  ga^.cost[ntAMemAImm]+2;
      ga^.rule[ntLReg] := 42;
   END;
   END;

      IF ga^.cost[ntFXReg] > ga^.cost[ntAMem]+1 THEN
      (* RULE 324/3418 *)
      ga^.cost[ntFXReg] :=  ga^.cost[ntAMem]+1;
      ga^.rule[ntFXReg] := 324;
   END;

      IF ga^.cost[ntFYReg] > ga^.cost[ntFXReg]+2 THEN
      (* RULE 321/3402 *)
      ga^.cost[ntFYReg] :=  ga^.cost[ntFXReg]+2;
      ga^.rule[ntFYReg] := 321;
   END;

      IF ga^.cost[ntLReg] > ga^.cost[ntReg] THEN
      (* RULE 6/992 *)
   IF  e^.gcg^.Reg.size=l  THEN 
      ga^.cost[ntLReg] :=  ga^.cost[ntReg];
      ga^.rule[ntLReg] := 6;
   END;
   END;

      IF ga^.cost[ntReg] > ga^.cost[ntLReg] THEN
      (* RULE 3/988 *)
 ga^.Reg.size:=l; ;
      ga^.cost[ntReg] :=  ga^.cost[ntLReg];
      ga^.rule[ntReg] := 3;
   END;

      IF ga^.cost[ntWReg] > ga^.cost[ntReg] THEN
      (* RULE 5/991 *)
   IF  e^.gcg^.Reg.size=w  THEN 
      ga^.cost[ntWReg] :=  ga^.cost[ntReg];
      ga^.rule[ntWReg] := 5;
   END;
   END;

      IF ga^.cost[ntReg] > ga^.cost[ntWReg] THEN
      (* RULE 2/987 *)
 ga^.Reg.size:=w; ;
      ga^.cost[ntReg] :=  ga^.cost[ntWReg];
      ga^.rule[ntReg] := 2;
   END;

      IF ga^.cost[ntBReg] > ga^.cost[ntReg] THEN
      (* RULE 4/990 *)
   IF  e^.gcg^.Reg.size=b  THEN 
      ga^.cost[ntBReg] :=  ga^.cost[ntReg];
      ga^.rule[ntBReg] := 4;
   END;
   END;

      IF ga^.cost[ntReg] > ga^.cost[ntBReg] THEN
      (* RULE 1/986 *)
 ga^.Reg.size:=b; ;
      ga^.cost[ntReg] :=  ga^.cost[ntBReg];
      ga^.rule[ntReg] := 1;
   END;

      IF ga^.cost[ntWReg] > ga^.cost[ntReg] THEN
      (* RULE 5/991 *)
   IF  e^.gcg^.Reg.size=w  THEN 
      ga^.cost[ntWReg] :=  ga^.cost[ntReg];
      ga^.rule[ntWReg] := 5;
   END;
   END;

      IF ga^.cost[ntLReg] > ga^.cost[ntReg] THEN
      (* RULE 6/992 *)
   IF  e^.gcg^.Reg.size=l  THEN 
      ga^.cost[ntLReg] :=  ga^.cost[ntReg];
      ga^.rule[ntLReg] := 6;
   END;
   END;

      IF ga^.cost[ntAReg] > ga^.cost[ntLReg] THEN
      (* RULE 14/1004 *)
 ga^.AReg.size:=l     ; ;
      ga^.cost[ntAReg] :=  ga^.cost[ntLReg];
      ga^.rule[ntAReg] := 14;
   END;

      IF ga^.cost[ntAReg] > ga^.cost[ntWReg] THEN
      (* RULE 13/1003 *)
 ga^.AReg.size:=w     ; ;
      ga^.cost[ntAReg] :=  ga^.cost[ntWReg];
      ga^.rule[ntAReg] := 13;
   END;

      IF ga^.cost[ntAReg] > ga^.cost[ntBReg] THEN
      (* RULE 12/1002 *)
 ga^.AReg.size:=b     ; ;
      ga^.cost[ntAReg] :=  ga^.cost[ntBReg];
      ga^.rule[ntAReg] := 12;
   END;

      IF ga^.cost[ntAMemARegAImm] > ga^.cost[ntAReg] THEN
      (* RULE 23/1017 *)
 ga^.AMemARegAImm.size:=e^.gcg^.AReg.size; ;
      ga^.cost[ntAMemARegAImm] :=  ga^.cost[ntAReg];
      ga^.rule[ntAMemARegAImm] := 23;
   END;

      IF ga^.cost[ntARegAImm] > ga^.cost[ntAReg] THEN
      (* RULE 20/1013 *)
 ga^.ARegAImm.size:=e^.gcg^.AReg.size; ;
      ga^.cost[ntARegAImm] :=  ga^.cost[ntAReg];
      ga^.rule[ntARegAImm] := 20;
   END;

      IF ga^.cost[ntAMemAReg] > ga^.cost[ntAReg] THEN
      (* RULE 17/1008 *)
 ga^.AMemAReg.size:=e^.gcg^.AReg.size; ;
      ga^.cost[ntAMemAReg] :=  ga^.cost[ntAReg];
      ga^.rule[ntAMemAReg] := 17;
   END;

 END MatchChainRules;

 PROCEDURE MemExtend;
 VAR i : LONGINT;
     e,le : IR.Expression;
     a,la : IR.Attributes;
     g,lg : IR.ExprAttributes;
 BEGIN 
    NEW (NextAttr); NEW (NextExpr); NEW (NextGcg);
    NextAttr^.hashchain := NIL;
    NextExpr^.hashchain := NIL;
    NextGcg^. hashchain := NIL;
    la:=NextAttr; le:=NextExpr; lg:=NextGcg;
    FOR i:=1 TO 
(******* empty insertion IpMemSize *******)
        30
    DO 
        NEW (a); a^.hashchain := NextAttr; NextAttr := a;
        NEW (e); e^.hashchain := NextExpr; NextExpr := e;
        NEW (g); g^.hashchain := NextGcg;  NextGcg  := g;
    END;
    IF FirstAttr=NIL THEN 
       FirstAttr:=NextAttr; FirstExpr:=NextExpr; FirstGcg:=NextGcg;
    ELSE
       LastAttr^.hashchain := NextAttr;
       LastExpr^.hashchain := NextExpr;
       LastGcg^.hashchain  := NextGcg;
    END;
    LastAttr:=la; LastExpr := le; LastGcg  := lg;
 END MemExtend;

 PROCEDURE  GlobalVariable* (
                      Atlabel  :  LAB.T;
                      Atadr  :  LONGINT;
                      AtcmtIdent  :  Idents.tIdent
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opGlobalVariable;
   a^.GlobalVariable.label := Atlabel;
   a^.GlobalVariable.adr := Atadr;
   a^.GlobalVariable.cmtIdent := AtcmtIdent;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 25/1024 *)
   IF 0 <   ga^.cost[ntGv]  THEN 
     ga^.cost[ntGv] := 0; 
     ga^.rule[ntGv] := 25;
   END;
     (* RULE 147/2142 *)
   IF 0 <   ga^.cost[ntGv]  THEN 
     ga^.cost[ntGv] := 0; 
     ga^.rule[ntGv] := 147;
   END;
     (* RULE 294/3274 *)
   IF 0 <   ga^.cost[ntAVar]  THEN 
 ga^.AVar.var.label    := e^.attr^.GlobalVariable.label; 
      ga^.AVar.var.frame    := 0;
      ga^.AVar.var.ofs      := e^.attr^.GlobalVariable.adr; 
      ga^.AVar.var.tmpreg   := RegNil; 
      ga^.AVar.var.cmtIdent := e^.attr^.GlobalVariable.cmtIdent; ;
     ga^.cost[ntAVar] := 0; 
     ga^.rule[ntAVar] := 294;
   END;
   MatchChainRules(e);
 END GlobalVariable;


 PROCEDURE  LocalVariable* (
                      Atadr  :  LONGINT;
                      AtcmtIdent  :  Idents.tIdent
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLocalVariable;
   a^.LocalVariable.adr := Atadr;
   a^.LocalVariable.cmtIdent := AtcmtIdent;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 26/1033 *)
   IF 0 <   ga^.cost[ntBreg]  THEN 
     ga^.cost[ntBreg] := 0; 
     ga^.rule[ntBreg] := 26;
   END;
     (* RULE 148/2151 *)
   IF 0 <   ga^.cost[ntBreg]  THEN 
     ga^.cost[ntBreg] := 0; 
     ga^.rule[ntBreg] := 148;
   END;
     (* RULE 295/3281 *)
   IF 0 <   ga^.cost[ntAVar]  THEN 
 ga^.AVar.var.label    := LAB.MT; 
      ga^.AVar.var.frame    := 0;
      ga^.AVar.var.ofs      := e^.attr^.LocalVariable.adr; 
      ga^.AVar.var.tmpreg   := RegNil; 
      ga^.AVar.var.cmtIdent := e^.attr^.LocalVariable.cmtIdent; ;
     ga^.cost[ntAVar] := 0; 
     ga^.rule[ntAVar] := 295;
   END;
   MatchChainRules(e);
 END LocalVariable;


 PROCEDURE  Selector* (
                      Atofs  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSelector;
   a^.Selector.ofs := Atofs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 27/1043 *)
    c:=       e^.son[1]^.gcg^.cost[ntGv];
   IF c <   ga^.cost[ntGv]  THEN 
     ga^.cost[ntGv] := c; 
     ga^.rule[ntGv] := 27;
   END;
     (* RULE 28/1046 *)
    c:=       e^.son[1]^.gcg^.cost[ntIreg];
   IF c <   ga^.cost[ntIreg]  THEN 
     ga^.cost[ntIreg] := c; 
     ga^.rule[ntIreg] := 28;
   END;
     (* RULE 29/1049 *)
    c:=       e^.son[1]^.gcg^.cost[ntBreg];
   IF c <   ga^.cost[ntBreg]  THEN 
     ga^.cost[ntBreg] := c; 
     ga^.rule[ntBreg] := 29;
   END;
     (* RULE 30/1052 *)
    c:=       e^.son[1]^.gcg^.cost[ntBregIreg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 30;
   END;
     (* RULE 149/2161 *)
    c:=       e^.son[1]^.gcg^.cost[ntGv];
   IF c <   ga^.cost[ntGv]  THEN 
     ga^.cost[ntGv] := c; 
     ga^.rule[ntGv] := 149;
   END;
     (* RULE 150/2164 *)
    c:=       e^.son[1]^.gcg^.cost[ntIreg];
   IF c <   ga^.cost[ntIreg]  THEN 
     ga^.cost[ntIreg] := c; 
     ga^.rule[ntIreg] := 150;
   END;
     (* RULE 151/2167 *)
    c:=       e^.son[1]^.gcg^.cost[ntBreg];
   IF c <   ga^.cost[ntBreg]  THEN 
     ga^.cost[ntBreg] := c; 
     ga^.rule[ntBreg] := 151;
   END;
     (* RULE 152/2170 *)
    c:=       e^.son[1]^.gcg^.cost[ntBregIreg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 152;
   END;
     (* RULE 296/3288 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opPointerFrom THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opContentOf THEN 
   IF e3^.son[1]^.attr^.op = IR.opLocalVariable THEN 
   IF 0 <   ga^.cost[ntAVar]  THEN 
 ga^.AVar.var.label    := LAB.MT; 
      ga^.AVar.var.frame    := e^.attr^.Selector.ofs;
      ga^.AVar.var.ofs      := e^.son[1]^.son[1]^.son[1]^.attr^.LocalVariable.adr; 
      ga^.AVar.var.tmpreg   := RegNil; 
      ga^.AVar.var.cmtIdent := e^.son[1]^.son[1]^.son[1]^.attr^.LocalVariable.cmtIdent; ;
     ga^.cost[ntAVar] := 0; 
     ga^.rule[ntAVar] := 296;
   END;
   END;
   END;
   END;
     (* RULE 297/3298 *)
    c:=       e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.cost[ntAVar]  THEN 
 ga^.AVar.var:=e^.son[1]^.gcg^.AVar.var; INC(ga^.AVar.var.ofs,e^.attr^.Selector.ofs); ;
     ga^.cost[ntAVar] := c; 
     ga^.rule[ntAVar] := 297;
   END;
   MatchChainRules(e);
 END Selector;


 PROCEDURE  Index* (
                      Atfactor  :  LONGINT
                      ;  op1  : Address
                      ;  op2  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opIndex;
   a^.Index.factor := Atfactor;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 31/1056 *)
    c:=       e^.son[1]^.gcg^.cost[ntGv]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntIreg]  THEN 
   IF  e^.attr^.Index.factor>1  THEN 
     ga^.cost[ntIreg] := c; 
     ga^.rule[ntIreg] := 31;
   END;
   END;
     (* RULE 32/1062 *)
    c:=       e^.son[1]^.gcg^.cost[ntGv]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBreg]  THEN 
   IF  e^.attr^.Index.factor=1  THEN 
     ga^.cost[ntBreg] := c; 
     ga^.rule[ntBreg] := 32;
   END;
   END;
     (* RULE 33/1067 *)
    c:=       e^.son[1]^.gcg^.cost[ntIreg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
   IF  e^.attr^.Index.factor>1  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 33;
   END;
   END;
     (* RULE 34/1077 *)
    c:=       e^.son[1]^.gcg^.cost[ntIreg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
   IF  e^.attr^.Index.factor=1  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 34;
   END;
   END;
     (* RULE 35/1082 *)
    c:=       e^.son[1]^.gcg^.cost[ntBreg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 35;
   END;
     (* RULE 36/1087 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 36;
   END;
     (* RULE 153/2174 *)
    c:=       e^.son[1]^.gcg^.cost[ntGv]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntIreg]  THEN 
   IF  e^.attr^.Index.factor>1  THEN 
     ga^.cost[ntIreg] := c; 
     ga^.rule[ntIreg] := 153;
   END;
   END;
     (* RULE 154/2180 *)
    c:=       e^.son[1]^.gcg^.cost[ntGv]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBreg]  THEN 
   IF  e^.attr^.Index.factor=1  THEN 
     ga^.cost[ntBreg] := c; 
     ga^.rule[ntBreg] := 154;
   END;
   END;
     (* RULE 155/2185 *)
    c:=       e^.son[1]^.gcg^.cost[ntIreg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
   IF  e^.attr^.Index.factor>1  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 155;
   END;
   END;
     (* RULE 156/2195 *)
    c:=       e^.son[1]^.gcg^.cost[ntIreg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
   IF  e^.attr^.Index.factor=1  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 156;
   END;
   END;
     (* RULE 157/2200 *)
    c:=       e^.son[1]^.gcg^.cost[ntBreg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 157;
   END;
     (* RULE 158/2205 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 158;
   END;
   MatchChainRules(e);
 END Index;


 PROCEDURE  PointerFrom* (
                         op1  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPointerFrom;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 38/1099 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBreg]  THEN 
     ga^.cost[ntBreg] := c; 
     ga^.rule[ntBreg] := 38;
   END;
     (* RULE 160/2217 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBreg]  THEN 
     ga^.cost[ntBreg] := c; 
     ga^.rule[ntBreg] := 160;
   END;
   MatchChainRules(e);
 END PointerFrom;


 PROCEDURE  SimpleAssignment* (
                         op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opSimpleAssignment;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 44/1134 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntARegAImm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 44;
   END;
     (* RULE 298/3302 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opMonOper THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntAVar];
    c:=  c+     e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.stmtcost  THEN 
   IF  ASM.AreEqualVariables(e^.son[1]^.gcg^.AVar.var,e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 298;
   END;
   END;
   END;
   END;
     (* RULE 299/3313 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntAVar];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ASM.AreEqualVariables(e^.son[1]^.gcg^.AVar.var,e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var) & ADR.IntLog2(e^.son[2]^.son[1]^.gcg^.Constant.val,e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var.log2)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 299;
   END;
   END;
   END;
   END;
     (* RULE 300/3313 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntAVar];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ASM.AreEqualVariables(e^.son[1]^.gcg^.AVar.var,e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var) & ADR.IntLog2(e^.son[2]^.son[2]^.gcg^.Constant.val,e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.log2)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 300;
   END;
   END;
   END;
   END;
     (* RULE 301/3324 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntAVar];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntARegAImm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.son[2]^.attr^.SymDyOper.code#ASMOP.imul) & ASM.AreEqualVariables(e^.son[1]^.gcg^.AVar.var,e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 301;
   END;
   END;
   END;
   END;
     (* RULE 302/3324 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntAVar];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntARegAImm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.stmtcost  THEN 
   IF  (e^.son[2]^.attr^.SymDyOper.code#ASMOP.imul) & ASM.AreEqualVariables(e^.son[1]^.gcg^.AVar.var,e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 302;
   END;
   END;
   END;
   END;
     (* RULE 303/3336 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSub THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntAVar];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntARegAImm];
    c:=  c+     e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.stmtcost  THEN 
   IF  ASM.AreEqualVariables(e^.son[1]^.gcg^.AVar.var,e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 303;
   END;
   END;
   END;
   END;
     (* RULE 304/3348 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opDiv THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntAVar];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntAVar];
   IF c <   ga^.stmtcost  THEN 
   IF  ASM.AreEqualVariables(e^.son[1]^.gcg^.AVar.var,e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var) & ADR.IntLog2(e^.son[2]^.son[2]^.gcg^.Constant.val,e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.log2)  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 304;
   END;
   END;
   END;
   END;
   Emit.EmitInstruction (e);
 END SimpleAssignment;


 PROCEDURE  MemCopy* (
                      Atlen  :  LONGINT;
                      AtisStringCopy  :  BOOLEAN
                      ;  op1  : Address
                      ;  op2  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opMemCopy;
   a^.MemCopy.len := Atlen;
   a^.MemCopy.isStringCopy := AtisStringCopy;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 45/1139 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 45;
   END;
   Emit.EmitInstruction (e);
 END MemCopy;


 PROCEDURE  ShortConstStrCopy* (
                      AtstrVal  :  LONGINT;
                      Atlen  :  LONGINT
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opShortConstStrCopy;
   a^.ShortConstStrCopy.strVal := AtstrVal;
   a^.ShortConstStrCopy.len := Atlen;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 46/1145 *)
    c:=  5+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 46;
   END;
   Emit.EmitInstruction (e);
 END ShortConstStrCopy;


 PROCEDURE  StrCopy* (
                         op1  : StringCopyArguments
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opStrCopy;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 47/1166 *)
    c:=       e^.son[1]^.gcg^.cost[ntStrCopyArgs];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 47;
   END;
     (* RULE 207/2488 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opStrCopyArguments THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opImplicifyConst THEN 
    c:=       e3^.son[1]^.gcg^.cost[ntMemory];
   e3 := e2^.son[2];
   IF e3^.attr^.op = IR.opImplicifyConst THEN 
    c:=  c+     e3^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 207;
   END;
   END;
   END;
   END;
   Emit.EmitInstruction (e);
 END StrCopy;


 PROCEDURE  StrCopyArguments* (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : StringCopyArguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opStrCopyArguments;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 48/1182 *)
    c:=  5+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntStrCopyArgs]  THEN 
     ga^.cost[ntStrCopyArgs] := c; 
     ga^.rule[ntStrCopyArgs] := 48;
   END;
     (* RULE 208/2528 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opImplicify THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opImplicify THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntStrCopyArgs]  THEN 
     ga^.cost[ntStrCopyArgs] := c; 
     ga^.rule[ntStrCopyArgs] := 208;
   END;
   END;
   END;
     (* RULE 209/2558 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opImplicifyConst THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opImplicify THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntStrCopyArgs]  THEN 
     ga^.cost[ntStrCopyArgs] := c; 
     ga^.rule[ntStrCopyArgs] := 209;
   END;
   END;
   END;
     (* RULE 210/2580 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opImplicify THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opImplicifyConst THEN 
    c:=  c+     e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntStrCopyArgs]  THEN 
     ga^.cost[ntStrCopyArgs] := c; 
     ga^.rule[ntStrCopyArgs] := 210;
   END;
   END;
   END;
   MatchChainRules(e);
 END StrCopyArguments;


 PROCEDURE  ImplicifyConst* (
                      Atlen  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opImplicifyConst;
   a^.ImplicifyConst.len := Atlen;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 49/1192 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 49;
   END;
   MatchChainRules(e);
 END ImplicifyConst;


 PROCEDURE  ImplicifyOpenIndexed* (
                      AtlenOfs  :  LONGINT;
                      AtisStackObject  :  BOOLEAN;
                      AtobjOfs  :  LONGINT
                      ;  op1  : ShrinkingStack
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opImplicifyOpenIndexed;
   a^.ImplicifyOpenIndexed.lenOfs := AtlenOfs;
   a^.ImplicifyOpenIndexed.isStackObject := AtisStackObject;
   a^.ImplicifyOpenIndexed.objOfs := AtobjOfs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 50/1197 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntReducedStack];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 50;
   END;
   MatchChainRules(e);
 END ImplicifyOpenIndexed;


 PROCEDURE  Implicify* (
                      AtlenOfs  :  LONGINT;
                      AtisStackObject  :  BOOLEAN;
                      AtobjOfs  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opImplicify;
   a^.Implicify.lenOfs := AtlenOfs;
   a^.Implicify.isStackObject := AtisStackObject;
   a^.Implicify.objOfs := AtobjOfs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 51/1208 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 51;
   END;
   MatchChainRules(e);
 END Implicify;


 PROCEDURE  MemSet3* (
                      Atv  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opMemSet3;
   a^.MemSet3.v := Atv;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 52/1222 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 52;
   END;
   Emit.EmitInstruction (e);
 END MemSet3;


 PROCEDURE  MemSet8* (
                      AtlrLo  :  LONGINT;
                      AtlrHi  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opMemSet8;
   a^.MemSet8.lrLo := AtlrLo;
   a^.MemSet8.lrHi := AtlrHi;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 53/1227 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 53;
   END;
   Emit.EmitInstruction (e);
 END MemSet8;


 PROCEDURE  ContentOf* (
                      Atsize  :  tSize
                      ;  op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opContentOf;
   a^.ContentOf.size := Atsize;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 39/1108 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntAMem]  THEN 
 ga^.AMem.size:=e^.attr^.ContentOf.size; ;
     ga^.cost[ntAMem] := c; 
     ga^.rule[ntAMem] := 39;
   END;
     (* RULE 288/3145 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opPointerFrom THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opPointerGuard THEN 
    c:=       e3^.son[1]^.gcg^.cost[ntMemory]+
     e3^.son[2]^.gcg^.cost[ntLReg]+
     e3^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.attr^.ContentOf.size=l  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 288;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END ContentOf;


 PROCEDURE  AddressOf* (
                         op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAddressOf;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 43/1129 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 43;
   END;
     (* RULE 214/2632 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opPointerFrom THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opContentOf THEN 
    c:=  2+     e3^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.son[1]^.son[1]^.attr^.ContentOf.size=l  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 214;
   END;
   END;
   END;
   END;
     (* RULE 215/2640 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSelector THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opPointerFrom THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = IR.opContentOf THEN 
    c:=  2+     e4^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.son[1]^.son[1]^.son[1]^.attr^.ContentOf.size=l) & (e^.son[1]^.attr^.Selector.ofs=0)  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 215;
   END;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END AddressOf;


 PROCEDURE  NoParam* (
                         VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opNoParam;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 54/1233 *)
   IF 0 <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := 0; 
     ga^.rule[ntArgs] := 54;
   END;
   MatchChainRules(e);
 END NoParam;


 PROCEDURE  Param* (
                         op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 55/1235 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntAMemARegAImm];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 55;
   END;
     (* RULE 211/2603 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opAddressOf THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntGv];
    c:=  c+     e^.son[1]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 211;
   END;
   END;
     (* RULE 212/2610 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opAddressOf THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opPointerFrom THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e4^.son[1]^.gcg^.cost[ntMemory];
    c:=  c+     e^.son[1]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntArgs]  THEN 
   IF  e^.son[2]^.son[1]^.son[1]^.attr^.ContentOf.size=l  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 212;
   END;
   END;
   END;
   END;
   END;
     (* RULE 213/2620 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opAddressOf THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opSelector THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = IR.opPointerFrom THEN 
   e5 := e4^.son[1];
   IF e5^.attr^.op = IR.opContentOf THEN 
    c:=  1+     e5^.son[1]^.gcg^.cost[ntMemory];
    c:=  c+     e^.son[1]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntArgs]  THEN 
   IF  (e^.son[2]^.son[1]^.son[1]^.son[1]^.attr^.ContentOf.size=l) & (e^.son[2]^.son[1]^.attr^.Selector.ofs=0)  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 213;
   END;
   END;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END Param;


 PROCEDURE  Param0* (
                         op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam0;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 56/1243 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 56;
   END;
   MatchChainRules(e);
 END Param0;


 PROCEDURE  Param8* (
                      AtlrLo  :  LONGINT;
                      AtlrHi  :  LONGINT
                      ;  op1  : Arguments
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam8;
   a^.Param8.lrLo := AtlrLo;
   a^.Param8.lrHi := AtlrHi;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 57/1245 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 57;
   END;
   MatchChainRules(e);
 END Param8;


 PROCEDURE  Param_AddrAndTag* (
                         op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_AddrAndTag;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 58/1250 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 58;
   END;
   MatchChainRules(e);
 END Param_AddrAndTag;


 PROCEDURE  Param_LensAndAddr* (
                      AtnofOpenLens  :  LONGINT
                      ;  op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_LensAndAddr;
   a^.Param_LensAndAddr.nofOpenLens := AtnofOpenLens;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 59/1256 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 59;
   END;
   MatchChainRules(e);
 END Param_LensAndAddr;


 PROCEDURE  Param_LensAndNewNofElemsAndAddr* (
                      AtnofOpenLens  :  LONGINT;
                      AtbaseNofElems  :  LONGINT
                      ;  op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_LensAndNewNofElemsAndAddr;
   a^.Param_LensAndNewNofElemsAndAddr.nofOpenLens := AtnofOpenLens;
   a^.Param_LensAndNewNofElemsAndAddr.baseNofElems := AtbaseNofElems;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 60/1263 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 60;
   END;
   MatchChainRules(e);
 END Param_LensAndNewNofElemsAndAddr;


 PROCEDURE  Param_Lens* (
                      AtnofOpenLens  :  LONGINT;
                      AtlastLenOfs  :  LONGINT
                      ;  op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_Lens;
   a^.Param_Lens.nofOpenLens := AtnofOpenLens;
   a^.Param_Lens.lastLenOfs := AtlastLenOfs;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 61/1292 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 61;
   END;
   MatchChainRules(e);
 END Param_Lens;


 PROCEDURE  Param_LensAndNewNofElems* (
                      AtnofOpenLens  :  LONGINT;
                      AtlastLenOfs  :  LONGINT;
                      AtbaseNofElems  :  LONGINT
                      ;  op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_LensAndNewNofElems;
   a^.Param_LensAndNewNofElems.nofOpenLens := AtnofOpenLens;
   a^.Param_LensAndNewNofElems.lastLenOfs := AtlastLenOfs;
   a^.Param_LensAndNewNofElems.baseNofElems := AtbaseNofElems;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 62/1298 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 62;
   END;
   MatchChainRules(e);
 END Param_LensAndNewNofElems;


 PROCEDURE  Param_RecordSizeAndAddr* (
                         op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_RecordSizeAndAddr;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 63/1327 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 63;
   END;
   MatchChainRules(e);
 END Param_RecordSizeAndAddr;


 PROCEDURE  Param_OArrSizeAndAddr* (
                      AtobjOfs  :  LONGINT;
                      AtelemSize  :  LONGINT
                      ;  op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_OArrSizeAndAddr;
   a^.Param_OArrSizeAndAddr.objOfs := AtobjOfs;
   a^.Param_OArrSizeAndAddr.elemSize := AtelemSize;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 64/1334 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 64;
   END;
   MatchChainRules(e);
 END Param_OArrSizeAndAddr;


 PROCEDURE  Param_PartialOArrSizeAndAddrOfPar* (
                         op1  : Arguments
                      ;  op2  : ShrinkingStack
                      ;  op3  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_PartialOArrSizeAndAddrOfPar;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 65/1346 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReducedStack]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 65;
   END;
   MatchChainRules(e);
 END Param_PartialOArrSizeAndAddrOfPar;


 PROCEDURE  Param_PartialOArrSizeAndAddrOfPtr* (
                      AtobjOfs  :  LONGINT
                      ;  op1  : Arguments
                      ;  op2  : ShrinkingStack
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opParam_PartialOArrSizeAndAddrOfPtr;
   a^.Param_PartialOArrSizeAndAddrOfPtr.objOfs := AtobjOfs;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 66/1351 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntReducedStack];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 66;
   END;
   MatchChainRules(e);
 END Param_PartialOArrSizeAndAddrOfPtr;


 PROCEDURE  DirectCall* (
                      AtparamSpace  :  LONGINT;
                      Atlabel  :  LAB.T
                      ;  op1  : Arguments
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opDirectCall;
   a^.DirectCall.paramSpace := AtparamSpace;
   a^.DirectCall.label := Atlabel;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 67/1357 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntMemory]  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 67;
   END;
   MatchChainRules(e);
 END DirectCall;


 PROCEDURE  IndirectCall* (
                      AtparamSpace  :  LONGINT
                      ;  op1  : Data
                      ;  op2  : Arguments
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opIndirectCall;
   a^.IndirectCall.paramSpace := AtparamSpace;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 68/1365 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntMemory]  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 68;
   END;
   MatchChainRules(e);
 END IndirectCall;


 PROCEDURE  BoundCall_FPtr_APtr* (
                      AtbprocLab  :  LAB.T;
                      AtprocOfs  :  LONGINT;
                      AtparamSpace  :  LONGINT
                      ;  op1  : Data
                      ;  op2  : Arguments
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBoundCall_FPtr_APtr;
   a^.BoundCall_FPtr_APtr.bprocLab := AtbprocLab;
   a^.BoundCall_FPtr_APtr.procOfs := AtprocOfs;
   a^.BoundCall_FPtr_APtr.paramSpace := AtparamSpace;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 69/1373 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntMemory]  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 69;
   END;
   MatchChainRules(e);
 END BoundCall_FPtr_APtr;


 PROCEDURE  BoundCall_FRec_APtr* (
                      AtbprocLab  :  LAB.T;
                      AtprocOfs  :  LONGINT;
                      AtparamSpace  :  LONGINT
                      ;  op1  : Data
                      ;  op2  : Arguments
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBoundCall_FRec_APtr;
   a^.BoundCall_FRec_APtr.bprocLab := AtbprocLab;
   a^.BoundCall_FRec_APtr.procOfs := AtprocOfs;
   a^.BoundCall_FRec_APtr.paramSpace := AtparamSpace;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 70/1388 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntMemory]  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 70;
   END;
   MatchChainRules(e);
 END BoundCall_FRec_APtr;


 PROCEDURE  BoundCall_FRec_ARec* (
                      AtbprocLab  :  LAB.T;
                      AtprocOfs  :  LONGINT;
                      AtparamSpace  :  LONGINT
                      ;  op1  : Data
                      ;  op2  : Arguments
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBoundCall_FRec_ARec;
   a^.BoundCall_FRec_ARec.bprocLab := AtbprocLab;
   a^.BoundCall_FRec_ARec.procOfs := AtprocOfs;
   a^.BoundCall_FRec_ARec.paramSpace := AtparamSpace;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 71/1404 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntArgs];
   IF c <   ga^.cost[ntMemory]  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 71;
   END;
   MatchChainRules(e);
 END BoundCall_FRec_ARec;


 PROCEDURE  ProcReturn* (
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opProcReturn;
   e^.arity := 0;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 72/1419 *)
   IF 0 <   ga^.stmtcost  THEN 
     ga^.stmtcost := 0; 
     ga^.stmtrule := 72;
   END;
   Emit.EmitInstruction (e);
 END ProcReturn;


 PROCEDURE  FuncReturn* (
                         op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opFuncReturn;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 73/1424 *)
    c:=       e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 73;
   END;
     (* RULE 74/1429 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 74;
   END;
     (* RULE 75/1434 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 75;
   END;
   Emit.EmitInstruction (e);
 END FuncReturn;


 PROCEDURE  NoFuncResult* (
                         op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opNoFuncResult;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 76/1440 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 76;
   END;
   Emit.EmitInstruction (e);
 END NoFuncResult;


 PROCEDURE  FuncResultOf* (
                      Atsize  :  tSize
                      ;  op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFuncResultOf;
   a^.FuncResultOf.size := Atsize;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 77/1443 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntBReg]  THEN 
   IF  e^.attr^.FuncResultOf.size=b  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 77;
   END;
   END;
     (* RULE 78/1447 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntWReg]  THEN 
   IF  e^.attr^.FuncResultOf.size=w  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 78;
   END;
   END;
     (* RULE 79/1451 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.attr^.FuncResultOf.size=l  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 79;
   END;
   END;
   MatchChainRules(e);
 END FuncResultOf;


 PROCEDURE  CaseExpr* (
                      AtisChar  :  BOOLEAN;
                      AtminVal  :  LONGINT;
                      AtmaxVal  :  LONGINT;
                      AttabLabel  :  LAB.T;
                      AtelseLabel  :  LAB.T
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opCaseExpr;
   a^.CaseExpr.isChar := AtisChar;
   a^.CaseExpr.minVal := AtminVal;
   a^.CaseExpr.maxVal := AtmaxVal;
   a^.CaseExpr.tabLabel := AttabLabel;
   a^.CaseExpr.elseLabel := AtelseLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 80/1458 *)
    c:=       e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 80;
   END;
   Emit.EmitInstruction (e);
 END CaseExpr;


 PROCEDURE  ForStmt* (
                      AttempOfs  :  LONGINT;
                      Atstep  :  LONGINT;
                      AtloopLabel  :  LAB.T;
                      AtcondLabel  :  LAB.T;
                      Atsize  :  tSize
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opForStmt;
   a^.ForStmt.tempOfs := AttempOfs;
   a^.ForStmt.step := Atstep;
   a^.ForStmt.loopLabel := AtloopLabel;
   a^.ForStmt.condLabel := AtcondLabel;
   a^.ForStmt.size := Atsize;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 81/1483 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 81;
   END;
   Emit.EmitInstruction (e);
 END ForStmt;


 PROCEDURE  MonOper* (
                      Atcode  :  ASMOP.tOper
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opMonOper;
   a^.MonOper.code := Atcode;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 82/1508 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 82;
   END;
     (* RULE 328/3440 *)
    c:=       e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 328;
   END;
   MatchChainRules(e);
 END MonOper;


 PROCEDURE  SymDyOper* (
                      Atcode  :  ASMOP.tOper
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSymDyOper;
   a^.SymDyOper.code := Atcode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 83/1515 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntAMemARegAImm]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[2]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 83;
   END;
     (* RULE 84/1515 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntReg]+
     e^.son[2]^.gcg^.cost[ntAMemARegAImm];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 84;
   END;
     (* RULE 305/3362 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntConstant]+
     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[1]^.gcg^.Constant.val=2) OR (e^.son[1]^.son[1]^.gcg^.Constant.val=4) OR (e^.son[1]^.son[1]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 305;
   END;
   END;
   END;
     (* RULE 306/3362 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntLReg]+
     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[2]^.gcg^.Constant.val=2) OR (e^.son[1]^.son[2]^.gcg^.Constant.val=4) OR (e^.son[1]^.son[2]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 306;
   END;
   END;
   END;
     (* RULE 307/3362 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntConstant]+
     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[1]^.gcg^.Constant.val=2) OR (e^.son[2]^.son[1]^.gcg^.Constant.val=4) OR (e^.son[2]^.son[1]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 307;
   END;
   END;
   END;
     (* RULE 308/3362 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntLReg]+
     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[2]^.gcg^.Constant.val=2) OR (e^.son[2]^.son[2]^.gcg^.Constant.val=4) OR (e^.son[2]^.son[2]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 308;
   END;
   END;
   END;
     (* RULE 309/3372 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntConstant]+
     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[1]^.gcg^.Constant.val=3) OR (e^.son[1]^.son[1]^.gcg^.Constant.val=5) OR (e^.son[1]^.son[1]^.gcg^.Constant.val=9))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 309;
   END;
   END;
   END;
     (* RULE 310/3372 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntLReg]+
     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[2]^.gcg^.Constant.val=3) OR (e^.son[1]^.son[2]^.gcg^.Constant.val=5) OR (e^.son[1]^.son[2]^.gcg^.Constant.val=9))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 310;
   END;
   END;
   END;
     (* RULE 311/3372 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntConstant]+
     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[1]^.gcg^.Constant.val=3) OR (e^.son[2]^.son[1]^.gcg^.Constant.val=5) OR (e^.son[2]^.son[1]^.gcg^.Constant.val=9))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 311;
   END;
   END;
   END;
     (* RULE 312/3372 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntLReg]+
     e2^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[2]^.gcg^.Constant.val=3) OR (e^.son[2]^.son[2]^.gcg^.Constant.val=5) OR (e^.son[2]^.son[2]^.gcg^.Constant.val=9))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 312;
   END;
   END;
   END;
     (* RULE 313/3382 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntConstant]+
     e3^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[1]^.son[1]^.gcg^.Constant.val=2) OR (e^.son[1]^.son[1]^.son[1]^.gcg^.Constant.val=4) OR (e^.son[1]^.son[1]^.son[1]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 313;
   END;
   END;
   END;
   END;
     (* RULE 314/3382 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntLReg]+
     e3^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[1]^.son[2]^.gcg^.Constant.val=2) OR (e^.son[1]^.son[1]^.son[2]^.gcg^.Constant.val=4) OR (e^.son[1]^.son[1]^.son[2]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 314;
   END;
   END;
   END;
   END;
     (* RULE 315/3382 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntConstant]+
     e3^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[2]^.son[1]^.gcg^.Constant.val=2) OR (e^.son[1]^.son[2]^.son[1]^.gcg^.Constant.val=4) OR (e^.son[1]^.son[2]^.son[1]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 315;
   END;
   END;
   END;
   END;
     (* RULE 316/3382 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntLReg]+
     e3^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[1]^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[1]^.son[2]^.son[2]^.gcg^.Constant.val=2) OR (e^.son[1]^.son[2]^.son[2]^.gcg^.Constant.val=4) OR (e^.son[1]^.son[2]^.son[2]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 316;
   END;
   END;
   END;
   END;
     (* RULE 317/3382 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntConstant]+
     e3^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[1]^.son[1]^.gcg^.Constant.val=2) OR (e^.son[2]^.son[1]^.son[1]^.gcg^.Constant.val=4) OR (e^.son[2]^.son[1]^.son[1]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 317;
   END;
   END;
   END;
   END;
     (* RULE 318/3382 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntLReg]+
     e3^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.son[1]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[1]^.son[2]^.gcg^.Constant.val=2) OR (e^.son[2]^.son[1]^.son[2]^.gcg^.Constant.val=4) OR (e^.son[2]^.son[1]^.son[2]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 318;
   END;
   END;
   END;
   END;
     (* RULE 319/3382 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntConstant]+
     e3^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[2]^.son[1]^.gcg^.Constant.val=2) OR (e^.son[2]^.son[2]^.son[1]^.gcg^.Constant.val=4) OR (e^.son[2]^.son[2]^.son[1]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 319;
   END;
   END;
   END;
   END;
     (* RULE 320/3382 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opSymDyOper THEN 
   e3 := e2^.son[2];
   IF e3^.attr^.op = IR.opSymDyOper THEN 
    c:=  1+     e3^.son[1]^.gcg^.cost[ntLReg]+
     e3^.son[2]^.gcg^.cost[ntConstant];
    c:=  c+     e2^.son[1]^.gcg^.cost[ntLReg];
    c:=  c+     e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  (e^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.attr^.SymDyOper.code=ASMOP.add) & (e^.son[2]^.son[2]^.attr^.SymDyOper.code=ASMOP.imul) & ((e^.son[2]^.son[2]^.son[2]^.gcg^.Constant.val=2) OR (e^.son[2]^.son[2]^.son[2]^.gcg^.Constant.val=4) OR (e^.son[2]^.son[2]^.son[2]^.gcg^.Constant.val=8))  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 320;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END SymDyOper;


 PROCEDURE  Sub* (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSub;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 85/1522 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntReg]+
     e^.son[2]^.gcg^.cost[ntAMemARegAImm];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 85;
   END;
   MatchChainRules(e);
 END Sub;


 PROCEDURE  Div* (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opDiv;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 86/1529 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntBReg]+
     e^.son[2]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 86;
   END;
     (* RULE 87/1544 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntWReg]+
     e^.son[2]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 87;
   END;
     (* RULE 88/1559 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 88;
   END;
     (* RULE 216/2650 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntBReg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 216;
   END;
     (* RULE 217/2669 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntWReg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 217;
   END;
     (* RULE 218/2688 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 218;
   END;
   MatchChainRules(e);
 END Div;


 PROCEDURE  Mod* (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opMod;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 89/1575 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntBReg]+
     e^.son[2]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 89;
   END;
     (* RULE 90/1588 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntWReg]+
     e^.son[2]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 90;
   END;
     (* RULE 91/1601 *)
    c:=  7+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 91;
   END;
     (* RULE 219/2708 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntBReg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 219;
   END;
     (* RULE 220/2726 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntWReg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 220;
   END;
     (* RULE 221/2744 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 221;
   END;
   MatchChainRules(e);
 END Mod;


 PROCEDURE  Difference* (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opDifference;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 92/1615 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntAMemARegAImm]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 92;
   END;
     (* RULE 222/2763 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 222;
   END;
   MatchChainRules(e);
 END Difference;


 PROCEDURE  SetExtendByElem* (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetExtendByElem;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 93/1622 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 93;
   END;
   MatchChainRules(e);
 END SetExtendByElem;


 PROCEDURE  SetExtendByRange* (
                         op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetExtendByRange;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 94/1630 *)
    c:=  11+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 94;
   END;
     (* RULE 223/2769 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 223;
   END;
     (* RULE 224/2795 *)
    c:=  6+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 224;
   END;
     (* RULE 225/2822 *)
    c:=  10+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 225;
   END;
     (* RULE 226/2842 *)
    c:=  5+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 226;
   END;
     (* RULE 227/2869 *)
    c:=  5+     e^.son[1]^.gcg^.cost[ntConstant]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 227;
   END;
   MatchChainRules(e);
 END SetExtendByRange;


 PROCEDURE  NoBoolVal* (
                         op1  : Boolean
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opNoBoolVal;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 95/1651 *)
    c:=       e^.son[1]^.gcg^.cost[ntBool];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 95;
   END;
   Emit.EmitInstruction (e);
 END NoBoolVal;


 PROCEDURE  BoolVal* (
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Boolean
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBoolVal;
   a^.BoolVal.trueLabel := AttrueLabel;
   a^.BoolVal.falseLabel := AtfalseLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 96/1654 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntBool];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 96;
   END;
     (* RULE 228/2897 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opBranch THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntCond];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 228;
   END;
   END;
     (* RULE 229/2904 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opBranch THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opFlag THEN 
    c:=       e3^.son[1]^.gcg^.cost[ntLab]+
     e3^.son[2]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 229;
   END;
   END;
   END;
     (* RULE 230/2912 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opIn THEN 
    c:=  4+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntLReg]+
     e2^.son[3]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 230;
   END;
   END;
     (* RULE 231/2922 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opIn THEN 
    c:=  2+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntConstant]+
     e2^.son[3]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 231;
   END;
   END;
     (* RULE 232/2930 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opIs THEN 
    c:=  2+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 232;
   END;
   END;
     (* RULE 233/2938 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opOdd THEN 
    c:=  2+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 233;
   END;
   END;
     (* RULE 234/2949 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opOdd THEN 
    c:=  2+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntAMem];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 234;
   END;
   END;
     (* RULE 235/2956 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opBit THEN 
    c:=  2+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntMemory]+
     e2^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 235;
   END;
   END;
     (* RULE 236/2963 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opCc THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntLab];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 236;
   END;
   END;
     (* RULE 335/3487 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opBranch THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opFloatCompare THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntLab]+
     e3^.son[2]^.gcg^.cost[ntFXReg]+
     e3^.son[3]^.gcg^.cost[ntFYReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 335;
   END;
   END;
   END;
     (* RULE 336/3499 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opBranch THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opFloatCompare THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntLab]+
     e3^.son[2]^.gcg^.cost[ntFYReg]+
     e3^.son[3]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 336;
   END;
   END;
   END;
     (* RULE 358/3667 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opBranch THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opFloatCompare THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntLab]+
     e3^.son[2]^.gcg^.cost[ntFXReg]+
     e3^.son[3]^.gcg^.cost[ntAMem];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 358;
   END;
   END;
   END;
     (* RULE 359/3679 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opBranch THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opFloatCompare THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntLab]+
     e3^.son[2]^.gcg^.cost[ntAMem]+
     e3^.son[3]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 359;
   END;
   END;
   END;
   MatchChainRules(e);
 END BoolVal;


 PROCEDURE  Not* (
                         op1  : Boolean
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opNot;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 97/1663 *)
    c:=       e^.son[1]^.gcg^.cost[ntBool];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 97;
   END;
   MatchChainRules(e);
 END Not;


 PROCEDURE  And* (
                         op1  : Boolean
                      ;  op2  : Boolean
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAnd;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 99/1665 *)
    c:=       e^.son[1]^.gcg^.cost[ntBool]+
     e^.son[2]^.gcg^.cost[ntBool];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 99;
   END;
   MatchChainRules(e);
 END And;


 PROCEDURE  Or* (
                         op1  : Boolean
                      ;  op2  : Boolean
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOr;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 98/1664 *)
    c:=       e^.son[1]^.gcg^.cost[ntBool]+
     e^.son[2]^.gcg^.cost[ntBool];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 98;
   END;
   MatchChainRules(e);
 END Or;


 PROCEDURE  ConstBranch* (
                      Atvalue  :  BOOLEAN;
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Label
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opConstBranch;
   a^.ConstBranch.value := Atvalue;
   a^.ConstBranch.trueLabel := AttrueLabel;
   a^.ConstBranch.falseLabel := AtfalseLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 100/1668 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLab];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 100;
   END;
   MatchChainRules(e);
 END ConstBranch;


 PROCEDURE  Branch* (
                      AtisSigned  :  BOOLEAN;
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Condition
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBranch;
   a^.Branch.isSigned := AtisSigned;
   a^.Branch.trueLabel := AttrueLabel;
   a^.Branch.falseLabel := AtfalseLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 101/1676 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntCond];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 101;
   END;
     (* RULE 333/3462 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opFloatCompare THEN 
    c:=  5+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntFXReg]+
     e2^.son[3]^.gcg^.cost[ntFYReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 333;
   END;
   END;
     (* RULE 334/3474 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opFloatCompare THEN 
    c:=  5+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntFYReg]+
     e2^.son[3]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 334;
   END;
   END;
     (* RULE 356/3642 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opFloatCompare THEN 
    c:=  5+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntFXReg]+
     e2^.son[3]^.gcg^.cost[ntAMem];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 356;
   END;
   END;
     (* RULE 357/3654 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opFloatCompare THEN 
    c:=  5+     e2^.son[1]^.gcg^.cost[ntLab]+
     e2^.son[2]^.gcg^.cost[ntAMem]+
     e2^.son[3]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 357;
   END;
   END;
   MatchChainRules(e);
 END Branch;


 PROCEDURE  LabelDef* (
                      Atlabel  :  LAB.T
                      ;  VAR result : Label);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLabelDef;
   a^.LabelDef.label := Atlabel;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 102/1683 *)
   IF 0 <   ga^.cost[ntLab]  THEN 
     ga^.cost[ntLab] := 0; 
     ga^.rule[ntLab] := 102;
   END;
   MatchChainRules(e);
 END LabelDef;


 PROCEDURE  Flag* (
                      Atrel  :  tRelation
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  VAR result : Condition);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFlag;
   a^.Flag.rel := Atrel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 103/1687 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntCond]  THEN 
     ga^.cost[ntCond] := c; 
     ga^.rule[ntCond] := 103;
   END;
   MatchChainRules(e);
 END Flag;


 PROCEDURE  Compare* (
                      Atrel  :  tRelation
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Condition);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCompare;
   a^.Compare.rel := Atrel;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 104/1693 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntAMem]+
     e^.son[3]^.gcg^.cost[ntARegAImm];
   IF c <   ga^.cost[ntCond]  THEN 
   IF  e^.son[2]^.gcg^.AMem.size=e^.son[3]^.gcg^.ARegAImm.size  THEN 
     ga^.cost[ntCond] := c; 
     ga^.rule[ntCond] := 104;
   END;
   END;
     (* RULE 105/1699 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntAReg]+
     e^.son[3]^.gcg^.cost[ntAMemARegAImm];
   IF c <   ga^.cost[ntCond]  THEN 
   IF  e^.son[2]^.gcg^.AReg.size=e^.son[3]^.gcg^.AMemARegAImm.size  THEN 
     ga^.cost[ntCond] := c; 
     ga^.rule[ntCond] := 105;
   END;
   END;
     (* RULE 106/1705 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntAImm]+
     e^.son[3]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntCond]  THEN 
   IF  e^.son[2]^.gcg^.AImm.size=e^.son[3]^.gcg^.AMemAReg.size  THEN 
     ga^.cost[ntCond] := c; 
     ga^.rule[ntCond] := 106;
   END;
   END;
   MatchChainRules(e);
 END Compare;


 PROCEDURE  StringCompare* (
                      Atrel  :  tRelation
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Condition);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opStringCompare;
   a^.StringCompare.rel := Atrel;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 107/1712 *)
    c:=  8+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntCond]  THEN 
     ga^.cost[ntCond] := c; 
     ga^.rule[ntCond] := 107;
   END;
   MatchChainRules(e);
 END StringCompare;


 PROCEDURE  ConstStringCompare* (
                      Atrel  :  tRelation;
                      Atstr  :  OT.oSTRING
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  VAR result : Condition);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opConstStringCompare;
   a^.ConstStringCompare.rel := Atrel;
   a^.ConstStringCompare.str := Atstr;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 108/1730 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntCond]  THEN 
     ga^.cost[ntCond] := c; 
     ga^.rule[ntCond] := 108;
   END;
   MatchChainRules(e);
 END ConstStringCompare;


 PROCEDURE  In* (
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opIn;
   a^.In.trueLabel := AttrueLabel;
   a^.In.falseLabel := AtfalseLabel;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 109/1736 *)
    c:=  5+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 109;
   END;
     (* RULE 237/2980 *)
    c:=  5+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 237;
   END;
     (* RULE 238/2988 *)
    c:=  5+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntConstant]+
     e^.son[3]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 238;
   END;
   MatchChainRules(e);
 END In;


 PROCEDURE  Is* (
                      AttypeLabel  :  LAB.T;
                      AtttableElemOfs  :  LONGINT;
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opIs;
   a^.Is.typeLabel := AttypeLabel;
   a^.Is.ttableElemOfs := AtttableElemOfs;
   a^.Is.trueLabel := AttrueLabel;
   a^.Is.falseLabel := AtfalseLabel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 110/1744 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 110;
   END;
   MatchChainRules(e);
 END Is;


 PROCEDURE  Odd* (
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOdd;
   a^.Odd.trueLabel := AttrueLabel;
   a^.Odd.falseLabel := AtfalseLabel;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 111/1751 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 111;
   END;
     (* RULE 239/2996 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntAMem];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 239;
   END;
   MatchChainRules(e);
 END Odd;


 PROCEDURE  Bit* (
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Label
                      ;  op2  : Address
                      ;  op3  : Data
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBit;
   a^.Bit.trueLabel := AttrueLabel;
   a^.Bit.falseLabel := AtfalseLabel;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 112/1757 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntLab]+
     e^.son[2]^.gcg^.cost[ntMemory]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 112;
   END;
   MatchChainRules(e);
 END Bit;


 PROCEDURE  Cc* (
                      Atcondcoding  :  LONGINT;
                      AttrueLabel  :  LAB.T;
                      AtfalseLabel  :  LAB.T
                      ;  op1  : Label
                      ;  VAR result : Boolean);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCc;
   a^.Cc.condcoding := Atcondcoding;
   a^.Cc.trueLabel := AttrueLabel;
   a^.Cc.falseLabel := AtfalseLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 113/1763 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntLab];
   IF c <   ga^.cost[ntBool]  THEN 
     ga^.cost[ntBool] := c; 
     ga^.rule[ntBool] := 113;
   END;
   MatchChainRules(e);
 END Cc;


 PROCEDURE  Abs* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAbs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 114/1781 *)
    c:=       e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 114;
   END;
     (* RULE 337/3512 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 337;
   END;
   MatchChainRules(e);
 END Abs;


 PROCEDURE  Ash* (
                         op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAsh;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 115/1790 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 115;
   END;
     (* RULE 240/3003 *)
   IF e^.son[2]^.attr^.op = IR.opLongintConst THEN 
    c:=  1+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 240;
   END;
   END;
   MatchChainRules(e);
 END Ash;


 PROCEDURE  Cap* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCap;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 116/1803 *)
    c:=       e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 116;
   END;
   MatchChainRules(e);
 END Cap;


 PROCEDURE  IncOrDec* (
                      Atcode  :  ASMOP.tOper
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opIncOrDec;
   a^.IncOrDec.code := Atcode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 117/1813 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntARegAImm];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 117;
   END;
   Emit.EmitInstruction (e);
 END IncOrDec;


 PROCEDURE  Excl* (
                         op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opExcl;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 118/1818 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 118;
   END;
     (* RULE 241/3021 *)
   IF e^.son[2]^.attr^.op = IR.opLongintConst THEN 
    c:=  1+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 241;
   END;
   END;
   Emit.EmitInstruction (e);
 END Excl;


 PROCEDURE  Incl* (
                         op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opIncl;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 119/1826 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 119;
   END;
     (* RULE 242/3026 *)
   IF e^.son[2]^.attr^.op = IR.opLongintConst THEN 
    c:=  1+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 242;
   END;
   END;
   Emit.EmitInstruction (e);
 END Incl;


 PROCEDURE  ShiftOrRotate* (
                      Atcode  :  ASMOP.tOper
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opShiftOrRotate;
   a^.ShiftOrRotate.code := Atcode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 120/1835 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntReg]+
     e^.son[2]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 120;
   END;
     (* RULE 243/3032 *)
   IF e^.son[2]^.attr^.op = IR.opLongintConst THEN 
    c:=  1+     e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 243;
   END;
   END;
   MatchChainRules(e);
 END ShiftOrRotate;


 PROCEDURE  StaticNew* (
                      Atsize  :  LONGINT;
                      AttdescLabel  :  LAB.T;
                      AtinitLabel  :  LAB.T
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opStaticNew;
   a^.StaticNew.size := Atsize;
   a^.StaticNew.tdescLabel := AttdescLabel;
   a^.StaticNew.initLabel := AtinitLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 121/1850 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 121;
   END;
   Emit.EmitInstruction (e);
 END StaticNew;


 PROCEDURE  OpenNew* (
                      AtelemSize  :  LONGINT;
                      AttdescLabel  :  LAB.T;
                      AtinitLabel  :  LAB.T;
                      AtnofLens  :  LONGINT
                      ;  op1  : Arguments
                      ;  op2  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opOpenNew;
   a^.OpenNew.elemSize := AtelemSize;
   a^.OpenNew.tdescLabel := AttdescLabel;
   a^.OpenNew.initLabel := AtinitLabel;
   a^.OpenNew.nofLens := AtnofLens;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 122/1861 *)
    c:=       e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 122;
   END;
   Emit.EmitInstruction (e);
 END OpenNew;


 PROCEDURE  LenCheck* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLenCheck;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 123/1872 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 123;
   END;
   MatchChainRules(e);
 END LenCheck;


 PROCEDURE  SystemNew* (
                         op1  : Data
                      ;  op2  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opSystemNew;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 124/1878 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 124;
   END;
   Emit.EmitInstruction (e);
 END SystemNew;


 PROCEDURE  Getreg* (
                      Atregcoding  :  LONGINT;
                      AtdstSize  :  LONGINT
                      ;  op1  : Address
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opGetreg;
   a^.Getreg.regcoding := Atregcoding;
   a^.Getreg.dstSize := AtdstSize;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 125/1886 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 125;
   END;
   Emit.EmitInstruction (e);
 END Getreg;


 PROCEDURE  Putreg* (
                      Atregcoding  :  LONGINT
                      ;  op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opPutreg;
   a^.Putreg.regcoding := Atregcoding;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 126/1944 *)
    c:=       e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 126;
   END;
     (* RULE 127/2002 *)
    c:=       e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 127;
   END;
   Emit.EmitInstruction (e);
 END Putreg;


 PROCEDURE  Move* (
                         op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opMove;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 128/2039 *)
    c:=  11+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 128;
   END;
   Emit.EmitInstruction (e);
 END Move;


 PROCEDURE  Data2Retype* (
                      AtsrcLen  :  LONGINT;
                      AtdstLen  :  LONGINT;
                      AttmpOfs  :  LONGINT
                      ;  op1  : Data
                      ;  VAR result : Retype);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opData2Retype;
   a^.Data2Retype.srcLen := AtsrcLen;
   a^.Data2Retype.dstLen := AtdstLen;
   a^.Data2Retype.tmpOfs := AttmpOfs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 129/2059 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntRetyp]  THEN 
 ga^.Retyp.dstLen:=e^.attr^.Data2Retype.dstLen; ga^.Retyp.tmpOfs:=e^.attr^.Data2Retype.tmpOfs; ;
     ga^.cost[ntRetyp] := c; 
     ga^.rule[ntRetyp] := 129;
   END;
     (* RULE 130/2069 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntRetyp]  THEN 
 ga^.Retyp.dstLen:=e^.attr^.Data2Retype.dstLen; ga^.Retyp.tmpOfs:=e^.attr^.Data2Retype.tmpOfs; ;
     ga^.cost[ntRetyp] := c; 
     ga^.rule[ntRetyp] := 130;
   END;
   MatchChainRules(e);
 END Data2Retype;


 PROCEDURE  Addr2Retype* (
                      AtsrcLen  :  LONGINT;
                      AtdstLen  :  LONGINT;
                      AttmpOfs  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Retype);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opAddr2Retype;
   a^.Addr2Retype.srcLen := AtsrcLen;
   a^.Addr2Retype.dstLen := AtdstLen;
   a^.Addr2Retype.tmpOfs := AttmpOfs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 131/2078 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntRetyp]  THEN 
 ga^.Retyp.dstLen:=e^.attr^.Addr2Retype.dstLen; ga^.Retyp.tmpOfs:=e^.attr^.Addr2Retype.tmpOfs; ;
     ga^.cost[ntRetyp] := c; 
     ga^.rule[ntRetyp] := 131;
   END;
   MatchChainRules(e);
 END Addr2Retype;


 PROCEDURE  Retype2Data* (
                         op1  : Retype
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRetype2Data;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 132/2087 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntRetyp];
   IF c <   ga^.cost[ntBReg]  THEN 
   IF  e^.son[1]^.gcg^.Retyp.dstLen=1  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 132;
   END;
   END;
     (* RULE 133/2092 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntRetyp];
   IF c <   ga^.cost[ntWReg]  THEN 
   IF  e^.son[1]^.gcg^.Retyp.dstLen=2  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 133;
   END;
   END;
     (* RULE 134/2097 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntRetyp];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.son[1]^.gcg^.Retyp.dstLen=4  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 134;
   END;
   END;
     (* RULE 244/3048 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opData2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntBReg]  THEN 
   IF  e^.son[1]^.attr^.Data2Retype.dstLen=1  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 244;
   END;
   END;
   END;
     (* RULE 245/3049 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opData2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntWReg]  THEN 
   IF  e^.son[1]^.attr^.Data2Retype.dstLen=2  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 245;
   END;
   END;
   END;
     (* RULE 246/3050 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opData2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.son[1]^.attr^.Data2Retype.dstLen=4  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 246;
   END;
   END;
   END;
     (* RULE 247/3053 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opAddr2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntBReg]  THEN 
   IF  e^.son[1]^.attr^.Addr2Retype.dstLen=1  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 247;
   END;
   END;
   END;
     (* RULE 248/3057 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opAddr2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntWReg]  THEN 
   IF  e^.son[1]^.attr^.Addr2Retype.dstLen=2  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 248;
   END;
   END;
   END;
     (* RULE 249/3065 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opAddr2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.son[1]^.attr^.Addr2Retype.dstLen=4  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 249;
   END;
   END;
   END;
   MatchChainRules(e);
 END Retype2Data;


 PROCEDURE  Retype2Float* (
                         op1  : Retype
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRetype2Float;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 135/2102 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntRetyp];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 135;
   END;
     (* RULE 250/3079 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opAddr2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntFXReg]  THEN 
   IF  ((e^.son[1]^.attr^.Addr2Retype.dstLen=4) OR (e^.son[1]^.attr^.Addr2Retype.dstLen=8)) & (e^.son[1]^.attr^.Addr2Retype.dstLen<=e^.son[1]^.attr^.Addr2Retype.srcLen)  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 250;
   END;
   END;
   END;
   MatchChainRules(e);
 END Retype2Float;


 PROCEDURE  Retype2Addr* (
                         op1  : Retype
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRetype2Addr;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 136/2106 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntRetyp];
   IF c <   ga^.cost[ntBreg]  THEN 
     ga^.cost[ntBreg] := c; 
     ga^.rule[ntBreg] := 136;
   END;
     (* RULE 251/3084 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opAddr2Retype THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntMemory]  THEN 
   IF  e^.son[1]^.attr^.Addr2Retype.dstLen<=e^.son[1]^.attr^.Addr2Retype.srcLen  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 251;
   END;
   END;
   END;
   MatchChainRules(e);
 END Retype2Addr;


 PROCEDURE  Int2Shortint* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opInt2Shortint;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 137/2119 *)
    c:=       e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 137;
   END;
     (* RULE 138/2123 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 138;
   END;
     (* RULE 139/2124 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 139;
   END;
     (* RULE 140/2125 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 140;
   END;
     (* RULE 141/2126 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 141;
   END;
     (* RULE 142/2128 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 142;
   END;
     (* RULE 143/2136 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 143;
   END;
     (* RULE 144/2137 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 144;
   END;
     (* RULE 145/2138 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 145;
   END;
     (* RULE 146/2139 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 146;
   END;
     (* RULE 161/2226 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 161;
   END;
   MatchChainRules(e);
 END Int2Shortint;


 PROCEDURE  Int2Integer* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opInt2Integer;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 162/2235 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntWReg]  THEN 
   IF  e^.son[1]^.gcg^.AMemAReg.size=b  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 162;
   END;
   END;
     (* RULE 163/2242 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 163;
   END;
     (* RULE 164/2246 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 164;
   END;
     (* RULE 165/2247 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 165;
   END;
     (* RULE 166/2248 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 166;
   END;
     (* RULE 167/2249 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 167;
   END;
     (* RULE 168/2250 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 168;
   END;
     (* RULE 169/2251 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 169;
   END;
     (* RULE 252/3089 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 252;
   END;
   MatchChainRules(e);
 END Int2Integer;


 PROCEDURE  Int2Longint* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opInt2Longint;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 170/2256 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.son[1]^.gcg^.AMemAReg.size=b  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 170;
   END;
   END;
     (* RULE 171/2260 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntAMemAReg];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.son[1]^.gcg^.AMemAReg.size=w  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 171;
   END;
   END;
     (* RULE 172/2264 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 172;
   END;
     (* RULE 253/3093 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 253;
   END;
     (* RULE 254/3097 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opInt2Integer THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 254;
   END;
   END;
     (* RULE 255/3101 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opCard2Integer THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 255;
   END;
   END;
     (* RULE 256/3102 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opCard2Integer THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 256;
   END;
   END;
     (* RULE 257/3103 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opCard2Integer THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 257;
   END;
   END;
     (* RULE 258/3104 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opCard2Integer THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 258;
   END;
   END;
     (* RULE 259/3106 *)
    c:=       e^.son[1]^.gcg^.cost[ntConstant];
   IF c <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=l; ga^.Constant.val:=e^.son[1]^.gcg^.Constant.val; ;
     ga^.cost[ntConstant] := c; 
     ga^.rule[ntConstant] := 259;
   END;
   MatchChainRules(e);
 END Int2Longint;


 PROCEDURE  Card2Shortint* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCard2Shortint;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 173/2269 *)
    c:=       e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 173;
   END;
     (* RULE 174/2270 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 174;
   END;
     (* RULE 175/2271 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 175;
   END;
     (* RULE 260/3110 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 260;
   END;
     (* RULE 261/3111 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 261;
   END;
     (* RULE 262/3112 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 262;
   END;
     (* RULE 263/3113 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 263;
   END;
     (* RULE 264/3115 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 264;
   END;
     (* RULE 265/3116 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 265;
   END;
     (* RULE 266/3117 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 266;
   END;
     (* RULE 267/3118 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBReg]  THEN 
     ga^.cost[ntBReg] := c; 
     ga^.rule[ntBReg] := 267;
   END;
   MatchChainRules(e);
 END Card2Shortint;


 PROCEDURE  Card2Integer* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCard2Integer;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 176/2275 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 176;
   END;
     (* RULE 177/2276 *)
    c:=       e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 177;
   END;
     (* RULE 178/2277 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 178;
   END;
     (* RULE 268/3120 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 268;
   END;
     (* RULE 269/3121 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 269;
   END;
     (* RULE 270/3122 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 270;
   END;
     (* RULE 271/3123 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 271;
   END;
     (* RULE 272/3125 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 272;
   END;
     (* RULE 273/3126 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 273;
   END;
     (* RULE 274/3127 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 274;
   END;
     (* RULE 275/3128 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 275;
   END;
     (* RULE 276/3129 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 276;
   END;
     (* RULE 277/3130 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntWReg]  THEN 
     ga^.cost[ntWReg] := c; 
     ga^.rule[ntWReg] := 277;
   END;
   MatchChainRules(e);
 END Card2Integer;


 PROCEDURE  Card2Longint* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCard2Longint;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 179/2281 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 179;
   END;
     (* RULE 180/2282 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 180;
   END;
     (* RULE 181/2283 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 181;
   END;
     (* RULE 278/3132 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 278;
   END;
     (* RULE 279/3133 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 279;
   END;
     (* RULE 280/3134 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 280;
   END;
     (* RULE 281/3135 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 281;
   END;
     (* RULE 282/3137 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 282;
   END;
     (* RULE 283/3138 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 283;
   END;
     (* RULE 284/3139 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 284;
   END;
     (* RULE 285/3140 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 285;
   END;
     (* RULE 286/3141 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 286;
   END;
     (* RULE 287/3142 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 287;
   END;
   MatchChainRules(e);
 END Card2Longint;


 PROCEDURE  CharConst* (
                      Atval  :  OT.oCHAR
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCharConst;
   a^.CharConst.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 182/2286 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=b; ga^.Constant.val:=ORD(e^.attr^.CharConst.val) MOD 256; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 182;
   END;
   MatchChainRules(e);
 END CharConst;


 PROCEDURE  BooleanConst* (
                      Atval  :  OT.oBOOLEAN
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opBooleanConst;
   a^.BooleanConst.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 183/2289 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=b; ga^.Constant.val:=BooleanTab[SYSTEM.VAL(SHORTINT,e^.attr^.BooleanConst.val)]; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 183;
   END;
   MatchChainRules(e);
 END BooleanConst;


 PROCEDURE  ShortintConst* (
                      Atval  :  OT.oLONGINT
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opShortintConst;
   a^.ShortintConst.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 184/2292 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=b; ga^.Constant.val:=e^.attr^.ShortintConst.val; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 184;
   END;
   MatchChainRules(e);
 END ShortintConst;


 PROCEDURE  IntegerConst* (
                      Atval  :  OT.oLONGINT
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opIntegerConst;
   a^.IntegerConst.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 185/2295 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=w; ga^.Constant.val:=e^.attr^.IntegerConst.val; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 185;
   END;
   MatchChainRules(e);
 END IntegerConst;


 PROCEDURE  LongintConst* (
                      Atval  :  OT.oLONGINT
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongintConst;
   a^.LongintConst.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 186/2298 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=l; ga^.Constant.val:=e^.attr^.LongintConst.val; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 186;
   END;
   MatchChainRules(e);
 END LongintConst;


 PROCEDURE  IntConst* (
                      Atval  :  OT.oLONGINT;
                      Atsize  :  tSize
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opIntConst;
   a^.IntConst.val := Atval;
   a^.IntConst.size := Atsize;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 187/2301 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=e^.attr^.IntConst.size; ga^.Constant.val:=e^.attr^.IntConst.val; ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 187;
   END;
   MatchChainRules(e);
 END IntConst;


 PROCEDURE  RealConst* (
                      Atval  :  OT.oREAL
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRealConst;
   a^.RealConst.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 188/2304 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=l; ga^.Constant.val:=SYSTEM.VAL(LONGINT,SYSTEM.VAL(SET,e^.attr^.RealConst.val)); ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 188;
   END;
   MatchChainRules(e);
 END RealConst;


 PROCEDURE  SetConst* (
                      Atval  :  OT.oSET
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSetConst;
   a^.SetConst.val := Atval;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 189/2307 *)
   IF 0 <   ga^.cost[ntConstant]  THEN 
 ga^.Constant.size:=l; ga^.Constant.val:=SYSTEM.VAL(LONGINT,e^.attr^.SetConst.val); ;
     ga^.cost[ntConstant] := 0; 
     ga^.rule[ntConstant] := 189;
   END;
   MatchChainRules(e);
 END SetConst;


 PROCEDURE  RecordGuard* (
                      AttypeLabel  :  LAB.T;
                      AtttableElemOfs  :  LONGINT;
                      AttagOfs  :  LONGINT
                      ;  op1  : Address
                      ;  op2  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opRecordGuard;
   a^.RecordGuard.typeLabel := AttypeLabel;
   a^.RecordGuard.ttableElemOfs := AtttableElemOfs;
   a^.RecordGuard.tagOfs := AttagOfs;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 190/2310 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntMemory]  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 190;
   END;
   MatchChainRules(e);
 END RecordGuard;


 PROCEDURE  PointerGuard* (
                      AttypeLabel  :  LAB.T;
                      AtttableElemOfs  :  LONGINT
                      ;  op1  : Address
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opPointerGuard;
   a^.PointerGuard.typeLabel := AttypeLabel;
   a^.PointerGuard.ttableElemOfs := AtttableElemOfs;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 191/2322 *)
    c:=  9+     e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 191;
   END;
   MatchChainRules(e);
 END PointerGuard;


 PROCEDURE  SimpleGuard* (
                      AttypeLabel  :  LAB.T;
                      AttagOfs  :  LONGINT
                      ;  op1  : Address
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opSimpleGuard;
   a^.SimpleGuard.typeLabel := AttypeLabel;
   a^.SimpleGuard.tagOfs := AttagOfs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 192/2338 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntMemory]  THEN 
     ga^.cost[ntMemory] := c; 
     ga^.rule[ntMemory] := 192;
   END;
   MatchChainRules(e);
 END SimpleGuard;


 PROCEDURE  IndexCheck* (
                      Atlen  :  LONGINT
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opIndexCheck;
   a^.IndexCheck.len := Atlen;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 193/2350 *)
    c:=       e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 193;
   END;
   MatchChainRules(e);
 END IndexCheck;


 PROCEDURE  NilCheck* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opNilCheck;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 194/2356 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 194;
   END;
     (* RULE 289/3164 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opContentOf THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opPointerFrom THEN 
   e4 := e3^.son[1];
   IF e4^.attr^.op = IR.opPointerGuard THEN 
    c:=       e4^.son[1]^.gcg^.cost[ntMemory]+
     e4^.son[2]^.gcg^.cost[ntLReg]+
     e4^.son[3]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
   IF  e^.son[1]^.attr^.ContentOf.size=l  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 289;
   END;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END NilCheck;


 PROCEDURE  MinIntCheck* (
                      AtfaultLabel  :  LAB.T
                      ;  op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opMinIntCheck;
   a^.MinIntCheck.faultLabel := AtfaultLabel;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 195/2363 *)
    c:=       e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 195;
   END;
   MatchChainRules(e);
 END MinIntCheck;


 PROCEDURE  ChrRangeCheck* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opChrRangeCheck;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 196/2374 *)
    c:=       e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 196;
   END;
   MatchChainRules(e);
 END ChrRangeCheck;


 PROCEDURE  ShortRangeCheck* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opShortRangeCheck;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 197/2385 *)
    c:=       e^.son[1]^.gcg^.cost[ntReg];
   IF c <   ga^.cost[ntReg]  THEN 
 ga^.Reg.size:=e^.son[1]^.gcg^.Reg.size; ;
     ga^.cost[ntReg] := c; 
     ga^.rule[ntReg] := 197;
   END;
   MatchChainRules(e);
 END ShortRangeCheck;


 PROCEDURE  OpenIndexStartLocal* (
                         VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOpenIndexStartLocal;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 198/2401 *)
   IF 1 <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := 1; 
     ga^.rule[ntLReg] := 198;
   END;
   MatchChainRules(e);
 END OpenIndexStartLocal;


 PROCEDURE  OpenIndexStart* (
                         op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOpenIndexStart;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 199/2405 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 199;
   END;
     (* RULE 290/3185 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opPointerFrom THEN 
    c:=       e2^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 290;
   END;
   END;
   MatchChainRules(e);
 END OpenIndexStart;


 PROCEDURE  OpenIndexPush* (
                      AtlenOfs  :  LONGINT
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOpenIndexPush;
   a^.OpenIndexPush.lenOfs := AtlenOfs;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 200/2409 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 200;
   END;
   MatchChainRules(e);
 END OpenIndexPush;


 PROCEDURE  OpenIndexStaticBase* (
                      Atsize  :  LONGINT
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  op4  : Data
                      ;  VAR result : ShrinkingStack);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOpenIndexStaticBase;
   a^.OpenIndexStaticBase.size := Atsize;
   e^.arity := 4;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   e^.son[4] := op4;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 201/2418 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntLReg]+
     e^.son[2]^.gcg^.cost[ntLReg]+
     e^.son[3]^.gcg^.cost[ntLReg]+
     e^.son[4]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntReducedStack]  THEN 
     ga^.cost[ntReducedStack] := c; 
     ga^.rule[ntReducedStack] := 201;
   END;
   MatchChainRules(e);
 END OpenIndexStaticBase;


 PROCEDURE  OpenIndexOpenBase* (
                      AtlenOfs  :  LONGINT
                      ;  op1  : ShrinkingStack
                      ;  VAR result : ShrinkingStack);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOpenIndexOpenBase;
   a^.OpenIndexOpenBase.lenOfs := AtlenOfs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 202/2434 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntReducedStack];
   IF c <   ga^.cost[ntReducedStack]  THEN 
     ga^.cost[ntReducedStack] := c; 
     ga^.rule[ntReducedStack] := 202;
   END;
     (* RULE 291/3191 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opOpenIndexStaticBase THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntLReg]+
     e2^.son[2]^.gcg^.cost[ntLReg]+
     e2^.son[3]^.gcg^.cost[ntLReg]+
     e2^.son[4]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntReducedStack]  THEN 
     ga^.cost[ntReducedStack] := c; 
     ga^.rule[ntReducedStack] := 291;
   END;
   END;
   MatchChainRules(e);
 END OpenIndexOpenBase;


 PROCEDURE  OpenIndexPop* (
                      AtlenOfs  :  LONGINT;
                      AtisFirstIndex  :  BOOLEAN;
                      AtisLastIndex  :  BOOLEAN
                      ;  op1  : ShrinkingStack
                      ;  VAR result : ShrinkingStack);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOpenIndexPop;
   a^.OpenIndexPop.lenOfs := AtlenOfs;
   a^.OpenIndexPop.isFirstIndex := AtisFirstIndex;
   a^.OpenIndexPop.isLastIndex := AtisLastIndex;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 203/2443 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntReducedStack];
   IF c <   ga^.cost[ntReducedStack]  THEN 
     ga^.cost[ntReducedStack] := c; 
     ga^.rule[ntReducedStack] := 203;
   END;
     (* RULE 292/3209 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opOpenIndexStaticBase THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opOpenIndexPush THEN 
    c:=  4+     e3^.son[1]^.gcg^.cost[ntLReg]+
     e3^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntLReg]+
     e2^.son[3]^.gcg^.cost[ntLReg]+
     e2^.son[4]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntReducedStack]  THEN 
     ga^.cost[ntReducedStack] := c; 
     ga^.rule[ntReducedStack] := 292;
   END;
   END;
   END;
     (* RULE 293/3239 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opOpenIndexStaticBase THEN 
   e3 := e2^.son[1];
   IF e3^.attr^.op = IR.opOpenIndexPush THEN 
   IF e3^.son[1]^.attr^.op = IR.opOpenIndexStartLocal THEN 
    c:=  4+     e3^.son[2]^.gcg^.cost[ntLReg];
    c:=  c+     e2^.son[2]^.gcg^.cost[ntLReg]+
     e2^.son[3]^.gcg^.cost[ntLReg]+
     e2^.son[4]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntReducedStack]  THEN 
     ga^.cost[ntReducedStack] := c; 
     ga^.rule[ntReducedStack] := 293;
   END;
   END;
   END;
   END;
   MatchChainRules(e);
 END OpenIndexPop;


 PROCEDURE  OpenIndexApplication* (
                         op1  : ShrinkingStack
                      ;  op2  : Data
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opOpenIndexApplication;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 204/2462 *)
    c:=       e^.son[1]^.gcg^.cost[ntReducedStack]+
     e^.son[2]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 204;
   END;
   MatchChainRules(e);
 END OpenIndexApplication;


 PROCEDURE  HeapOpenIndexApplication* (
                      AtobjOfs  :  LONGINT
                      ;  op1  : ShrinkingStack
                      ;  VAR result : Address);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opHeapOpenIndexApplication;
   a^.HeapOpenIndexApplication.objOfs := AtobjOfs;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 205/2470 *)
    c:=       e^.son[1]^.gcg^.cost[ntReducedStack];
   IF c <   ga^.cost[ntBregIreg]  THEN 
     ga^.cost[ntBregIreg] := c; 
     ga^.rule[ntBregIreg] := 205;
   END;
   MatchChainRules(e);
 END HeapOpenIndexApplication;


 PROCEDURE  ConjureRegister* (
                         VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opConjureRegister;
   e^.arity := 0;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 206/2478 *)
   IF 0 <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := 0; 
     ga^.rule[ntLReg] := 206;
   END;
   MatchChainRules(e);
 END ConjureRegister;


 PROCEDURE  FloatAssignment* (
                      Atsize  :  tSize
                      ;  op1  : Address
                      ;  op2  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opFloatAssignment;
   a^.FloatAssignment.size := Atsize;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 322/3407 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntMemory]+
     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 322;
   END;
     (* RULE 347/3582 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opFloatContentOf THEN 
    c:=  1+     e2^.son[1]^.gcg^.cost[ntMemory];
    c:=  c+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.stmtcost  THEN 
   IF  e^.attr^.FloatAssignment.size=e^.son[2]^.attr^.FloatContentOf.size  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 347;
   END;
   END;
   END;
   Emit.EmitInstruction (e);
 END FloatAssignment;


 PROCEDURE  FloatContentOf* (
                      Atsize  :  tSize
                      ;  op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatContentOf;
   a^.FloatContentOf.size := Atsize;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 323/3412 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntAMem]  THEN 
 ga^.AMem.size:=e^.attr^.FloatContentOf.size; ;
     ga^.cost[ntAMem] := c; 
     ga^.rule[ntAMem] := 323;
   END;
   MatchChainRules(e);
 END FloatContentOf;


 PROCEDURE  FloatParam* (
                      Atsize  :  tSize
                      ;  op1  : Arguments
                      ;  op2  : Data
                      ;  VAR result : Arguments);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatParam;
   a^.FloatParam.size := Atsize;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 325/3423 *)
    c:=  2+     e^.son[1]^.gcg^.cost[ntArgs]+
     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntArgs]  THEN 
     ga^.cost[ntArgs] := c; 
     ga^.rule[ntArgs] := 325;
   END;
   MatchChainRules(e);
 END FloatParam;


 PROCEDURE  FloatFuncReturn* (
                         op1  : Data
                                                         );
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
  a^.op := IR.opFloatFuncReturn;
   e^.arity := 1;
   e^.son[1] := op1;
   NextAttr := FirstAttr;
   NextExpr := FirstExpr;
   NextGcg  := FirstGcg;
   ga^.stmtcost := IR.infcost;
   e^.gcg := ga;

     (* RULE 326/3429 *)
    c:=       e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.stmtcost  THEN 
     ga^.stmtcost := c; 
     ga^.stmtrule := 326;
   END;
   Emit.EmitInstruction (e);
 END FloatFuncReturn;


 PROCEDURE  FloatFuncResultOf* (
                         op1  : Address
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatFuncResultOf;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 327/3435 *)
    c:=       e^.son[1]^.gcg^.cost[ntMemory];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 327;
   END;
   MatchChainRules(e);
 END FloatFuncResultOf;


 PROCEDURE  FloatNegate* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatNegate;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

   MatchChainRules(e);
 END FloatNegate;


 PROCEDURE  FloatSymDyOper* (
                      Atcode  :  ASMOP.tOper
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatSymDyOper;
   a^.FloatSymDyOper.code := Atcode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 329/3445 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntFXReg]+
     e^.son[2]^.gcg^.cost[ntFYReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 329;
   END;
     (* RULE 330/3445 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntFYReg]+
     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 330;
   END;
     (* RULE 348/3595 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntFXReg]+
     e^.son[2]^.gcg^.cost[ntAMem];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 348;
   END;
     (* RULE 349/3595 *)
    c:=  30+     e^.son[1]^.gcg^.cost[ntAMem]+
     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 349;
   END;
     (* RULE 352/3611 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opInt2Float THEN 
    c:=  30+     e2^.son[1]^.gcg^.cost[ntAMem];
    c:=  c+     e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
   IF  (e^.son[2]^.son[1]^.gcg^.AMem.size=w) OR (e^.son[2]^.son[1]^.gcg^.AMem.size=l)  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 352;
   END;
   END;
   END;
     (* RULE 353/3611 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opInt2Float THEN 
    c:=  30+     e2^.son[1]^.gcg^.cost[ntAMem];
    c:=  c+     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
   IF  (e^.son[1]^.son[1]^.gcg^.AMem.size=w) OR (e^.son[1]^.son[1]^.gcg^.AMem.size=l)  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 353;
   END;
   END;
   END;
   MatchChainRules(e);
 END FloatSymDyOper;


 PROCEDURE  FloatDyOper* (
                      Atcode  :  ASMOP.tOper
                      ;  op1  : Data
                      ;  op2  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatDyOper;
   a^.FloatDyOper.code := Atcode;
   e^.arity := 2;
   e^.son[1] := op1;
   e^.son[2] := op2;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 331/3451 *)
    c:=  60+     e^.son[1]^.gcg^.cost[ntFYReg]+
     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 331;
   END;
     (* RULE 332/3456 *)
    c:=  60+     e^.son[1]^.gcg^.cost[ntFXReg]+
     e^.son[2]^.gcg^.cost[ntFYReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 332;
   END;
     (* RULE 350/3600 *)
    c:=  60+     e^.son[1]^.gcg^.cost[ntAMem]+
     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 350;
   END;
     (* RULE 351/3605 *)
    c:=  60+     e^.son[1]^.gcg^.cost[ntFXReg]+
     e^.son[2]^.gcg^.cost[ntAMem];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 351;
   END;
     (* RULE 354/3621 *)
   e2 := e^.son[1];
   IF e2^.attr^.op = IR.opInt2Float THEN 
    c:=  60+     e2^.son[1]^.gcg^.cost[ntAMem];
    c:=  c+     e^.son[2]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
   IF  (e^.son[1]^.son[1]^.gcg^.AMem.size=w) OR (e^.son[1]^.son[1]^.gcg^.AMem.size=l)  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 354;
   END;
   END;
   END;
     (* RULE 355/3631 *)
   e2 := e^.son[2];
   IF e2^.attr^.op = IR.opInt2Float THEN 
    c:=  60+     e2^.son[1]^.gcg^.cost[ntAMem];
    c:=  c+     e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
   IF  (e^.son[2]^.son[1]^.gcg^.AMem.size=w) OR (e^.son[2]^.son[1]^.gcg^.AMem.size=l)  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 355;
   END;
   END;
   END;
   MatchChainRules(e);
 END FloatDyOper;


 PROCEDURE  FloatCompare* (
                      Atrel  :  tRelation
                      ;  op1  : Label
                      ;  op2  : Data
                      ;  op3  : Data
                      ;  VAR result : Condition);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opFloatCompare;
   a^.FloatCompare.rel := Atrel;
   e^.arity := 3;
   e^.son[1] := op1;
   e^.son[2] := op2;
   e^.son[3] := op3;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

   MatchChainRules(e);
 END FloatCompare;


 PROCEDURE  Entier* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opEntier;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 338/3517 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntLReg]  THEN 
     ga^.cost[ntLReg] := c; 
     ga^.rule[ntLReg] := 338;
   END;
   MatchChainRules(e);
 END Entier;


 PROCEDURE  Int2Float* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opInt2Float;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 339/3524 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 339;
   END;
     (* RULE 340/3532 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 340;
   END;
     (* RULE 341/3538 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 341;
   END;
     (* RULE 360/3692 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 360;
   END;
     (* RULE 361/3700 *)
    c:=  1+     e^.son[1]^.gcg^.cost[ntAMem];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 361;
   END;
   MatchChainRules(e);
 END Int2Float;


 PROCEDURE  Card2Float* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opCard2Float;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 342/3545 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntBReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 342;
   END;
     (* RULE 343/3553 *)
    c:=  4+     e^.son[1]^.gcg^.cost[ntWReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 343;
   END;
     (* RULE 344/3561 *)
    c:=  3+     e^.son[1]^.gcg^.cost[ntLReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 344;
   END;
   MatchChainRules(e);
 END Card2Float;


 PROCEDURE  Real2Longreal* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opReal2Longreal;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 345/3568 *)
    c:=       e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 345;
   END;
   MatchChainRules(e);
 END Real2Longreal;


 PROCEDURE  Longreal2Real* (
                         op1  : Data
                      ;  VAR result : Data);
 VAR    e  : IR.Expression;
        a  : IR.Attributes;
        ga : IR.ExprAttributes;
        c  : INTEGER;
        e2,e3,e4,e5,e6,e7,e8,e9,e10 : IR.Expression;

 BEGIN
   IF NextAttr=NIL THEN MemExtend; END;
   e := NextExpr;
   a := NextAttr;
   ga  := NextGcg; e^.attr := a;
   NextAttr := NextAttr^.hashchain;
   NextExpr := NextExpr^.hashchain;
   NextGcg  := NextGcg^.hashchain; 
  a^.op := IR.opLongreal2Real;
   e^.arity := 1;
   e^.son[1] := op1;
   result := e;
   ga^.cost := IR.InfCosts;
   e^.gcg := ga;

     (* RULE 346/3571 *)
    c:=       e^.son[1]^.gcg^.cost[ntFXReg];
   IF c <   ga^.cost[ntFXReg]  THEN 
     ga^.cost[ntFXReg] := c; 
     ga^.rule[ntFXReg] := 346;
   END;
   MatchChainRules(e);
 END Longreal2Real;


 BEGIN 
    FirstAttr := NIL; MemExtend;
(*++++++ start insertion IpIRConsInit ++++++*)
 BooleanTab[0]:=0; BooleanTab[1]:=1; 

(*------ end   insertion IpIRConsInit ------*)
 
 END Cons.

