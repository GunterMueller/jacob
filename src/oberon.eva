/********************************************************************************************************************************/
/*** oberon.eva / Evaluator specification                                                                                     ***/
/********************************************************************************************************************************/
MODULE Evaluator

TREE

EXPORT{ TYPE   tErrorMsg        = ERR.tErrorMsg ;                     (* These types are re-declared due to the fact that       *)
               tLevel           = OB.tLevel     ;                     (* qualidents are  illegal in an evaluator specification. *)
               tSize            = OB.tSize      ;                     (* They are used for attribute types and must therefore   *)
               tAddress         = OB.tAddress   ;                     (* be known in the abstract syntax tree specification.    *)
               tOB              = OB.tOB        ;                     
               tCoercion        = OB.tOB        ; 
               tLabel           = LAB.T         ; }

EVAL                                                                  /* Now the actual evaluator specification...              */

IMPORT{ IMPORT Idents           ,
               OB               ; }

GLOBAL{ IMPORT ADR              ,
               ARG              ,
               BL               ,
               CO               ,
               DRV              ,
               E                ,
               ERR              ,
               ErrLists         ,
               FIL              ,
               Idents           ,
               LIM              ,
               LAB              ,
               O                ,
               OD               ,
               OB               ,
               OT               ,
               POS              ,
               PR               ,
               SI               ,
               STR              ,
               TT               ,
               T                ,
               UTI              ,
               V                ;

        TYPE   tOB              = OB.tOB;                             (* These types are re-declared due to the fact that       *)
               tSize            = OB.tSize;                           (* qualidents are  illegal in an ast specification.       *)
               tAddress         = OB.tAddress;                        
               tParMode         = OB.tParMode;

        PROCEDURE superfluous_application_due_to_warning_suppression(b:ARRAY OF SYSTEM.BYTE) : BOOLEAN;
        BEGIN RETURN TRUE; END superfluous_application_due_to_warning_suppression; }

/********************************************************************************************************************************/
DECLARE

 Imports DeclSection DeclUnits Decls Procs FormalPars FPSections
 ParIds Receiver Type ArrayExprLists FieldLists IdentLists Qualidents
 Stmts Cases CaseLabels GuardedStmts Guard ConstExpr Exprs Elements
 Designator Designations ExprLists NewExprLists SysAsmExprLists
 = [ ModuleIn : tOB INHERITED ].                                      /* Holds the name of the current module                   */

 ArrayExprLists Qualidents Stmts Cases CaseLabels GuardedStmts
 ConstExpr Exprs Elements Designator Designations ExprLists NewExprLists SysAsmExprLists
 = [ TableIn : tOB INHERITED ].                                       /* Holds the current declarations                         */

 Stmts Cases GuardedStmts
 = [ ResultTypeReprIn : tOB INHERITED ].                              /* Holds the result type of the current function proc.    */

 Exprs Elements Designator Designations ExprLists NewExprLists SysAsmExprLists
 = [ ValDontCareIn : BOOLEAN INHERITED ].                             /* Displays the necessity of constant folding             */

 Stmts Cases GuardedStmts
 = [ ReturnExistsOut : BOOLEAN SYNTHESIZED ].                         /* Displays the existence of a RETURN statement           */

/********************************************************************************************************************************/
RULE

/*------------------------------------------------------------------------------------------------------------------------------*/
Module =
{
  ModuleEntry                   := \OB.\mModuleEntry
                                   (/* name               := */ Name
                                   ,/* globalLabel        := */ \LAB.\AppS(\LAB.\NewGlobal(Name),'$G')
                                   ,/* isForeign          := */ IsForeign);

  Imports:TableIn               := { Imports:TableIn:=\OB.\mScopeEntry(\PR.\GetTablePREDECL());                    /* !PreDecls */

                                     IF \ARG.\OptionShowPredeclTable & (\FIL.\NestingDepth<=1)THEN 
                                        \OD.\DumpTable(Name,Imports:TableIn,\UTI.\MakeString('PREDECL'),Name);
                                     END;
                                   };
  Imports:ModuleIn              := ModuleEntry;

  DeclSection:TableIn           := \DRV.\ShowCompiling(Imports:TableOut);
  DeclSection:ModuleIn          := ModuleEntry;
  

  Stmts:TableIn                 := { Stmts:TableIn:=\E.\CheckUnresolvedForwardBoundProcs                 /* !ForwardProcSolving */
                                                    (\E.\CheckUnresolvedForwardProcs
                                                     (\DRV.\ShowProcCount(DeclSection:TableOut))
                                                    );
                                     IF ErrLists.Length(FIL.ActP^.ErrorList)=0 THEN 
                                        \T.\CalcProcNumsOfEntries(Stmts:TableIn); 
                                     END;
                                     \FIL.\ActP^.\MainTable   := DeclSection:TableOut;
                                     \FIL.\ActP^.\IsForeign   := IsForeign;
                                     \FIL.\ActP^.\Library     := Library;
                                     \FIL.\ActP^.\ModuleEntry := ModuleEntry;           

                                     IF \ARG.\OptionShowStmtTables & (\FIL.\NestingDepth<=1) THEN 
                                        \OD.\DumpTable0(Name,Stmts:TableIn,\UTI.\MakeString('MODULE'),Name);
                                     END;
                                   };
  Stmts:ModuleIn                := ModuleEntry;
  Stmts:ResultTypeReprIn        := \OB.\cmtTypeRepr;
  
  Globals                       := DeclSection:TableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Imports =
[ Table : tOB THREAD ]
.
Import =
[ ServerTable : tOB       ]
[ ErrorMsg    : SHORTCARD ]
{
  ServerTable,ErrorMsg          := { ServerTable:=\DRV.\Import(ServerId,ErrorMsg);
                                     IF \ARG.\OptionShowImportTables & (\FIL.\NestingDepth<=1) THEN 
                                        \OD.\DumpTable0(\E.\IdentOfEntry(ModuleIn)
                                                       ,ServerTable,\UTI.\MakeString('SERVER'),ServerId);
                                     END;
                                   };

  Next:TableIn                  := \OB.\mServerEntry
                                   (/* prevEntry          := */ TableIn
                                   ,/* module             := */ ModuleIn     
                                   ,/* ident              := */ RefId
                                   ,/* exportMode         := */ \OB.\PRIVATE
                                   ,/* level              := */ 1
                                   ,/* declStatus         := */ \OB.\DECLARED
                                   ,/* serverTable        := */ ServerTable
                                   ,/* serverId           := */ ServerId);
  TableOut                      := Next:TableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
DeclSection =
[ Table   : tOB      THREAD ]
{
  DeclUnits:TableIn             := TableIn;

  Procs:TableIn                 := \E.\CheckUnresolvedForwardPointers(DeclUnits:TableOut);               /* !ForwardTypeSolving */

  TableOut                      := Procs:TableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
DeclUnits =
[ Table   : tOB      THREAD ]
.
DeclUnit =
{
  Decls:TableIn                 := TableIn;

  Next:TableIn                  := Decls:TableOut;

  TableOut                      := Next:TableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Decls =
[ Table   : tOB      THREAD ]
.

/*---------------------------------------------------------------------------*/
ConstDecl =
[ TableTmp : tOB ]
{
  TableTmp                      := \OB.\mConstEntry
                                   (/* prevEntry          := */ TableIn
                                   ,/* module             := */ ModuleIn     
                                   ,/* ident              := */ IdentDef:Ident
                                   ,/* exportMode         := */ IdentDef:ExportMode
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\TOBEDECLARED
                                   ,/* typeRepr           := */ \OB.\cmtObject
                                   ,/* value              := */ \OB.\cmtObject
                                   ,/* label              := */ label);

  ConstExpr:TableIn             := TableTmp;

  Next:TableIn                  := \E.\DefineConstEntry
                                   (/* Entry              := */ TableTmp
                                   ,/* Level              := */ LevelIn
                                   ,/* Ident              := */ IdentDef:Ident
                                   ,/* Type               := */ ConstExpr:TypeReprOut
                                   ,/* Value              := */ ConstExpr:ValueReprOut);

  TableOut                      := Next:TableOut;

  Entry                         := TableTmp; 
}.

/*---------------------------------------------------------------------------*/
TypeDecl =
[ TableTmp       : tOB       ]
[ ForwardedEntry : tOB       ]           /* Entry of a still undeclared type T, which was introduced by a previous POINTER TO T */
[ ForwardedPos   : tPosition ]           /* ... its position                                                                    */
[ TypeEntry      : tOB       ]
{
  TableTmp                      := \OB.\mTypeEntry
                                   (/* prevEntry          := */ TableIn
                                   ,/* module             := */ ModuleIn
                                   ,/* ident              := */ IdentDef:Ident
                                   ,/* exportMode         := */ IdentDef:ExportMode
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\TOBEDECLARED
                                   ,/* typeRepr           := */ Type:FirstTypeReprOut);

  Type:TableIn                  := TableTmp;
  Type:ForwardPBaseIsOkIn       := TRUE;                                                   /* !ForwardType, !ForwardTypeSolving */
  Type:OpenArrayIsOkIn          := TRUE;                                                                     /* !LegalOpenArray */
  Type:IsVarParTypeIn           := FALSE;                                                                     /* !RecursiveType */

  ForwardedEntry                := \E.\LookupForward
                                   (/* entry              := */ TableIn
                                   ,/* ident              := */ IdentDef:Ident);
  ForwardedPos BEFORE Next:TableIn;
  ForwardedPos                  := { \E.\PosOfForwardEntry(ForwardedEntry,ForwardedPos); };

  Next:TableIn, TypeEntry       :=
  { Next:TableIn                := \E.\DefineTypeEntry
                                   (/* Table            := */ Type:TableOut
                                   ,/* Entry            := */ TableTmp
                                   ,/* ForwardEntry     := */ ForwardedEntry
                                   ,/* Level            := */ LevelIn
                                   ,/* Ident            := */ IdentDef:Ident
                                   ,/* Type             := */ Type:TypeReprOut);
    TypeEntry                   := TableTmp; 
  };

  TableOut                      := Next:TableOut;
}.

/*---------------------------------------------------------------------------*/
VarDecl =
{                                                                     /*
                                                                       * Method: - Create the variable entries as TOBEDECLARED
                                                                       *         - Process the type
                                                                       *         - Set the created variable entries to DECLARED
                                                                       */
  IdentLists:Table1In           := TableIn;
  IdentLists:TooBigMsg          := \ERR.\MsgTooManyVars;              /* (IdentLists is also used in the context of FieldLists) */

  Type:TableIn                  := IdentLists:Table1Out;              /* All identifiers are now entered as TOBEDECLARED        */
  Type:ForwardPBaseIsOkIn       := FALSE;                                                  /* !ForwardType, !ForwardTypeSolving */
  Type:OpenArrayIsOkIn          := FALSE;                                                                    /* !LegalOpenArray */
  Type:IsVarParTypeIn           := FALSE;                                                                     /* !RecursiveType */

  IdentLists:Table2In           := IdentLists:Table1Out;
  IdentLists:TypeReprIn         := Type:TypeReprOut;

  Next:TableIn                  := IdentLists:Table2Out;              /* All identifiers are now DECLARED                       */

  TableOut                      := Next:TableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Procs =
[ Table : tOB THREAD ].

/*---------------------------------------------------------------------------*/
ProcDecl =
[ AlreadyDeclEntry   : tOB         ]                       /* Entry with same name as the procedure, declared in the same scope */
[ ForwardedProcEntry : tOB         ]                       /* Entry of the appropriate forward procedure declaration            */
[ IsUndeclared       : BOOLEAN     ]                       /* Flags the undeclared property of the current procedure            */
[ TableTmp           : tOB         ]
[ ProcTypeRepr       : tOB         ]                       /* Procedure type of the current procedure                           */
{
  AlreadyDeclEntry              := \E.\Lookup0(\DRV.\ShowProcCount(TableIn),IdentDef:Ident);
  ForwardedProcEntry            := \E.\ForwardProcOnly(AlreadyDeclEntry);
  IsUndeclared BEFORE DeclSection:TableIn;
  IsUndeclared                  := \E.\IsErrorEntry(AlreadyDeclEntry)
                                OR \E.\IsForwardProcEntry(AlreadyDeclEntry);
  TableTmp                      := \E.\ChooseProcedureEntry
                                   (/* table              := */ TableIn
                                   ,/* entry              := */ \OB.\mProcedureEntry
                                                                (/* prevEntry      := */ TableIn
                                                                ,/* module         := */ ModuleIn     
                                                                ,/* ident          := */ IdentDef:Ident
                                                                ,/* exportMode     := */ IdentDef:ExportMode
                                                                ,/* level          := */ LevelIn
                                                                ,/* declStatus     := */ \OB.\TOBEDECLARED
                                                                ,/* typeRepr       := */ \OB.\cmtObject
                                                                ,/* complete       := */ TRUE
                                                                ,/* position       := */ IdentDef:Pos
                                                                ,/* label          := */ label
                                                                ,/* namePath       := */ NamePath
                                                                ,/* env            := */ NIL)
                                   ,/* forwardEntry       := */ ForwardedProcEntry);

  FormalPars:TableIn            := \OB.\mScopeEntry(TableTmp);

  ProcTypeRepr                  := \OB.\mProcedureTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ \OT.\SIZEoPROCEDURE
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* signatureRepr      := */ FormalPars:SignatureReprOut
                                   ,/* resultType         := */ FormalPars:ResultTypeReprOut
                                   ,/* paramSpace         := */ paramSpace);

  DeclSection:TableIn           := \E.\DefineProcedureEntry
                                   (/* Table              := */ FormalPars:TableOut
                                   ,/* Entry              := */ TableTmp
                                   ,/* ForwardEntry       := */ ForwardedProcEntry
                                   ,/* level              := */ LevelIn
                                   ,/* Ident              := */ IdentDef:Ident
                                   ,/* ExportMode         := */ IdentDef:ExportMode
                                   ,/* Label              := */ label
                                   ,/* Type               := */ ProcTypeRepr
                                   ,/* Env                := */ env);

  Stmts:TableIn                 := { Stmts:TableIn:=\E.\CheckUnresolvedForwardProcs
                                                    (DeclSection:TableOut);                              /* !ForwardProcSolving */
                                     IF ARG.\OptionShowStmtTables & (\FIL.\NestingDepth<=1) THEN 
                                        \OD.\DumpTable0(\E.\IdentOfEntry(ModuleIn)
                                                       ,Stmts:TableIn,\UTI.\MakeString('PROCEDURE'),IdentDef:Ident);
                                     END; (* IF *)
                                   };
  Stmts:ResultTypeReprIn        := FormalPars:ResultTypeReprOut;

  Next:TableIn                  := TableTmp;

  TableOut                      := Next:TableOut;

  Entry                         := \E.\Lookup0(TableTmp,IdentDef:Ident);
  Locals                        := DeclSection:TableOut;
}.

/*---------------------------------------------------------------------------*/
ForwardDecl =
[ TableTmp : tOB ]
{
  TableTmp                      := \OB.\mProcedureEntry
                                   (/* prevEntry          := */ TableIn
                                   ,/* module             := */ ModuleIn     
                                   ,/* ident              := */ IdentDef:Ident
                                   ,/* exportMode         := */ IdentDef:ExportMode
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\TOBEDECLARED
                                   ,/* typeRepr           := */ \OB.\cmtObject
                                   ,/* complete           := */ FALSE
                                   ,/* position           := */ IdentDef:Pos
                                   ,/* label              := */ label
                                   ,/* namePath           := */ NamePath
                                   ,/* env                := */ NIL);

  FormalPars:TableIn            := \OB.\mScopeEntry(TableTmp);

  Next:TableIn                  := \E.\DefineProcedureEntry
                                   (/* Table              := */ TableTmp
                                   ,/* Entry              := */ TableTmp
                                   ,/* ForwardEntry       := */ \OB.\cmtEntry
                                   ,/* Level              := */ LevelIn
                                   ,/* Ident              := */ IdentDef:Ident
                                   ,/* ExportMode         := */ IdentDef:ExportMode
                                   ,/* Label              := */ label
                                   ,/* Type               := */ \OB.\mProcedureTypeRepr
                                                                (/* entry          := */ \OB.\cNonameEntry
                                                                ,/* size           := */ \OT.\SIZEoPROCEDURE
                                                                ,/* typeBlocklists := */ \OB.\mTypeBlocklists(NIL,NIL)
                                                                ,/* isInTDescList  := */ FALSE
                                                                ,/* label          := */ \LAB.\MT
                                                                ,/* signatureRepr  := */ FormalPars:SignatureReprOut
                                                                ,/* resultType     := */ FormalPars:ResultTypeReprOut
                                                                ,/* paramSpace     := */ paramSpace)
                                   ,/* Env                := */ NIL
                                   );

  TableOut                      := Next:TableOut;
}.

/*---------------------------------------------------------------------------*/
BoundProcDecl =
[ ReceiverTypeRepr     : tOB       ]    /* The _record_ type of the receiver                                                    */
[ ProcTypeRepr         : tOB       ]    /* Procedure type of the current procedure                                              */
[ AlreadyExistingField : tOB       ]    /* Receiver's record field or bound procedure with same name as current bound procedure */
[ CurrBProcEntry       : tOB       ]    /* Entry of the current bound procedure                                                 */
[ ErrorMsg             : tErrorMsg ]
{
  Receiver:TableIn              := \OB.\mScopeEntry(\DRV.\ShowProcCount(TableIn));

  ReceiverTypeRepr              := \T.\ReceiverRecordTypeOfType(Receiver:TypeReprOut);

  FormalPars:TableIn            := Receiver:TableOut;

  ProcTypeRepr                  := \OB.\mProcedureTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ \OT.\SIZEoPROCEDURE
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* signatureRepr      := */ FormalPars:SignatureReprOut
                                   ,/* resultType         := */ FormalPars:ResultTypeReprOut
                                   ,/* paramSpace         := */ paramSpace);

  AlreadyExistingField          := \E.\Lookup0
                                   (\T.\FieldsOfRecordType(ReceiverTypeRepr)
                                   ,IdentDef:Ident);
  ErrorMsg BEFORE DeclSection:TableIn;
  ErrorMsg                      := \T.\CheckBoundProc
                                   (/* module             := */ ModuleIn     
                                   ,/* field              := */ AlreadyExistingField
                                   ,/* boundProcType      := */ ProcTypeRepr
                                   ,/* isForward          := */ FALSE
                                   ,/* receiverType       := */ ReceiverTypeRepr
                                   ,/* boundProcIdent     := */ IdentDef:Ident);

  CurrBProcEntry                := \OB.\mBoundProcEntry
                                   (/* prevEntry          := */ \OB.\cmtEntry
                                   ,/* module             := */ ModuleIn     
                                   ,/* ident              := */ IdentDef:Ident
                                   ,/* exportMode         := */ IdentDef:ExportMode
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\DECLARED
                                   ,/* receiverSig        := */ Receiver:SignatureOut
                                   ,/* typeRepr           := */ ProcTypeRepr
                                   ,/* complete           := */ TRUE
                                   ,/* position           := */ IdentDef:Pos
                                   ,/* label              := */ label
                                   ,/* namePath           := */ NamePath
                                   ,/* redefinedProc      := */ \OB.\cmtEntry
                                   ,/* procNum            := */ \OB.\NOPROCNUM
                                   ,/* env                := */ env);

  DeclSection:TableIn           := \T.\BindProcedureToRecord
                                   (/* type               := */ ReceiverTypeRepr
                                   ,/* entry              := */ CurrBProcEntry
                                   ,/* table              := */ FormalPars:TableOut
                                   ,/* forwardEntry       := */ AlreadyExistingField
                                   ,/* currPosition       := */ IdentDef:Pos
                                   ,/* module             := */ ModuleIn);

  Stmts:TableIn                 := { Stmts:TableIn:=\E.\CheckUnresolvedForwardProcs                      /* !ForwardProcSolving */
                                                    (DeclSection:TableOut);
                                     IF ARG.\OptionShowStmtTables & (\FIL.\NestingDepth<=1) THEN 
                                        \OD.\DumpTable0(\E.\IdentOfEntry(ModuleIn)
                                                       ,Stmts:TableIn,\UTI.\MakeString('BOUND'),IdentDef:Ident);
                                     END; (* IF *)
                                   };
  Stmts:ResultTypeReprIn        := FormalPars:ResultTypeReprOut;

  Next:TableIn                  := TableIn;

  TableOut                      := Next:TableOut;

  Entry                         := CurrBProcEntry;
  Locals                        := DeclSection:TableOut;
}.

/*---------------------------------------------------------------------------*/
BoundForwardDecl =
[ ReceiverTypeRepr     : tOB       ]    /* The type of the receiver                                                             */
[ ProcTypeRepr         : tOB       ]    /* Procedure type of the current procedure                                              */
[ AlreadyExistingField : tOB       ]    /* Receiver's record field or bound procedure with same name as current bound procedure */
[ ErrorMsg             : tErrorMsg ]
{
  Receiver:TableIn              := \OB.\mScopeEntry(TableIn);

  ReceiverTypeRepr              := \T.\ReceiverRecordTypeOfType(Receiver:TypeReprOut);

  FormalPars:TableIn            := Receiver:TableOut;

  ProcTypeRepr                  := \OB.\mProcedureTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ \OT.\SIZEoPROCEDURE
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* signatureRepr      := */ FormalPars:SignatureReprOut
                                   ,/* resultType         := */ FormalPars:ResultTypeReprOut
                                   ,/* paramSpace         := */ paramSpace);

  AlreadyExistingField          := \E.\Lookup0
                                   (\T.\FieldsOfRecordType(ReceiverTypeRepr)
                                   ,IdentDef:Ident);
  ErrorMsg BEFORE Next:TableIn;
  ErrorMsg                      := \T.\CheckBoundProc
                                   (/* module             := */ ModuleIn     
                                   ,/* field              := */ AlreadyExistingField
                                   ,/* boundProcType      := */ ProcTypeRepr
                                   ,/* isForward          := */ TRUE
                                   ,/* receiverType       := */ ReceiverTypeRepr
                                   ,/* boundProcIdent     := */ IdentDef:Ident);

  Next:TableIn                  := \T.\BindProcedureToRecord
                                   (/* type               := */ ReceiverTypeRepr
                                   ,/* entry              := */ \OB.\mBoundProcEntry
                                                                (/* prevEntry      := */ \OB.\cmtEntry
                                                                ,/* module         := */ ModuleIn     
                                                                ,/* ident          := */ IdentDef:Ident
                                                                ,/* exportMode     := */ IdentDef:ExportMode
                                                                ,/* level          := */ LevelIn
                                                                ,/* declStatus     := */ \OB.\DECLARED
                                                                ,/* receiverSig    := */ Receiver:SignatureOut
                                                                ,/* typeRepr       := */ ProcTypeRepr
                                                                ,/* complete       := */ FALSE
                                                                ,/* position       := */ IdentDef:Pos                             
                                                                ,/* label          := */ label
                                                                ,/* namePath       := */ NamePath
                                                                ,/* redefinedProc  := */ \OB.\cmtEntry
                                                                ,/* procNum        := */ \OB.\NOPROCNUM
                                                                ,/* env            := */ NIL)
                                   ,/* table              := */ TableIn
                                   ,/* forwardEntry       := */ \OB.\cmtEntry
                                   ,/* currPosition       := */ IdentDef:Pos
                                   ,/* module             := */ ModuleIn);

  TableOut                      := Next:TableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
FormalPars =
[ Table             : tOB      THREAD      ]
[ SignatureReprOut  : tOB      SYNTHESIZED ]
[ ResultTypeReprOut : tOB      SYNTHESIZED ]
{
  FPSections:TableIn            := TableIn;

  Type:TableIn                  := TableIn;
  Type:ForwardPBaseIsOkIn       := FALSE;                                                  /* !ForwardType, !ForwardTypeSolving */
  Type:OpenArrayIsOkIn          := FALSE;                                                                    /* !LegalOpenArray */
  Type:IsVarParTypeIn           := FALSE;                                                                     /* !RecursiveType */

  SignatureReprOut              := FPSections:SignatureReprOut;
  ResultTypeReprOut             := Type:TypeReprOut;
  TableOut                      := FPSections:TableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
FPSections =
[ Table             : tOB      THREAD      ]
[ SignatureReprOut  : tOB      SYNTHESIZED ]
{
  SignatureReprOut              := \OB.\cmtSignature;
}.

GenericFPSection =
{
  SignatureReprOut              := \OB.\mGenericSignature(); 
}.

FPSection =
{                                                                     /*
                                                                       * Method: - Create the parameter entries as TOBEDECLARED
                                                                       *         - Process the type
                                                                       *         - Set the created parameter entries to DECLARED
                                                                       */
  ParIds:Table1In               := TableIn;
  ParIds:ParModeIn              := ParMode;

  Type:TableIn                  := ParIds:Table1Out;                  /* All identifiers are now entered as TOBEDECLARED        */
  Type:ForwardPBaseIsOkIn       := FALSE;                                                  /* !ForwardType, !ForwardTypeSolving */
  Type:OpenArrayIsOkIn          := TRUE;                                                                     /* !LegalOpenArray */
  Type:IsVarParTypeIn           := (ParMode=\OB.\REFPAR);                                                     /* !RecursiveType */

  ParIds:TypeReprIn             := Type:TypeReprOut;
  ParIds:Table2In               := ParIds:Table1Out;
  ParIds:SignatureReprIn        := Next:SignatureReprOut;

  Next:TableIn                  := ParIds:Table2Out;                  /* All identifiers are now DECLARED                       */

  TableOut                      := Next:TableOut;
  SignatureReprOut              := ParIds:SignatureReprOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
ParIds =
[ Table1        : tOB      THREAD    ] /* pass 1 */
[ ParModeIn     : tParMode INHERITED ]

[ TypeReprIn    : tOB      INHERITED ] /* pass 2 */
[ Table2        : tOB      THREAD    ]
[ SignatureRepr : tOB      THREAD    ]
.
ParId =
{
  /* pass 1 */
  Next:Table1In                 := \OB.\mVarEntry
                                   (/* prevEntry          := */ Table1In
                                   ,/* module             := */ ModuleIn
                                   ,/* ident              := */ Ident
                                   ,/* exportMode         := */ \OB.\PRIVATE
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\TOBEDECLARED
                                   ,/* typeRepr           := */ \OB.\cmtObject
                                   ,/* isParam            := */ TRUE
                                   ,/* isReceiverPar      := */ FALSE
                                   ,/* parMode            := */ ParModeIn
                                   ,/* address            := */ 0
                                   ,/* refMode            := */ ParModeIn
                                   ,/* isWithed           := */ FALSE
                                   ,/* isLaccessed        := */ FALSE);

  Table1Out                     := Next:Table1Out;

  /* pass 2 */

  Next:Table2In                 := \E.\DefineVarEntry
                                   (/* table              := */ Table2In
                                   ,/* entry              := */ Next:Table1In
                                   ,/* level              := */ LevelIn
                                   ,/* ident              := */ Ident
                                   ,/* type               := */ TypeReprIn
                                   ,/* addr               := */ AddrOfPar
                                   ,/* refMode            := */ RefMode);
  Next:SignatureReprIn          := SignatureReprIn;

  Table2Out                     := Next:Table2Out;
  SignatureReprOut              := \OB.\mSignature
                                   (/* next               := */ Next:SignatureReprOut
                                   ,/* VarEntry           := */ Next:Table1In);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Receiver =
[ Table         : tOB      THREAD      ]
[ TypeReprOut   : tOB      SYNTHESIZED ]
[ SignatureOut  : tOB      SYNTHESIZED ]

[ TableTmp      : tOB ]
[ Entry         : tOB ]                                                                           /* Entry of the receiver type */
[ EntryTypeRepr : tOB ]                                                                           /* Type of the receiver type  */
{
  TableTmp                      := \OB.\mVarEntry
                                   (/* prevEntry          := */ TableIn
                                   ,/* module             := */ ModuleIn
                                   ,/* ident              := */ Name
                                   ,/* exportMode         := */ \OB.\PRIVATE
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\TOBEDECLARED
                                   ,/* typeRepr           := */ \OB.\cmtObject
                                   ,/* isParam            := */ TRUE
                                   ,/* isReceiverPar      := */ TRUE
                                   ,/* parMode            := */ ParMode
                                   ,/* address            := */ AddrOfPar
                                   ,/* refMode            := */ \OB.\REFPAR
                                   ,/* isWithed           := */ FALSE
                                   ,/* isLaccessed        := */ FALSE);

  Entry                         := \E.\Lookup(TableIn,TypeIdent);
  EntryTypeRepr                 := \E.\TypeOfTypeEntry(Entry);

  TypeReprOut                   := \T.\LegalReceiverTypeOnly(EntryTypeRepr);
  TableOut                      := \E.\DefineVarEntry
                                   (/* table              := */ TableTmp
                                   ,/* entry              := */ TableTmp
                                   ,/* level              := */ LevelIn
                                   ,/* ident              := */ Name
                                   ,/* type               := */ TypeReprOut
                                   ,/* addr               := */ AddrOfPar
                                   ,/* refMode            := */ ParMode);
  SignatureOut                  := \OB.\mSignature
                                   (/* next               := */ \OB.\cmtObject
                                   ,/* VarEntry           := */ TableOut);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Type =
[ FirstTypeReprOut    : tOB     SYNTHESIZED ]                 /* Yields the root type node fragment, without sub nodes          */
[ Table               : tOB     THREAD      ]
[ ForwardPBaseIsOkIn  : BOOLEAN INHERITED   ]                 /* Flags the legality of a POINTER TO T, where T is still unknown */
[ OpenArrayIsOkIn     : BOOLEAN INHERITED   ]                 /* Flags the legality of ARRAY OF T                               */
[ IsVarParTypeIn      : BOOLEAN INHERITED   ]                 /* Flags an immediate VAR-parameter context                       */

[ TypeReprOut         : tOB     SYNTHESIZED ]
{
  FirstTypeReprOut              := \OB.\cmtTypeRepr;

  TableOut                      := TableIn;
  TypeReprOut                   := \OB.\cmtTypeRepr;
}.

/*---------------------------------------------------------------------------*/
NamedType =
{
  Qualidents:TableIn            := TableIn;

  TypeReprOut                   := \E.\TypeOfTypeEntry(Qualidents:EntryOut);
}.

/*---------------------------------------------------------------------------*/
ArrayType =
{
  FirstTypeReprOut              := \OB.\mArrayTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ 0
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* len                := */ 0
                                   ,/* elemTypeRepr       := */ \OB.\cmtTypeRepr);

  Type:TableIn                  := TableIn;
  Type:ForwardPBaseIsOkIn       := FALSE;                                                  /* !ForwardType, !ForwardTypeSolving */
  Type:OpenArrayIsOkIn          := FALSE;                                                                    /* !LegalOpenArray */
  Type:IsVarParTypeIn           := FALSE;                                                                     /* !RecursiveType */

  ArrayExprLists:TableIn        := TableIn;
  ArrayExprLists:ElemTypeReprIn := Type:TypeReprOut;

  TypeReprOut                   := \T.\CopyArrayTypeRepr
                                   (/* typeFragment       := */ FirstTypeReprOut
                                   ,/* typeConstructed    := */ ArrayExprLists:TypeReprOut);
}.

/*---------------------------------------------------------------------------*/
OpenArrayType =
{
  FirstTypeReprOut              := \OB.\mArrayTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ 0
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* len                := */ \OB.\OPENARRAYLEN
                                   ,/* elemTypeRepr       := */ \OB.\cmtTypeRepr);

  Type:TableIn                  := TableIn;
  Type:ForwardPBaseIsOkIn       := FALSE;                                                  /* !ForwardType, !ForwardTypeSolving */
  Type:IsVarParTypeIn           := FALSE;                                                                     /* !RecursiveType */

  TypeReprOut                   := \T.\CompleteOpenArrayTypeRepr
                                   (/* type               := */ FirstTypeReprOut
                                   ,/* elemTypeRepr       := */ Type:TypeReprOut);
}.

/*---------------------------------------------------------------------------*/
PointerType =
[ BaseTypeEntry : tOB       ]                                                      /* The (type-)entry of the pointer base type */
[ BaseTypePos   : tPosition ]                                                      /* The position of the pointer base type     */
{
  FirstTypeReprOut              := \OB.\mPointerTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ \OT.\SIZEoPOINTER
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* baseTypeEntry      := */ \OB.\cNonameEntry);

  BaseTypeEntry                 := \OB.\cmtObject;
  BaseTypePos                   := \POS.\NoPosition;

  TypeReprOut                   := \T.\CompletePointerTypeRepr
                                   (/* type               := */ FirstTypeReprOut
                                   ,/* baseTypeEntry      := */ BaseTypeEntry);
}.

PointerToIdType =
{
  TableOut, BaseTypeEntry       :=
  { BaseTypeEntry               := \E.\ApplyPointerBaseIdent
                                   (/* ForwardPBaseIsOkIn := */ ForwardPBaseIsOkIn
                                   ,/* Entry              := */ \E.\Lookup(TableIn,Ident)
                                   ,/* TableIn            := */ TableIn
                                   ,/* LevelIn            := */ LevelIn
                                   ,/* ModuleIn           := */ ModuleIn
                                   ,/* Ident              := */ Ident
                                   ,/* Position           := */ IdentPos
                                   ,/* TableOut           =: */ TableOut);
  };
  BaseTypePos                   := IdentPos;
}.

PointerToQualIdType =
{
  Qualidents:TableIn            := TableIn;

  BaseTypeEntry                 := Qualidents:EntryOut;
  BaseTypePos                   := Qualidents:Position;
}.

PointerToStructType =
{
  Type:TableIn                  := TableIn;
  Type:ForwardPBaseIsOkIn       := FALSE;                                                  /* !ForwardType, !ForwardTypeSolving */
  Type:OpenArrayIsOkIn          := TRUE;                                                                     /* !LegalOpenArray */
  Type:IsVarParTypeIn           := FALSE;                                                                     /* !RecursiveType */

  BaseTypeEntry                 := \OB.\mTypeEntry
                                   (/* prevEntry          := */ \OB.\cNonameEntry
                                   ,/* module             := */ ModuleIn
                                   ,/* ident              := */ \Idents.\NoIdent
                                   ,/* exportMode         := */ \OB.\PRIVATE
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\DECLARED
                                   ,/* typeRepr           := */ Type:TypeReprOut);
  BaseTypePos                   := Type:Position;
}.

/*---------------------------------------------------------------------------*/
ProcedureType =
{
  FirstTypeReprOut              := \OB.\mProcedureTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ \OT.\SIZEoPROCEDURE
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* signatureRepr      := */ \OB.\cmtSignature
                                   ,/* resultType         := */ \OB.\cmtTypeRepr
                                   ,/* paramSpace         := */ 0);

  FormalPars:TableIn            := \OB.\mScopeEntry(TableIn);

  TypeReprOut                   := \T.\CompleteProcedureTypeRepr
                                   (/* type               := */ FirstTypeReprOut
                                   ,/* signatureRepr      := */ FormalPars:SignatureReprOut
                                   ,/* resultType         := */ FormalPars:ResultTypeReprOut
                                   ,/* paramSpace         := */ paramSpace);

}.

/*---------------------------------------------------------------------------*/
RecordType =
{
  FirstTypeReprOut              := \OB.\mRecordTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ 0
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* extLevel           := */ 0
                                   ,/* baseTypeRepr       := */ \OB.\cmtObject
                                   ,/* extTypeReprList    := */ \OB.\cmtTypeReprList
                                   ,/* fields             := */ \OB.\cmtEntry
                                   ,/* nofBoundProcs      := */ 0);

  FieldLists:FieldTableIn       := \OB.\mScopeEntry(TableIn);

  TypeReprOut                   := \T.\CompleteRecordTypeRepr
                                   (/* type               := */ FirstTypeReprOut
                                   ,/* size               := */ FieldLists:SizeOut
                                   ,/* extLevel           := */ \OB.\ROOTEXTLEVEL
                                   ,/* baseTypeRepr       := */ \OB.\cmtObject
                                   ,/* extTypeReprList    := */ \OB.\cmtTypeReprList
                                   ,/* fields             := */ FieldLists:FieldTableOut);
}.

/*---------------------------------------------------------------------------*/
ExtendedType =
[ BaseTypeRepr : tOB    ]                                                                       /* Type of the record base type */
[ extLevel     : tLevel ]
{
  FirstTypeReprOut              := \OB.\mRecordTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ 0
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* extLevel           := */ 0
                                   ,/* baseTypeRepr       := */ \OB.\cmtObject
                                   ,/* extTypeReprList    := */ \OB.\cmtTypeReprList
                                   ,/* fields             := */ \OB.\cmtEntry
                                   ,/* nofBoundProcs      := */ 0);

  Qualidents:TableIn            := TableIn;

  BaseTypeRepr                  := \E.\TypeOfTypeEntry(Qualidents:EntryOut);

  FieldLists:FieldTableIn       := \T.\CloneRecordFields
                                   (/* NewScope           := */ \OB.\mScopeEntry(TableIn)
                                   ,/* BaseTypeRepr       := */ BaseTypeRepr);

  extLevel                      := 1+\T.\ExtLevelOfType(BaseTypeRepr); 
  TypeReprOut                   := \T.\CompleteRecordTypeRepr
                                   (/* type               := */ FirstTypeReprOut
                                   ,/* size               := */ FieldLists:SizeOut
                                   ,/* extLevel           := */ extLevel
                                   ,/* baseTypeRepr       := */ BaseTypeRepr
                                   ,/* extTypeReprList    := */ \OB.\cmtTypeReprList
                                   ,/* fields             := */ FieldLists:FieldTableOut);

  ==> \T.\AppendExtension(BaseTypeRepr,FirstTypeReprOut);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
ArrayExprLists =
[ ElemTypeReprIn : tOB INHERITED   ]                                                         /* Element type of the array type  */
[ TypeReprOut    : tOB SYNTHESIZED ]                                                         /* The complete array type         */
{
  TypeReprOut                   := \OB.\cmtObject;
}.

mtArrayExprList =
{
  TypeReprOut                   := ElemTypeReprIn;
}.

ArrayExprList =
[ Len      : oLONGINT ]                                                                      /* Formal array length             */
[ ElemSize : tSize    ]                                                                      /* Size of the element type        */
[ TypeSize : tSize    ]                                                                      /* Size of the complete array type */
{
  Next:TableIn                  := TableIn;

  ConstExpr:TableIn             := TableIn;

  Len                           := \V.\ValueOfInteger(ConstExpr:ValueReprOut);
  ElemSize                      := \T.\SizeOfType(Next:TypeReprOut);
  TypeSize                      := \OT.\NewArrayTypeSize                                     /* Calculates the complete size    */
                                   (/* len                := */ Len
                                   ,/* eSize              := */ ElemSize);

  TypeReprOut                   := \OB.\mArrayTypeRepr
                                   (/* entry              := */ \OB.\cNonameEntry
                                   ,/* size               := */ TypeSize
                                   ,/* typeBlocklists     := */ \OB.\mTypeBlocklists(NIL,NIL)
                                   ,/* isInTDescList      := */ FALSE
                                   ,/* label              := */ \LAB.\MT
                                   ,/* len                := */ Len
                                   ,/* elemTypeRepr       := */ Next:TypeReprOut);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
FieldLists =
[ FieldTable : tOB THREAD ]                                                           /* Holds the entries of the record fields */
.
FieldList =
{
  IdentLists:Table1In           := FieldTableIn;
  IdentLists:TooBigMsg          := \ERR.\MsgObjectTooBig;

  Type:TableIn                  := IdentLists:Table1Out;
  Type:ForwardPBaseIsOkIn       := FALSE;                                                  /* !ForwardType, !ForwardTypeSolving */
  Type:OpenArrayIsOkIn          := FALSE;                                                                    /* !LegalOpenArray */
  Type:IsVarParTypeIn           := FALSE;                                                                     /* !RecursiveType */

  IdentLists:Table2In           := IdentLists:Table1Out;
  IdentLists:TypeReprIn         := Type:TypeReprOut;

  Next:FieldTableIn             := IdentLists:Table2Out;

  FieldTableOut                 := Next:FieldTableOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
IdentLists =
[ Table1     : tOB       THREAD    ] /* pass 1 */               /* The still TOBEDECLARED entries for this ident list           */
[ TooBigMsg  : tErrorMsg INHERITED ]                            /* ... to be emitted, if the size exceeds the appropriate limit */

[ Table2     : tOB       THREAD    ] /* pass 2 */               /* The completed entries for this ident list                    */
[ TypeReprIn : tOB       INHERITED ]                            /* All elements of this ident list should be of this type       */
.
IdentList =
[ AlreadyDeclaredEntry : tOB ]                                  /* The entry with the same name as the current ident            */
{
  /* pass 1 */
  AlreadyDeclaredEntry          := \E.\Lookup0(Table1In,IdentDef:Ident);

  Next:Table1In                 := \OB.\mVarEntry
                                   (/* prevEntry          := */ Table1In
                                   ,/* module             := */ ModuleIn
                                   ,/* ident              := */ IdentDef:Ident
                                   ,/* exportMode         := */ IdentDef:ExportMode
                                   ,/* level              := */ LevelIn
                                   ,/* declStatus         := */ \OB.\TOBEDECLARED
                                   ,/* typeRepr           := */ \OB.\cmtObject
                                   ,/* isParam            := */ FALSE
                                   ,/* isReceiverPar      := */ FALSE
                                   ,/* parMode            := */ \OB.\VALPAR
                                   ,/* address            := */ 0
                                   ,/* refMode            := */ \OB.\VALPAR
                                   ,/* isWithed           := */ FALSE
                                   ,/* isLaccessed        := */ FALSE);

  Table1Out                     := Next:Table1Out;

  /* pass 2 */
  Next:Table2In                 := \E.\DefineVarEntry
                                   (/* table              := */ Table2In
                                   ,/* entry              := */ Next:Table1In
                                   ,/* level              := */ LevelIn
                                   ,/* ident              := */ IdentDef:Ident
                                   ,/* type               := */ TypeReprIn
                                   ,/* addr               := */ AddrOfVar
                                   ,/* refMode            := */ \OB.\VALPAR);

  Table2Out                     := Next:Table2Out;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Qualidents =
[ EntryOut : tOB SYNTHESIZED ]
{

  EntryOut                      := \OB.\cmtObject;
}.

mtQualident =
{
  EntryOut                      := \OB.\cErrorEntry;
}.

UnqualifiedIdent =
{
  EntryOut                      := \E.\Lookup(TableIn,Ident);
}.

QualifiedIdent =
[ ServerEntry : tOB ]                                                                             /* Entry of the server module */
{
  ServerEntry                   := \E.\Lookup(TableIn,ServerId);
  EntryOut                      := \E.\LookupExtern(ServerEntry,Ident);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Stmts =
{
  ReturnExistsOut               := FALSE;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Stmt =
{
  ReturnExistsOut               := Next:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
AssignStmt =
[ VarTypeRepr : tOB ]
{
  Designator:ValDontCareIn      := FALSE;                                                                      /* !ShortCircuit */
  Designator:IsCallDesignatorIn := FALSE;

  Exprs:ValDontCareIn           := FALSE;                                                                      /* !ShortCircuit */

  VarTypeRepr                   := Designator:TypeReprOut;
  Coerce                        := \CO.\GetCoercion
                                   (/* SrcType            := */ Exprs:TypeReprOut
                                   ,/* DstType            := */ VarTypeRepr);

  ==> \CO.\DoRealCoercion(Coerce,Exprs:ValueReprOut,Exprs:TypeReprOut); 
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
CallStmt =
{
  Designator:ValDontCareIn      := FALSE;                                                                      /* !ShortCircuit */
  Designator:IsCallDesignatorIn := TRUE;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
IfStmt =
{
  Exprs:ValDontCareIn           := FALSE;                                                                      /* !ShortCircuit */

  ReturnExistsOut               := Next:ReturnExistsOut
                                OR Then:ReturnExistsOut
                                OR Else:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
CaseStmt =
{
  Exprs:ValDontCareIn           := FALSE;                                                                      /* !ShortCircuit */

  Cases:CaseTypeReprIn          := \T.\LegalCaseExprTypesOnly(Exprs:TypeReprOut);
  Cases:LabelRangeIn            := \OB.\cmtLabelRange;
  Cases:LabelLimitsIn           := \OB.\cmtLabelRange; 

  ReturnExistsOut               := Next:ReturnExistsOut
                                OR Cases:ReturnExistsOut
                                OR Else:ReturnExistsOut;
  LabelLimits                   := Cases:LabelLimitsOut; 
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Cases =
[ CaseTypeReprIn : tOB INHERITED ]                                                         /* Type of the case expression       */
[ LabelRangeIn   : tOB INHERITED ]                                                         /* Set of the already occured labels */
[ LabelLimits    : tOB THREAD    ]
{
  ReturnExistsOut               := FALSE;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Case =
{
  CaseLabels:LabelRangeIn       := LabelRangeIn;
  CaseLabels:LabelLimitsIn      := LabelLimitsIn;

  Next:LabelRangeIn             := CaseLabels:LabelRangeOut;
  Next:LabelLimitsIn            := CaseLabels:LabelLimitsOut;

  ReturnExistsOut               := Next:ReturnExistsOut OR Stmts:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
CaseLabels =
[ CaseTypeReprIn : tOB INHERITED ]                                                         /* Type of the case expression       */
[ LabelRange     : tOB THREAD    ]                                                         /* Set of the already occured labels */
[ LabelLimits    : tOB THREAD    ]
.
CaseLabel =
{
  Next:LabelRangeIn             := \V.\ExtendLabelRange
                                   (/* labelRange         := */ LabelRangeIn
                                   ,/* value1             := */ ConstExpr1:ValueReprOut
                                   ,/* value2             := */ ConstExpr2:ValueReprOut);
  Next:LabelLimitsIn            := \V.\ExtendLabelLimits
                                   (/* labelLimit         := */ LabelLimitsIn
                                   ,/* value1             := */ ConstExpr1:ValueReprOut
                                   ,/* value2             := */ ConstExpr2:ValueReprOut);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
WhileStmt =
{
  Exprs:ValDontCareIn           := FALSE;                                                                      /* !ShortCircuit */

  ReturnExistsOut               := Next:ReturnExistsOut
                                OR Stmts:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
RepeatStmt =
{
  Exprs:ValDontCareIn           := FALSE;                                                                      /* !ShortCircuit */

  ReturnExistsOut               := Next:ReturnExistsOut
                                OR Stmts:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
ForStmt =
[ ControlVarTypeRepr : tOB ]                                                                   /* Type of the control variable  */
{
  CurLevel                      := LevelIn; 
  ControlVarEntry               := \E.\Lookup(TableIn,Ident);
  ControlVarTypeRepr            := \E.\TypeOfEntry(ControlVarEntry);

  From:ValDontCareIn            := FALSE;                                                                      /* !ShortCircuit */

  To:ValDontCareIn              := FALSE;                                                                      /* !ShortCircuit */

  FromCoerce                    := \CO.\GetCoercion
                                   (/* SrcType            := */ From:TypeReprOut
                                   ,/* DstType            := */ ControlVarTypeRepr);
  ToCoerce                      := \CO.\GetCoercion
                                   (/* SrcType            := */ To:TypeReprOut
                                   ,/* DstType            := */ ControlVarTypeRepr);

  ReturnExistsOut               := Next:ReturnExistsOut
                                OR Stmts:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
LoopStmt =
{
  ReturnExistsOut               := Next:ReturnExistsOut
                                OR Stmts:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
WithStmt =
{
  ReturnExistsOut               := Next:ReturnExistsOut
                                OR GuardedStmts:ReturnExistsOut
                                OR Else:ReturnExistsOut;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
GuardedStmts =
{
  ReturnExistsOut               := FALSE;
}.

GuardedStmt =
{
  Next:TableIn                  := TableIn;

  Guard:TableIn                 := TableIn;

  Stmts:TableIn                 := { Stmts:TableIn:=Guard:TableOut;
                                     IF ARG.\OptionShowWithTables & (\FIL.\NestingDepth<=1) THEN 
                                        \OD.\DumpTable0(E.\IdentOfEntry(ModuleIn)
                                                       ,Stmts:TableIn,\UTI.\MakeString('WITH'),\Idents.\NoIdent);
                                     END; (* IF *)
                                   };
  ReturnExistsOut               := Next:ReturnExistsOut OR Stmts:ReturnExistsOut;
  CurLevel                      := LevelIn;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Guard =
[ Table       : tOB THREAD ]
[ VarTypeRepr : tOB        ]                                                              /* Type of the variable to be guarded */
{
  VarEntry                      := Variable:EntryOut; 
  
  VarTypeRepr                   := \E.\TypeOfVarEntry(VarEntry);
  TypeTypeRepr                  := \E.\TypeOfTypeEntry(TypeId:EntryOut);

  TableOut                      := \E.\EntryWithed                                                           /* !WithedVariable */
                                   (/* Module             := */ ModuleIn
                                   ,/* Qualification      := */ \TT.\GetQualification(Variable)
                                   ,/* Table              := */ TableIn
                                   ,/* Variable           := */ Variable:EntryOut
                                   ,/* Type               := */ TypeTypeRepr);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
ReturnStmt =
{
  Exprs:ValDontCareIn           := FALSE;                                                                      /* !ShortCircuit */

  Coerce                        := \CO.\GetCoercion
                                   (/* SrcType            := */ Exprs:TypeReprOut
                                   ,/* DstType            := */ ResultTypeReprIn);

  ReturnExistsOut               := TRUE;

  ==> \CO.\DoRealCoercion(Coerce,Exprs:ValueReprOut,Exprs:TypeReprOut); 
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
ConstExpr =
[ TypeReprOut  : tOB SYNTHESIZED ]
[ ValueReprOut : tOB SYNTHESIZED ]
{
  Expr:ValDontCareIn            := FALSE;                                                                      /* !ShortCircuit */
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Exprs =
[ EntryOut          : tOB     SYNTHESIZED ]
[ IsLValueOut       : BOOLEAN SYNTHESIZED ]
[ IsWritableOut     : BOOLEAN SYNTHESIZED ]                                                  /* For read-only external L-Values */
{
  EntryOut                      := \OB.\cmtEntry;
  TypeReprOut                   := \OB.\cErrorTypeRepr;
  ValueReprOut                  := \OB.\cmtValue;
  IsLValueOut                   := FALSE;
  IsWritableOut                 := FALSE;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
MonExpr =
{
  TypeReprOut                   := Exprs:TypeReprOut;
}.

NegateExpr =
{
  ValueReprOut                  := \V.\NegateValue(Exprs:ValueReprOut);
  TypeReprOut                   := \T.\ConstTypeCorrection                                               /* !MinimalIntegerType */
                                   (/* Type               := */ Exprs:TypeReprOut
                                   ,/* Value              := */ ValueReprOut);
}.

IdentityExpr =
{
  ValueReprOut                  := Exprs:ValueReprOut;
}.

NotExpr =
{
  ValueReprOut                  := \V.\NotValue(Exprs:ValueReprOut);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
DyExpr =
{
  DyOperator:TypeRepr1In        := Expr1:TypeReprOut;
  DyOperator:ValueRepr1In       := Expr1:ValueReprOut;
  DyOperator:Expr1PosIn         := Expr1:Position;

  DyOperator:TypeRepr2In        := Expr2:TypeReprOut;
  DyOperator:ValueRepr2In       := Expr2:ValueReprOut;
  DyOperator:Expr2PosIn         := Expr2:Position;

  DyOperator:ValDontCareIn      := ValDontCareIn;
  Expr2:ValDontCareIn           := DyOperator:ValDontCareOut;

  TypeReprOut                   := DyOperator:TypeReprOut;
  ValueReprOut                  := DyOperator:ValueReprOut;

  ==> \CO.\DoRealCoercion(DyOperator:Coerce1,Expr1:ValueReprOut,Expr1:TypeReprOut); 
  ==> \CO.\DoRealCoercion(DyOperator:Coerce2,Expr2:ValueReprOut,Expr2:TypeReprOut); 
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
IsExpr =
{
  Designator:IsCallDesignatorIn := FALSE;

  TypeTypeRepr                  := \E.\TypeOfTypeEntry(TypeId:EntryOut);

  TypeReprOut                   := \OB.\cBooleanTypeRepr;
  ValueReprOut                  := \V.\TypeTestValue(Designator:TypeReprOut,TypeTypeRepr);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
SetExpr =
{
  TypeReprOut                   := \OB.\cSetTypeRepr;
  ConstValueRepr                := Elements:ValueReprOut; 
  ValueReprOut                  := { IF Elements:IsConstOut THEN 
                                        ValueReprOut:=Elements:ValueReprOut;
                                     ELSE 
                                        ValueReprOut:=\OB.\cmtValue;
                                     END;
                                   };
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
DesignExpr =
{
  Designator:IsCallDesignatorIn := FALSE;

  EntryOut                      := Designator:EntryOut;
  TypeReprOut                   := \T.\EmptyTypeToErrorType(Designator:TypeReprOut);
  ValueReprOut                  := Designator:ValueReprOut;
  IsLValueOut                   := \E.\IsVarEntry(Designator:EntryOut);
  IsWritableOut                 := Designator:IsWritableOut;
  
  Entry                         := EntryOut; 
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
SetConst =
{
  TypeReprOut                   := \OB.\cSetTypeRepr;
  ValueReprOut                  := \OB.\mSetValue      (/* v := */ Set      );
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
IntConst =
{
  TypeReprOut                   := \T.\MinimalIntegerType(Int);                                         /* !MinimalIntConstType */
  ValueReprOut                  := \OB.\mIntegerValue  (/* v := */ Int      );
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
RealConst =
{
  TypeReprOut                   := \OB.\cRealTypeRepr;
  ValueReprOut                  := \OB.\mRealValue     (/* v := */ Real     );
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
LongrealConst =
{
  TypeReprOut                   := \OB.\cLongrealTypeRepr;
  ValueReprOut                  := \OB.\mLongrealValue (/* v := */ Longreal );
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
CharConst =
{
  TypeReprOut                   := \OB.\cCharStringTypeRepr;                                               /* !CharEqualString1 */
  ValueReprOut                  := \OB.\mCharValue     (/* v := */ Char     );
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
StringConst =
{
  TypeReprOut                   := \OB.\cStringTypeRepr;
  ValueReprOut                  := \OB.\mStringValue   (/* v := */ String   );
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
NilConst =
{
  TypeReprOut                   := \OB.\cNilTypeRepr;
  ValueReprOut                  := \OB.\cNilValue;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Elements =
[ ValueReprOut : tOB     SYNTHESIZED ] 
[ IsConstOut   : BOOLEAN SYNTHESIZED ] 
{
  ValueReprOut                  := \OB.\cEmptySetValue;
  IsConstOut                    := TRUE; 
}.

Element =
{
  ValueReprOut,IsConstOut       := { ValueReprOut:=\V.\ExtendSet
                                     (/* set              := */ Next:ValueReprOut
                                     ,/* a                := */ Expr1:ValueReprOut
                                     ,/* b                := */ \TT.\ElementCorrection
                                                                (/* expr2          := */ Expr2
                                                                ,/* val1           := */ Expr1:ValueReprOut
                                                                ,/* val2           := */ Expr2:ValueReprOut)
                                     ,/* isConst          =: */ IsConstOut);
                                     IF ~Next:IsConstOut THEN IsConstOut:=FALSE; END; (* IF *)
                                    };

}.

/*------------------------------------------------------------------------------------------------------------------------------*/
DyOperator =
[ TypeRepr1In  : tOB       INHERITED   ]
[ ValueRepr1In : tOB       INHERITED   ]
[ Expr1PosIn   : tPosition INHERITED   ]

[ TypeRepr2In  : tOB       INHERITED   ]
[ ValueRepr2In : tOB       INHERITED   ]
[ Expr2PosIn   : tPosition INHERITED   ]

[ ValDontCare  : BOOLEAN   THREAD      ]
[ TypeReprOut  : tOB       SYNTHESIZED ]
[ ValueReprOut : tOB       SYNTHESIZED ]

{
  ValDontCareOut BEFORE TypeRepr2In, ValueRepr2In;

  ValDontCareOut                := ValDontCareIn;
  TypeReprOut                   := \OB.\cErrorTypeRepr;
  ValueReprOut                  := \OB.\cmtValue;

  Coerce1                       := \OB.\cmtCoercion;
  Coerce2                       := \OB.\cmtCoercion;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
RelationOper =
[ TypeReprTmp : tOB ]                                                            /* The concrete relation operates on this type */
{
  TypeReprOut                   := \OB.\cBooleanTypeRepr;

  TypeReprTmp                   := \T.\RelationInputType(TypeRepr1In,TypeRepr2In);

  Coerce1                       := \CO.\GetCoercion
                                   (/* SrcType            := */ TypeRepr1In
                                   ,/* DstType            := */ TypeReprTmp);
  Coerce2                       := \CO.\GetCoercion
                                   (/* SrcType            := */ TypeRepr2In
                                   ,/* DstType            := */ TypeReprTmp);

  ValueReprOut                  := \V.\RelationValue
                                   (/* arg1               := */ \CO.\DoCoercion
                                                                (/* coerce         := */ Coerce1
                                                                ,/* arg            := */ ValueRepr1In)
                                   ,/* arg2               := */ \CO.\DoCoercion
                                                                (/* coerce         := */ Coerce2
                                                                ,/* arg            := */ ValueRepr2In)
                                   ,/* operator           := */ Operator);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
InOper =
{
  TypeReprOut                   := \OB.\cBooleanTypeRepr;
  ValueReprOut                  := \V.\InValue(ValueRepr1In,ValueRepr2In);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
NumSetOper =
[ TypeReprTmp : tOB ]
{
  TypeReprTmp                   := \T.\SetOrSmallestNumTypeInclBoth(TypeRepr1In,TypeRepr2In);               /* !SmallestNumeric */

  Coerce1                       := \CO.\GetCoercion
                                   (/* SrcType            := */ TypeRepr1In
                                   ,/* DstType            := */ TypeReprTmp);
  Coerce2                       := \CO.\GetCoercion
                                   (/* SrcType            := */ TypeRepr2In
                                   ,/* DstType            := */ TypeReprTmp);

  ValueReprOut                  := \V.\OperationValue
                                   (/* arg1               := */ \CO.\DoCoercion
                                                                (/* coerce         := */ Coerce1
                                                                ,/* arg            := */ ValueRepr1In)
                                   ,/* arg2               := */ \CO.\DoCoercion
                                                                (/* coerce         := */ Coerce2
                                                                ,/* arg            := */ ValueRepr2In)
                                   ,/* operator           := */ Operator);
  TypeReprOut                   := \T.\ConstTypeCorrection                                               /* !MinimalIntegerType */
                                   (/* Type               := */ TypeReprTmp
                                   ,/* Value              := */ ValueReprOut);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
RDivOper =
{
  TypeReprTmp                   := \T.\SetOrSmallestRealType                                                /* !SmallestReal    */
                                   (\T.\SetOrSmallestNumTypeInclBoth(TypeRepr1In,TypeRepr2In));             /* !SmallestNumeric */
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
IntOper =
{
  TypeReprTmp                   := \T.\SmallestIntegerTypeInclBoth(TypeRepr1In,TypeRepr2In);                /* !SmallestInteger */
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
BoolOper =
{
  TypeReprOut                   := \OB.\cBooleanTypeRepr;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
OrOper =
{
  ValDontCareOut                := ValDontCareIn                                                               /* !ShortCircuit */
                                OR \V.\IsTrueValue(ValueRepr1In);
  ValueReprOut                  := \V.\OrValue(ValueRepr1In,ValueRepr2In);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
AndOper =
{
  ValDontCareOut                := ValDontCareIn                                                               /* !ShortCircuit */
                                OR \V.\IsFalseValue(ValueRepr1In);
  ValueReprOut                  := \V.\AndValue(ValueRepr1In,ValueRepr2In);
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Designator =
[ IsCallDesignatorIn : BOOLEAN  INHERITED   ]
[ EntryOut           : tOB      SYNTHESIZED ]
[ ValueReprOut       : tOB      SYNTHESIZED ]
[ IsWritableOut      : BOOLEAN  SYNTHESIZED ]

[ typeRepr  : tOB       ]
[ valueRepr : tOB       ]
[ endPos    : tPosition ]
{
  Entry                         := \E.\Lookup(TableIn,Ident);
  typeRepr                      := \E.\TypeOfEntry(Entry);
  valueRepr                     := \E.\ExprValueOfEntry(Entry);
  endPos                        := { endPos:=Position; \POS.\IncCol(endPos,\UTI.\IdentLength(Ident)); };

  Designations                  := \TT.\ArgumentCorrection
                                   (/* isCall             := */ IsCallDesignatorIn
                                   ,/* type               := */ typeRepr
                                   ,/* pos                := */ endPos
                                   ,/* next               := */ \TT.\DesignorToGuardedDesignation
                                                                (/* curModule      := */ ModuleIn
                                                                ,/* entry          := */ Entry
                                                                ,/* typeRepr       := */ typeRepr
                                                                ,/* designor       := */ Designors
                                                                ,/* mtDesignor     =: */ Designors)
                                   );

  Designations:EntryIn          := Entry;
  Designations:TypeReprIn       := typeRepr;
  Designations:ValueReprIn      := valueRepr;
  Designations:PrevEntryIn      := \OB.\cmtEntry;
  Designations:EntryPosition    := Position;
  Designations:IsWritableIn     := TRUE;

  EntryOut                      := Designations:EntryOut;
  TypeReprOut                   := Designations:TypeReprOut;
  ValueReprOut                  := Designations:ValueReprOut;
  IsWritableOut                 := Designations:IsWritableOut;
  SignatureRepr                 := Designations:SignatureReprOut; 
  ExprList                      := Designations:ExprListOut; 
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Indexor =
{
  ExprList:TableIn              := \OB.\cmtObject;
  ExprList:ModuleIn             := NIL;
  ExprList:ValDontCareIn        := FALSE;
  ExprList:SignatureIn          := \OB.\cmtObject;
  ExprList:ClosingPosIn         := \POS.\NoPosition;
}.

Argumentor =
{
  ExprList:TableIn              := \OB.\cmtObject;
  ExprList:ModuleIn             := NIL;
  ExprList:ValDontCareIn        := FALSE;
  ExprList:SignatureIn          := \OB.\cmtObject;
  ExprList:ClosingPosIn         := \POS.\NoPosition;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
Designations =
[ IsCallDesignatorIn : BOOLEAN   INHERITED   ]
[ PrevEntryIn        : tOB       INHERITED   ]
[ EntryPosition      : tPosition INHERITED   ]
[ Entry              : tOB       THREAD      ]
[ TypeRepr           : tOB       THREAD      ]
[ ValueRepr          : tOB       THREAD      ]
[ IsWritable         : BOOLEAN   THREAD      ]
[ SignatureReprOut   : tOB       SYNTHESIZED ]
[ ExprListOut        : tTree     SYNTHESIZED ]
{
  Entry                         := \OB.\cmtObject; 
  SignatureReprOut              := \OB.\cmtObject; 
  ExprListOut                   := \Tree.\NoTree; 
}.

/*---------------------------------------------------------------------------*/
Designation =
{
  Nextion                       := \Tree.\cmtDesignation;

  EntryOut                      := Nextion:EntryOut;
  TypeReprOut                   := Nextion:TypeReprOut;
  ValueReprOut                  := Nextion:ValueReprOut;
  IsWritableOut                 := Nextion:IsWritableOut;
  SignatureReprOut              := Nextion:SignatureReprOut; 
  ExprListOut                   := Nextion:ExprListOut; 
}.

/*---------------------------------------------------------------------------*/
Importing =
[ typeRepr : tOB       ]
[ endPos   : tPosition ]
{
  Entry                         := \E.\LookupExtern(EntryIn,Ident);
  typeRepr                      := \E.\TypeOfEntry(Entry);
  endPos                        := { endPos:=IdPos; \POS.\IncCol(endPos,\UTI.\IdentLength(Ident)); };

  Nextion                       := \TT.\ArgumentCorrection
                                   (/* isCall             := */ IsCallDesignatorIn
                                   ,/* type               := */ typeRepr
                                   ,/* pos                := */ endPos
                                   ,/* next               := */ \TT.\DesignorToDesignation
                                                                (/* entry          := */ Entry
                                                                ,/* typeRepr       := */ typeRepr
                                                                ,/* designor       := */ Nextor
                                                                ,/* mtDesignor     =: */ Nextor)
                                   );

  Nextion:PrevEntryIn           := EntryIn;
  Nextion:EntryIn               := Entry;
  Nextion:TypeReprIn            := typeRepr;
  Nextion:ValueReprIn           := \E.\ExprValueOfEntry(Entry);
  Nextion:IsWritableIn          := \E.\IsWritableEntry(Entry);                                          /* !ReadOnlyApplication */
}.

/*---------------------------------------------------------------------------*/
Selecting =
[ typeRepr : tOB       ]
[ endPos   : tPosition ]
{
  Entry                         := \T.\TypeSelected(TypeReprIn,Ident);
  typeRepr                      := \E.\TypeOfVarEntry(Entry);
  endPos                        := { endPos:=IdPos; \POS.\IncCol(endPos,\UTI.\IdentLength(Ident)); };

  Nextion                       := \TT.\ArgumentCorrection
                                   (/* isCall             := */ IsCallDesignatorIn
                                   ,/* type               := */ typeRepr
                                   ,/* pos                := */ endPos
                                   ,/* next               := */ \TT.\DesignorToGuardedDesignation
                                                                (/* curModule      := */ ModuleIn
                                                                ,/* entry          := */ Entry
                                                                ,/* typeRepr       := */ typeRepr
                                                                ,/* designor       := */ Nextor
                                                                ,/* mtDesignor     =: */ Nextor)
                                   );

  Nextion:PrevEntryIn           := EntryIn;
  Nextion:EntryIn               := Entry;
  Nextion:TypeReprIn            := typeRepr;
  Nextion:ValueReprIn           := \OB.\cmtValue;
  Nextion:IsWritableIn          := IsWritableIn                                                          /* !TransitiveReadOnly */
                                 & (  ~\E.\IsExternEntry(Entry,ModuleIn)                                /* !ReadOnlyApplication */
                                   OR \E.\IsWritableEntry(Entry)
                                   );
}.

/*---------------------------------------------------------------------------*/
Indexing =
[ endPos   : tPosition ]
{
  Len                           := \T.\LenOfArrayType(TypeReprIn);
  ElemTypeRepr                  := \T.\TypeIndexed(TypeReprIn);
  endPos                        := { endPos:=Op2Pos; \POS.\IncCol(endPos,1); };

  Nextion                       := \TT.\ArgumentCorrection
                                   (/* isCall             := */ IsCallDesignatorIn
                                   ,/* type               := */ ElemTypeRepr
                                   ,/* pos                := */ endPos
                                   ,/* next               := */ \TT.\DesignorToGuardedDesignation
                                                                (/* curModule      := */ ModuleIn
                                                                ,/* entry          := */ EntryIn
                                                                ,/* typeRepr       := */ ElemTypeRepr
                                                                ,/* designor       := */ Nextor
                                                                ,/* mtDesignor     =: */ Nextor)
                                   );

  Nextion:EntryIn               := EntryIn;
  Nextion:TypeReprIn            := ElemTypeRepr;
  Nextion:ValueReprIn           := \OB.\cmtValue;
  Nextion:IsWritableIn          := IsWritableIn;                                                         /* !TransitiveReadOnly */
}.

/*---------------------------------------------------------------------------*/
Dereferencing =
{
  BaseTypeRepr                  := \T.\TypeDereferenced(TypeReprIn);

  Nextion                       := \TT.\DesignorToDesignation
                                   (/* entry              := */ EntryIn
                                   ,/* typeRepr           := */ BaseTypeRepr
                                   ,/* designor           := */ Nextor
                                   ,/* mtDesignor         =: */ Nextor);

  Nextion:EntryIn               := EntryIn;
  Nextion:TypeReprIn            := BaseTypeRepr;
  Nextion:ValueReprIn           := \OB.\cmtValue;
  Nextion:IsWritableIn          := TRUE;
}.

/*---------------------------------------------------------------------------*/
Supering =
[ baseTypeRepr : tOB       ]
[ endPos       : tPosition ]
{
  Entry                         := EntryIn; 
  RcvEntry                      := PrevEntryIn; 
  baseTypeRepr                  := \T.\RecordBaseTypeOfType(\E.\ReceiverTypeOfBoundProc(EntryIn));
  endPos                        := { endPos:=Position; \POS.\IncCol(endPos,1); };

  Nextion                       := \TT.\ArgumentCorrection
                                   (/* isCall             := */ IsCallDesignatorIn
                                   ,/* type               := */ TypeReprIn
                                   ,/* pos                := */ endPos
                                   ,/* next               := */ \TT.\DesignorToDesignation
                                                                (/* entry          := */ EntryIn
                                                                ,/* typeRepr       := */ TypeReprIn
                                                                ,/* designor       := */ Nextor
                                                                ,/* mtDesignor     =: */ Nextor)
                                   );

  Nextion:EntryIn               := EntryIn;
  Nextion:TypeReprIn            := TypeReprIn;
  Nextion:ValueReprIn           := \OB.\cmtValue;
  Nextion:IsWritableIn          := IsWritableIn;
}.

/*---------------------------------------------------------------------------*/
Argumenting =
[ signature : tOB ]
{
  Entry                         := EntryIn; 
  ProcTypeRepr                  := TypeReprIn; 
  RcvEntry                      := PrevEntryIn; 

  Nextion                       := \TT.\DesignorToDesignation
                                   (/* entry              := */ EntryIn
                                   ,/* typeRepr           := */ TypeReprIn
                                   ,/* designor           := */ Nextor
                                   ,/* mtDesignor         =: */ Nextor);

  signature                     := \SI.\SignatureOfProcType(TypeReprIn);

  ExprList:SignatureIn          := signature;
  ExprList:ClosingPosIn         := Op2Pos;

  Nextion:EntryIn               := EntryIn;
  Nextion:TypeReprIn            := \T.\TypeArgumented(TypeReprIn);
  Nextion:ValueReprIn           := \OB.\cmtValue;
  Nextion:IsWritableIn          := IsWritableIn;
  
  SignatureReprOut              := signature; 
  ExprListOut                   := ExprList; 
}.

/*---------------------------------------------------------------------------*/
Guarding =
{
  StaticTypeRepr                := TypeReprIn; 
  TestTypeRepr                  := { IF IsImplicit THEN 
                                        TestTypeRepr := TypeReprIn;
                                     ELSE
                                        TestTypeRepr := \E.\TypeOfTypeEntry(Qualidents:EntryOut);
                                     END;
                                   };

  Nextion                       := \TT.\DesignorToDesignation
                                   (/* entry              := */ EntryIn
                                   ,/* typeRepr           := */ TypeReprIn
                                   ,/* designor           := */ Nextor
                                   ,/* mtDesignor         =: */ Nextor);

  Nextion:EntryIn               := EntryIn;
  Nextion:TypeReprIn            := TestTypeRepr;                                                                   /* !Guarding */
  Nextion:ValueReprIn           := \OB.\cmtValue;
  Nextion:IsWritableIn          := IsWritableIn;
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
ExprLists =
[ SignatureIn  : tOB       INHERITED ]
[ ClosingPosIn : tPosition INHERITED ]
.
ExprList =
[ parMode        : tParMode ]
[ formalTypeRepr : tOB      ]
{
  parMode                       := \SI.\ModeOfSignatureParam(SignatureIn);
  formalTypeRepr                := \SI.\TypeOfSignatureParam(SignatureIn);

  Coerce                        := \CO.\GetCoercion
                                   (/* SrcType            := */ Expr:TypeReprOut
                                   ,/* DstType            := */ formalTypeRepr);

  Next:SignatureIn              := \SI.\NextSignature(SignatureIn);

  ==> \CO.\DoRealCoercion(Coerce,Expr:ValueReprOut,Expr:TypeReprOut); 
}.

/*------------------------------------------------------------------------------------------------------------------------------*/
END Evaluator

/********************************************************************************************************************************/
MODULE SuperfluousApplications

RULE

UnqualifiedIdent ={
  CHECK superfluous_application_due_to_warning_suppression ( ModuleIn      ) ==> ;
}.

QualifiedIdent ={
  CHECK superfluous_application_due_to_warning_suppression ( ModuleIn      ) ==> ;
}.

Designor ={
  CHECK superfluous_application_due_to_warning_suppression ( Nextor        ) ==> ;
}.

Selector ={
  CHECK superfluous_application_due_to_warning_suppression ( OpPos         ) ==> ;
  CHECK superfluous_application_due_to_warning_suppression ( Ident         ) ==> ;
  CHECK superfluous_application_due_to_warning_suppression ( IdPos         ) ==> ;
}.

Indexor ={
  CHECK superfluous_application_due_to_warning_suppression ( Op1Pos        ) ==> ;
  CHECK superfluous_application_due_to_warning_suppression ( Op2Pos        ) ==> ;
}.

Dereferencor ={
  CHECK superfluous_application_due_to_warning_suppression ( OpPos         ) ==> ;
}.

Argumentor ={
  CHECK superfluous_application_due_to_warning_suppression ( Op1Pos        ) ==> ;
  CHECK superfluous_application_due_to_warning_suppression ( Op2Pos        ) ==> ;
}.

END SuperfluousApplications

/********************************************************************************************************************************/
MODULE Nil

EVAL RULE

AssignStmt={ ==> \V.\AdjustNilValue(Exprs:ValueReprOut,VarTypeRepr      ,Exprs:ValueReprOut); }.
ReturnStmt={ ==> \V.\AdjustNilValue(Exprs:ValueReprOut,ResultTypeReprIn ,Exprs:ValueReprOut); }.
DyExpr    ={ ==> \V.\AdjustNilValue(Expr2:ValueReprOut,Expr1:TypeReprOut,Expr2:ValueReprOut); 
             ==> \V.\AdjustNilValue(Expr1:ValueReprOut,Expr2:TypeReprOut,Expr1:ValueReprOut); }.
ExprList  ={ ==> \V.\AdjustNilValue(Expr:ValueReprOut ,formalTypeRepr   ,Expr:ValueReprOut ); }.

END Nil

/********************************************************************************************************************************/
MODULE Levels

EVAL DECLARE

 DeclSection DeclUnits Decls Procs FormalPars FPSections ParIds
 Receiver Type ArrayExprLists FieldLists IdentLists IdentDef Stmts 
 Cases CaseLabels GuardedStmts ConstExpr Exprs Elements Designors 
 ExprLists NewExprLists SysAsmExprLists
 = [ LevelIn : tLevel INHERITED ].                                    /* Holds the current scope nesting level                  */

RULE

Module ={
  DeclSection:LevelIn           := \OB.\MODULELEVEL;
  Stmts:LevelIn                 := \OB.\MODULELEVEL;
}.

ProcDecl ={
  FormalPars:LevelIn            := LevelIn+1;
  DeclSection:LevelIn           := LevelIn+1;
  Stmts:LevelIn                 := LevelIn+1;
}.

ForwardDecl ={
  FormalPars:LevelIn            := LevelIn+1;
}.

BoundProcDecl ={
  Receiver:LevelIn              := LevelIn+1;
  FormalPars:LevelIn            := LevelIn+1;
  DeclSection:LevelIn           := LevelIn+1;
  Stmts:LevelIn                 := LevelIn+1;
}.

BoundForwardDecl ={
  Receiver:LevelIn              := LevelIn+1;
  FormalPars:LevelIn            := LevelIn+1;
}.

RecordType ={
  FieldLists:LevelIn            := \OB.\FIELDLEVEL;
}.

ExtendedType ={
  FieldLists:LevelIn            := \OB.\FIELDLEVEL;
}.

END Levels

/********************************************************************************************************************************/
MODULE SizesAndAddrs

EVAL RULE

Module ={
  DeclSection:VarAddrIn         := \ADR.\GlobalVarBase;
  GlobalSpace                   := \ADR.\Align4(DeclSection:VarAddrOut-\ADR.\GlobalVarBase);
}.

DeclSection =
[ VarAddr : tAddress THREAD ]
.

DeclUnits =
[ VarAddr : tAddress THREAD ]
.

DeclUnit ={
  Decls:VarAddrIn               := VarAddrIn;
  Next:VarAddrIn                := Decls:VarAddrOut;
  VarAddrOut                    := Next:VarAddrOut;
}.

Decls =
[ VarAddr : tAddress THREAD ]
.

VarDecl ={
  IdentLists:VarAddrIn          := VarAddrIn;
  IdentLists:SizeIn             := 0;
  Next:VarAddrIn                := IdentLists:VarAddrOut;
  VarAddrOut                    := Next:VarAddrOut;
}.

ProcDecl =
[ paramSpace : tSize ]{
  FormalPars:ParAddrIn          := \ADR.\ProcParBase;
  paramSpace                    := FormalPars:ParAddrOut-\ADR.\ProcParBase;
  DeclSection:VarAddrIn         := \ADR.\LocalVarBase(DeclSection:LevelIn);
  LocalSpace                    := \ADR.\Align4(DeclSection:VarAddrIn-DeclSection:VarAddrOut);
}.

ForwardDecl =
[ paramSpace : tSize ]{
  FormalPars:ParAddrIn          := \ADR.\ProcParBase;
  paramSpace                    := FormalPars:ParAddrOut-\ADR.\ProcParBase;
}.

BoundProcDecl =
[ paramSpace : tSize ]{
  Receiver:ParAddrIn            := \ADR.\ProcParBase;
  FormalPars:ParAddrIn          := Receiver:ParAddrOut;
  paramSpace                    := FormalPars:ParAddrOut-\ADR.\ProcParBase;
  DeclSection:VarAddrIn         := \ADR.\LocalVarBase(DeclSection:LevelIn);
  LocalSpace                    := \ADR.\Align4(DeclSection:VarAddrIn-DeclSection:VarAddrOut);
}.

BoundForwardDecl =
[ paramSpace : tSize ]{
  Receiver:ParAddrIn            := \ADR.\ProcParBase;
  FormalPars:ParAddrIn          := Receiver:ParAddrOut;
  paramSpace                    := FormalPars:ParAddrOut-\ADR.\ProcParBase;
}.

FormalPars =
[ ParAddr : tAddress THREAD ]
.

FPSections =
[ ParAddr : tAddress THREAD ]
.

FPSection ={
  ParIds:ParAddrIn              := ParAddrIn;
  Next:ParAddrIn                := ParIds:ParAddrOut;
  ParAddrOut                    := Next:ParAddrOut;
}.

ParIds =
[ ParAddr : tAddress THREAD ]
.

ParId =
[ AddrOfPar : tAddress ]
[ RefMode   : tParMode ]{
  AddrOfPar                     ,
  RefMode                       ,
  Next:ParAddrIn                := { \ADR.\NextParAddr
                                     (/* parMode  := */ ParModeIn
                                     ,/* type     := */ TypeReprIn
                                     ,/* oldAddr  := */ ParAddrIn
                                     ,/* parAddr  =: */ AddrOfPar
                                     ,/* refMode  =: */ RefMode
                                     ,/* newAddr  =: */ Next:ParAddrIn);
                                   };
  ParAddrOut                    := Next:ParAddrOut;                                   
}.

Receiver =
[ ParAddr   : tAddress THREAD ]
[ AddrOfPar : tAddress        ]
[ RefMode   : tParMode        ]{
  AddrOfPar                     ,
  RefMode                       ,
  ParAddrOut                    := { \ADR.\NextParAddr
                                     (/* parMode  := */ ParMode
                                     ,/* type     := */ EntryTypeRepr
                                     ,/* oldAddr  := */ ParAddrIn
                                     ,/* parAddr  =: */ AddrOfPar
                                     ,/* refMode  =: */ RefMode
                                     ,/* newAddr  =: */ ParAddrOut);
                                   };
}.

ProcedureType =
[ paramSpace : tSize ]{
  FormalPars:ParAddrIn          := \ADR.\ProcParBase;
  paramSpace                    := FormalPars:ParAddrOut-\ADR.\ProcParBase;
}.

RecordType ={
  FieldLists:SizeIn             := 0;
}.

ExtendedType ={
  FieldLists:SizeIn             := \T.\SizeOfType(BaseTypeRepr);
}.

FieldLists =
[ Size : tSize THREAD ]
.                      

FieldList ={
  IdentLists:VarAddrIn          := SizeIn;
  IdentLists:SizeIn             := SizeIn;
  Next:SizeIn                   := IdentLists:SizeOut;
  SizeOut                       := Next:SizeOut;
}.

IdentLists =
[ VarAddr : tAddress THREAD ]
[ Size    : tSize    THREAD ]
.                           

IdentList =
[ ItemSize  : tSize    ]
[ AddrOfVar : tAddress ]{
  ItemSize                      := \T.\SizeOfType(TypeReprIn);
  AddrOfVar,Next:VarAddrIn      := { \ADR.\NextVarAddr
                                     (/* level     := */ LevelIn  
                                     ,/* oldAddr   := */ VarAddrIn
                                     ,/* typesize  := */ ItemSize
                                     ,/* varAddr   =: */ AddrOfVar
                                     ,/* newAddr   =: */ Next:VarAddrIn);
                                   };
  Next:SizeIn                   := \OT.\NewRecordTypeSize
                                   (/* oSize              := */ SizeIn
                                   ,/* fSize              := */ ItemSize);

  VarAddrOut                    := Next:VarAddrOut;
  SizeOut                       := Next:SizeOut;
}.

END SizesAndAddrs

/********************************************************************************************************************************/
MODULE Temporaries

EVAL DECLARE

 Stmts Cases GuardedStmts
 Exprs Elements Designator Designations ExprLists NewExprLists
 = [ TempOfs : tAddress THREAD ].

RULE

Module ={
  Stmts:TempOfsIn               := \ADR.\GlobalTmpBase;
  
  TempSpace                     := \ADR.\GlobalTmpBase-Stmts:TempOfsOut; 
}.

ProcDecl ={
  Stmts:TempOfsIn               := -\ADR.\Align4(-DeclSection:VarAddrOut);

  TempSpace                     := Stmts:TempOfsIn-Stmts:TempOfsOut; 
}.

BoundProcDecl ={
  Stmts:TempOfsIn               := -\ADR.\Align4(-DeclSection:VarAddrOut);

  TempSpace                     := Stmts:TempOfsIn-Stmts:TempOfsOut; 
}.

AssignStmt ={
  Designator:TempOfsIn          := TempOfsIn; 
  Exprs:TempOfsIn               := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize3(Designator:TempOfsOut,Exprs:TempOfsOut,Next:TempOfsOut); 
}.

CallStmt ={
  Designator:TempOfsIn          := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Designator:TempOfsOut,Next:TempOfsOut); 
}.

IfStmt ={
  Exprs:TempOfsIn               := TempOfsIn; 
  Then:TempOfsIn                := TempOfsIn; 
  Else:TempOfsIn                := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize4(Exprs:TempOfsOut,Then:TempOfsOut,Else:TempOfsOut,Next:TempOfsOut); 
}.

CaseStmt ={
  Exprs:TempOfsIn               := TempOfsIn; 
  Cases:TempOfsIn               := TempOfsIn; 
  Else:TempOfsIn                := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize4(Exprs:TempOfsOut,Cases:TempOfsOut,Else:TempOfsOut,Next:TempOfsOut); 
}.

WhileStmt ={
  Exprs:TempOfsIn               := TempOfsIn; 
  Stmts:TempOfsIn               := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize3(Exprs:TempOfsOut,Stmts:TempOfsOut,Next:TempOfsOut); 
}.

RepeatStmt ={
  Stmts:TempOfsIn               := TempOfsIn; 
  Exprs:TempOfsIn               := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize3(Exprs:TempOfsOut,Stmts:TempOfsOut,Next:TempOfsOut); 
}.

ForStmt ={
  TempAddr                      := TempOfsIn-4; 

  From:TempOfsIn                := TempOfsIn; 
  To:TempOfsIn                  := TempOfsIn; 
  Stmts:TempOfsIn               := TempAddr; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize4(From:TempOfsOut,To:TempOfsOut,Stmts:TempOfsOut,Next:TempOfsOut); 
}.

LoopStmt ={
  Stmts:TempOfsIn               := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Stmts:TempOfsOut,Next:TempOfsOut); 
}.

WithStmt ={
  GuardedStmts:TempOfsIn        := TempOfsIn; 
  Else:TempOfsIn                := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize3(GuardedStmts:TempOfsOut,Else:TempOfsOut,Next:TempOfsOut); 
}.

Case ={
  Stmts:TempOfsIn               := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Stmts:TempOfsOut,Next:TempOfsOut); 
}.

GuardedStmt ={
  Stmts:TempOfsIn               := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Stmts:TempOfsOut,Next:TempOfsOut); 
}.

ConstExpr ={
  Expr:TempOfsIn                := 0; 
}.

DyExpr ={
  Expr1:TempOfsIn               := TempOfsIn; 
  Expr2:TempOfsIn               := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Expr1:TempOfsOut,Expr2:TempOfsOut); 
}.

IsExpr ={
  Designator:TempOfsIn          := TempOfsIn; 
  
  TempOfsOut                    := Designator:TempOfsOut; 
}.

SetExpr ={
  Elements:TempOfsIn            := TempOfsIn; 
  
  TempOfsOut                    := Elements:TempOfsOut; 
}.

DesignExpr ={
  Designator:TempOfsIn          := TempOfsIn; 
  
  TempOfsOut                    := Designator:TempOfsOut; 
}.

Element ={
  Expr1:TempOfsIn               := TempOfsIn; 
  Expr2:TempOfsIn               := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize3(Expr1:TempOfsOut,Expr2:TempOfsOut,Next:TempOfsOut); 
}.

Designator ={
  Designations:TempOfsIn        := TempOfsIn; 
  
  TempOfsOut                    := Designations:TempOfsOut; 
}.

Indexor ={
  ExprList:TempOfsIn            := 0; 
}.

Argumentor ={
  ExprList:TempOfsIn            := 0; 
}.

Indexing ={
  TempAddr,Expr:TempOfsIn       := { IF Len=\OB.\OPENARRAYLEN THEN
                                        TempAddr:=TempOfsIn-4; Expr:TempOfsIn:=TempAddr; 
                                     ELSE
                                        TempAddr:=0; Expr:TempOfsIn:=TempOfsIn; 
                                     END; }; 
  Nextion:TempOfsIn             := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Expr:TempOfsOut,Nextion:TempOfsOut); 
}.

Argumenting ={
  ExprList:TempOfsIn            := TempOfsIn; 

  TempOfsOut                    := ExprList:TempOfsOut; 
}.                                                        

PredeclArgumenting1 ={
  Expr:TempOfsIn                := TempOfsIn; 
  ExprLists:TempOfsIn           := 0; 

  TempOfsOut                    := Expr:TempOfsOut; 
}.

PredeclArgumenting2Opt ={
  Expr1:TempOfsIn               := TempOfsIn; 
  Expr2:TempOfsIn               := TempOfsIn; 
  ExprLists:TempOfsIn           := 0; 

  TempOfsOut                    := \ADR.\MinSize2(Expr1:TempOfsOut,Expr2:TempOfsOut); 
}.

PredeclArgumenting3 ={
  Expr1:TempOfsIn               := TempOfsIn; 
  Expr2:TempOfsIn               := TempOfsIn; 
  Expr3:TempOfsIn               := TempOfsIn; 
  ExprLists:TempOfsIn           := 0; 

  TempOfsOut                    := \ADR.\MinSize3(Expr1:TempOfsOut,Expr2:TempOfsOut,Expr3:TempOfsOut); 
}.

TypeArgumenting ={
  ExprLists:TempOfsIn           := 0; 
}.

SysValArgumenting ={
  Expr:TempOfsIn                := TempOfsIn; 

  TempAddr                      := Expr:TempOfsOut
                                 - \ADR.\Align4(\ADR.\MaxSize3(\T.\SizeOfType(TypeTypeRepr)
                                                              ,\T.\SizeOfType(Expr:TypeReprOut)
                                                              ,1+\V.\LengthOfString(Expr:ValueReprOut)
                                                              )
                                               ); 

  TempOfsOut                    := TempAddr; 
}.

NewArgumenting ={
  Expr:TempOfsIn                := TempOfsIn; 
  NewExprLists:TempOfsIn        := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Expr:TempOfsOut,NewExprLists:TempOfsOut); 
}.

ExprList ={
  Expr:TempOfsIn                := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Expr:TempOfsOut,Next:TempOfsOut); 
}.

NewExprList ={
  Expr:TempOfsIn                := TempOfsIn; 
  Next:TempOfsIn                := TempOfsIn; 

  TempOfsOut                    := \ADR.\MinSize2(Expr:TempOfsOut,Next:TempOfsOut); 
}.          

SysAsmExprList ={
  Expr:TempOfsIn                := 0; 
}.

END Temporaries

/********************************************************************************************************************************/
MODULE Labels

EVAL DECLARE

 DeclSection DeclUnits Decls Procs
 = [ LabelPrefixIn : tLabel INHERITED ].

 Stmts Cases GuardedStmts
 = [ LoopEndLabelIn : tLabel INHERITED ].

RULE

Module ={
  DeclSection:LabelPrefixIn     := { IF IsForeign THEN 
                                        DeclSection:LabelPrefixIn:=\LAB.\NewGlobal(Idents.NoIdent);
                                     ELSE 
                                        DeclSection:LabelPrefixIn:=\LAB.\NewGlobal(Name);
                                     END; };
  Stmts:LoopEndLabelIn          := \LAB.\MT;                                                                     /* !ExitInLoop */
}.

ConstDecl =
[ label : tLabel ]{
  label                         := \LAB.\MakeGlobal
                                   (/* isExported         := */ (IdentDef:ExportMode#\OB.\PRIVATE)
                                   ,/* prefix             := */ LabelPrefixIn
                                   ,/* id                 := */ IdentDef:Ident);
}.

TypeDecl ={
  ==> \T.\DefineTypeReprLabel
      (TypeEntry
      ,\LAB.\App_Id(LabelPrefixIn,IdentDef:Ident)); 
}.

ProcDecl =
[ label : tLabel ]{
  label                         := \LAB.\MakeGlobal
                                   (/* isExported         := */ (IdentDef:ExportMode#\OB.\PRIVATE)
                                   ,/* prefix             := */ LabelPrefixIn
                                   ,/* id                 := */ IdentDef:Ident);
  DeclSection:LabelPrefixIn     := \LAB.\App_Id(LabelPrefixIn,IdentDef:Ident);
  Stmts:LoopEndLabelIn          := \LAB.\MT;                                                                     /* !ExitInLoop */
}.

ForwardDecl =
[ label : tLabel ]{
  label                         := \LAB.\MakeGlobal
                                   (/* isExported         := */ (IdentDef:ExportMode#\OB.\PRIVATE)
                                   ,/* prefix             := */ LabelPrefixIn
                                   ,/* id                 := */ IdentDef:Ident);
}.

BoundProcDecl =
[ label     : tLabel ]
[ typeident : tIdent ]{
  typeident                     := \E.\IdentOfEntry(\T.\EntryOfType(ReceiverTypeRepr)); 

  label                         := \LAB.\MakeBound
                                   (/* prefix             := */ LabelPrefixIn
                                   ,/* typeId             := */ typeident
                                   ,/* procId             := */ IdentDef:Ident);

  DeclSection:LabelPrefixIn     := label;
  Stmts:LoopEndLabelIn          := \LAB.\MT;                                                                     /* !ExitInLoop */
}.

BoundForwardDecl =
[ label : tLabel ]{
  label                         := \LAB.\MakeBound
                                   (/* prefix             := */ LabelPrefixIn
                                   ,/* typeId             := */ \E.\IdentOfEntry(\T.\EntryOfType(ReceiverTypeRepr))
                                   ,/* procId             := */ IdentDef:Ident);
}.

LoopStmt ={
  LoopEndLabel                  := \LAB.\NewLocal(); 
  Stmts:LoopEndLabelIn          := LoopEndLabel;
}.

ExitStmt ={
  LoopEndLabel                  := LoopEndLabelIn; 
}.

END Labels

/********************************************************************************************************************************/
MODULE NamePaths

EVAL DECLARE

 DeclSection DeclUnits Decls Procs FormalPars FPSections Type FieldLists
 = [ NamePathIn : tOB INHERITED ].

RULE

Module ={
  DeclSection:NamePathIn        := \OB.\mSelectNamePath(\OB.\mIdentNamePath(\OB.\cmtNamePath,Name));
}.

TypeDecl ={
  Type:NamePathIn               := \OB.\mIdentNamePath(NamePathIn,IdentDef:Ident); 
}.

VarDecl ={
  Type:NamePathIn               := \OB.\mIdentNamePath(NamePathIn,\TT.\IdentOfFirstVariable(IdentLists)); 
}.

Procs = 
[ NamePath : tOB]{
  NamePath                      := \OB.\cmtNamePath;
}.

ProcDecl ={
  NamePath                      := \OB.\mIdentNamePath(NamePathIn,IdentDef:Ident);
  FormalPars:NamePathIn         := \OB.\mSelectNamePath(NamePath);
  DeclSection:NamePathIn        := FormalPars:NamePathIn; 
}.

ForwardDecl ={
  NamePath                      := \OB.\mIdentNamePath(NamePathIn,IdentDef:Ident);
  FormalPars:NamePathIn         := \OB.\mSelectNamePath(NamePath);
}.

BoundProcDecl ={
  NamePath                      := \OB.\mIdentNamePath
                                   (\OB.\mSelectNamePath
                                    (\OB.\mIdentNamePath(NamePathIn,Receiver:TypeIdent))
                                   ,IdentDef:Ident);
  FormalPars:NamePathIn         := \OB.\mSelectNamePath(NamePath);
  DeclSection:NamePathIn        := FormalPars:NamePathIn; 
}.

BoundForwardDecl ={
  NamePath                      := \OB.\mIdentNamePath(NamePathIn,IdentDef:Ident);
  FormalPars:NamePathIn         := \OB.\mSelectNamePath(NamePath);
}.

FPSection ={
  Type:NamePathIn               := \OB.\mIdentNamePath(NamePathIn,\TT.\IdentOfFirstParameter(ParIds)); 
}.

ArrayType ={
  Type:NamePathIn               := \OB.\mIndexNamePath(NamePathIn); 
}.

OpenArrayType ={
  Type:NamePathIn               := \OB.\mIndexNamePath(NamePathIn); 
}.  

PointerToStructType ={
  Type:NamePathIn               := \OB.\mDereferenceNamePath(NamePathIn); 
}.  

RecordType ={
  FieldLists:NamePathIn         := \OB.\mSelectNamePath(NamePathIn);
}.

FieldList ={
  Type:NamePathIn               := \OB.\mIdentNamePath(NamePathIn,\TT.\IdentOfFirstVariable(IdentLists)); 
}.
END NamePaths

/********************************************************************************************************************************/
MODULE TypeDescriptors

EVAL DECLARE

 DeclSection DeclUnits Decls Procs Type FieldLists FormalPars FPSections
 = [ TDescListIn : tOB INHERITED ].
 
RULE

Module ={
  TDescList                     := \OB.\mTDescList(\OB.\cmtTDescElem); 
  DeclSection:TDescListIn       := TDescList; 
}.

TypeDecl ={
  ==> \T.\AppendTDesc(TDescListIn
                     ,TypeEntry
                     ,Type:NamePathIn);
}.

PointerToStructType ={
  ==> \T.\AppendTDesc(TDescListIn
                     ,BaseTypeEntry
                     ,\OB.\mDereferenceNamePath(NamePathIn));
}.

END TypeDescriptors

/********************************************************************************************************************************/
MODULE OptLaccess

EVAL RULE

Exprs                = [ MainEntryOut:tOB SYNTHESIZED ] { MainEntryOut             := \OB.\cmtEntry;             }.
DesignExpr           =                                  { MainEntryOut             := Designator:MainEntryOut;   }.

Designator           = [ MainEntryOut:tOB SYNTHESIZED ] { Designations:MainEntryIn := Entry;                   
                                                          MainEntryOut             := Designations:MainEntryOut; }.
Designations         = [ MainEntry:tOB THREAD ].
Designation          =                                  { Nextion:MainEntryIn      := MainEntryIn;
                                                          MainEntryOut             := Nextion:MainEntryOut;      }.
Dereferencing        =                                  { Nextion:MainEntryIn      := \OB.\cmtEntry;             }.

AssignStmt           = { ==> \E.\SetLaccess(Designator:MainEntryOut); }.
Argumenting          = { ==> { IF isBoundProc & \T.\IsRecordType(\T.ElemTypeOfArrayType(\E.\TypeOfEntry(PrevEntryIn))) THEN
                                  \E.\SetLaccess(MainEntryIn);
                               END; };
                       }.
ExprList             = { ==> { IF parMode=\OB.\REFPAR THEN 
                                  \E.\SetLaccess(Expr:MainEntryOut);
                               END; };
                       }.
/*
SysAdrArgumenting    = { ==> \E.\SetLaccess(Expr:MainEntryOut      ); }.
*/
DecIncArgumenting    = { ==> \E.\SetLaccess(Expr1:MainEntryOut     ); }.
CopyArgumenting      = { ==> \E.\SetLaccess(Expr1:MainEntryOut     ); }.
ExclInclArgumenting  = { ==> \E.\SetLaccess(Expr1:MainEntryOut     ); }.
SysGetArgumenting    = { ==> \E.\SetLaccess(Expr2:MainEntryOut     ); }.
SysGetregArgumenting = { ==> \E.\SetLaccess(Expr2:MainEntryOut     ); }.
SysNewArgumenting    = { ==> \E.\SetLaccess(Expr1:MainEntryOut     ); }.
NewArgumenting       = { ==> \E.\SetLaccess(Expr:MainEntryOut      ); }.

END OptLaccess

/********************************************************************************************************************************/
MODULE OptDisplay

EVAL DECLARE

 DeclSection DeclUnits Decls Procs FormalPars FPSections ParIds Type ArrayExprLists FieldLists 
 IdentLists Stmts Cases CaseLabels GuardedStmts ConstExpr Exprs Elements Designator Designations
 Designors ExprLists NewExprLists SysAsmExprLists = [ EnvIn : tOB INHERITED ].

RULE

Module = [env:tOB]{
  env                           := \OB.\mEnvironment(ModuleEntry,\OB.\NOLEVELS); 
  DeclSection:EnvIn             := env;
  Stmts:EnvIn                   := env;
}.

ProcDecl = [env:tOB]{
  env                           := \OB.\mEnvironment(NIL,\OB.\NOLEVELS); 
  FormalPars:EnvIn              := env;
  DeclSection:EnvIn             := env;
  Stmts:EnvIn                   := env;
}.

BoundProcDecl = [env:tOB]{
  env                           := \OB.\mEnvironment(NIL,\OB.\NOLEVELS); 
  FormalPars:EnvIn              := env;
  DeclSection:EnvIn             := env;
  Stmts:EnvIn                   := env;
}.

CallStmt ={
  ==> \E.\InclEnvLevel(EnvIn,\E.\LevelOfProcEntry(Designator:EntryOut)); 
}.

Argumenting ={
  ==> \E.\InclEnvLevel(EnvIn,\E.\LevelOfProcEntry(EntryIn)); 
}.

END OptDisplay

/********************************************************************************************************************************/
MODULE SysValAtVarParamPos

EVAL DECLARE

 Exprs Elements Designator Designations = [ isParamContextIn : BOOLEAN INHERITED ].
 
RULE

AssignStmt     = { Designator:isParamContextIn := FALSE; 
                        Exprs:isParamContextIn := FALSE; }.
CallStmt       = { Designator:isParamContextIn := FALSE; }.
IfStmt         = {      Exprs:isParamContextIn := FALSE; }.
CaseStmt       = {      Exprs:isParamContextIn := FALSE; }.
WhileStmt      = {      Exprs:isParamContextIn := FALSE; }.
RepeatStmt     = {      Exprs:isParamContextIn := FALSE; }.
ForStmt        = {       From:isParamContextIn := FALSE; 
                           To:isParamContextIn := FALSE; }.
ReturnStmt     = {      Exprs:isParamContextIn := FALSE; }.
ConstExpr      = {       Expr:isParamContextIn := FALSE; }.
ExprList       = {       Expr:isParamContextIn := TRUE;  }.
NewExprList    = {       Expr:isParamContextIn := TRUE;  }.
SysAsmExprList = {       Expr:isParamContextIn := FALSE; }.

END SysValAtVarParamPos

/********************************************************************************************************************************/
/*** END oberon.eva                                                                                                           ***/
/********************************************************************************************************************************/

