  (**************************************************************) 
  (*   This module was generated by BEG V1.75        *)
  (*        GMD Forschunsstelle an der Universitaet Karlsruhe   *)
  (*        Vincenz-Priessnitz-Str. 1 76131 Karlsruhe Germany   *)
  (**************************************************************)
MODULE Emit;
IMPORT SYSTEM, IR,RegAlloc,
(******* empty insertion IpInOut *******)
ConsBase,InOut,
(*++++++ start insertion IpTestImport ++++++*)
 BETO,
(*------ end   insertion IpTestImport ------*)
(******* empty insertion IpNtTypes *******)
(******* empty insertion IpText *******)
(******* empty insertion IpTypes *******)
(*++++++ start insertion IpEmit_i ++++++*)
 ADR,ARG,ASM,ASMOP,ERR,FIL,Idents,LAB,LIM,O,NDP; 

CONST 
      ntBReg         = IR.ntBReg;
      ntWReg         = IR.ntWReg;
      ntLReg         = IR.ntLReg;
      ntReg          = IR.ntReg;
      ntFXReg        = IR.ntFXReg;
      ntFYReg        = IR.ntFYReg;
      ntConstant     = IR.ntConstant;
      ntGv           = IR.ntGv;
      ntIreg         = IR.ntIreg;
      ntBreg         = IR.ntBreg;
      ntBregIreg     = IR.ntBregIreg;
      ntMemory       = IR.ntMemory;
      ntLab          = IR.ntLab;
      ntCond         = IR.ntCond;
      ntBool         = IR.ntBool;
      ntReducedStack = IR.ntReducedStack;
      ntStrCopyArgs  = IR.ntStrCopyArgs;
      ntArgs         = IR.ntArgs;
      ntRetyp        = IR.ntRetyp;
      ntAMem         = IR.ntAMem;
      ntAReg         = IR.ntAReg;
      ntAImm         = IR.ntAImm;
      ntAMemAReg     = IR.ntAMemAReg;
      ntAMemAImm     = IR.ntAMemAImm;
      ntARegAImm     = IR.ntARegAImm;
      ntAMemARegAImm = IR.ntAMemARegAImm;
      ntAVar         = IR.ntAVar;
CONST 
ah=ASM.ah;al=ASM.al;bh=ASM.bh;ch=ASM.ch;cl=ASM.cl;dh=ASM.dh;ax=ASM.ax;
dx=ASM.dx;eax=ASM.eax;ebx=ASM.ebx;ecx=ASM.ecx;edx=ASM.edx;esi=ASM.esi;
edi=ASM.edi;ebp=ASM.ebp;esp=ASM.esp;st=ASM.st;st1=ASM.st1;
b=ASM.b;w=ASM.w;l=ASM.l;s=ASM.s;

add=ASMOP.add;and=ASMOP.and;bound=ASMOP.bound;bt=ASMOP.bt;bts=ASMOP.bts;
btr=ASMOP.btr;call=ASMOP.call;cbw=ASMOP.cbw;cdq=ASMOP.cdq;cld=ASMOP.cld;
cwd=ASMOP.cwd;cwde=ASMOP.cwde;cmp=ASMOP.cmp;dec=ASMOP.dec;inc=ASMOP.inc;
ja=ASMOP.ja;jae=ASMOP.jae;jb=ASMOP.jb;jg=ASMOP.jg;jge=ASMOP.jge;jl=ASMOP.jl;
jle=ASMOP.jle;jmp=ASMOP.jmp;jnc=ASMOP.jnc;jnp=ASMOP.jnp;jns=ASMOP.jns;
jno=ASMOP.jno;jnz=ASMOP.jnz;js=ASMOP.js;jz=ASMOP.jz;idiv=ASMOP.idiv;
imul=ASMOP.imul;lea=ASMOP.lea;leave=ASMOP.leave;lods=ASMOP.lods;
loopnz=ASMOP.loopnz;mov=ASMOP.mov;movs=ASMOP.movs;movsbw=ASMOP.movsbw;
movsbl=ASMOP.movsbl;movswl=ASMOP.movswl;movzbl=ASMOP.movzbl;
movzbw=ASMOP.movzbw;movzwl=ASMOP.movzwl;neg=ASMOP.neg;not=ASMOP.not;
or=ASMOP.or;popl=ASMOP.popl;pushl=ASMOP.pushl;popf=ASMOP.popf;pushf=ASMOP.pushf;
sahf=ASMOP.sahf;sar=ASMOP.sar;shl=ASMOP.shl;shr=ASMOP.shr;repz=ASMOP.repz;
ret=ASMOP.ret;rol=ASMOP.rol;ror=ASMOP.ror;setc=ASMOP.setc;setnz=ASMOP.setnz;
seto=ASMOP.seto;setp=ASMOP.setp;sets=ASMOP.sets;setz=ASMOP.setz;sub=ASMOP.sub;
stos=ASMOP.stos;test=ASMOP.test;xor=ASMOP.xor;fdecstp=ASMOP.fdecstp;
fstsw=ASMOP.fstsw;fld=ASMOP.fld;fild=ASMOP.fild;fistp=ASMOP.fistp;
fst=ASMOP.fst;fstp=ASMOP.fstp;fcomp=ASMOP.fcomp;fcompp=ASMOP.fcompp;
fabs=ASMOP.fabs;fchs=ASMOP.fchs;fxch=ASMOP.fxch;

 VAR ai :LONGINT; 
              VAR    oper:ASMOP.tOper; sz:ASM.tSize; reg,r1,r2:IR.Register; ii,ofs,shift,len:LONGINT; set:SET; 
                     label,label1,label2,label3,label4,label5:LAB.T;
      localavail : IR.RegisterSet;

(******* empty insertion IpEmit *******)
TYPE   NtAttributes = RECORD
    BReg : RECORD
     END;
    WReg : RECORD
     END;
    LReg : RECORD
     END;
    Reg : RECORD
     END;
    FXReg : RECORD
     END;
    FYReg : RECORD
     END;
    Constant : RECORD
     END;
    Gv : RECORD
                     loc  :  ASM.tLocation;
     END;
    Ireg : RECORD
                     loc  :  ASM.tLocation;
     END;
    Breg : RECORD
                     loc  :  ASM.tLocation;
     END;
    BregIreg : RECORD
                     loc  :  ASM.tLocation;
     END;
    Memory : RECORD
                     loc  :  ASM.tLocation;
     END;
    Lab : RECORD
     END;
    Cond : RECORD
                     rel  :  ConsBase.tRelation;
     END;
    Bool : RECORD
     END;
    ReducedStack : RECORD
                     headerBaseReg  :  IR.Register;
                     displacementReg  :  IR.Register;
                     sizeReg  :  IR.Register;
                     tmpReg  :  IR.Register;
     END;
    StrCopyArgs : RECORD
     END;
    Args : RECORD
     END;
    Retyp : RECORD
     END;
    AMem : RECORD
                     oper  :  ASM.tOperand;
     END;
    AReg : RECORD
                     oper  :  ASM.tOperand;
     END;
    AImm : RECORD
                     oper  :  ASM.tOperand;
     END;
    AMemAReg : RECORD
                     oper  :  ASM.tOperand;
     END;
    AMemAImm : RECORD
                     oper  :  ASM.tOperand;
     END;
    ARegAImm : RECORD
                     oper  :  ASM.tOperand;
     END;
    AMemARegAImm : RECORD
                     oper  :  ASM.tOperand;
     END;
    AVar : RECORD
     END;
   END;
 VAR  RegisterSetEmpty : IR.RegisterSet;

              
PROCEDURE^EmitNtBReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtWReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtLReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtFXReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtFYReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtGv (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtIreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtBreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtBregIreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtMemory (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtLab (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtCond (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtBool (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtReducedStack (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtStrCopyArgs (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtArgs (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtRetyp (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtAMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtAReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtAMemAReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtAMemAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtARegAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtAMemARegAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
PROCEDURE^EmitNtAVar (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 

              PROCEDURE LR(to,from:IR.Register);
              BEGIN
               IF (to>=ebp) OR (from>=ebp) THEN
                  ASM.CS2( mov,l  ,  ASM.R(ConsBase.RegNil),ASM.R(ConsBase.RegNil) ); 
                  IF ARG.OptionCommentsInAsm THEN ASM.CmtS('LR '); ASM.CmtR(from); ASM.CmtS(' --> '); ASM.CmtR(to); END;
               ELSE
                  ASM.CS2( mov,ASM.RegSizeTab[to]  ,  ASM.R(from),ASM.R(to) ); 
                  IF ARG.OptionCommentsInAsm THEN ASM.CmtS('LR'); END;
               END;
               
               IF ARG.OptionShowStatistics THEN INC(FIL.ActP^.nofLRs); END;
              END LR;
            
              PROCEDURE Spill(reg:IR.Register; loc:RegAlloc.Spilllocation);
              BEGIN
               CASE reg OF
               |ConsBase.Regah,ConsBase.Regbh,ConsBase.Regch,ConsBase.Regdh: 
                  ASM.CS2( sub,l  ,  ASM.i(4),ASM.R(esp)        ); IF ARG.OptionCommentsInAsm THEN ASM.CmtS('Spill'); END;
                  ASM.CS2( mov,b  ,  ASM.R(reg),ASM.B(esp)          ); IF ARG.OptionCommentsInAsm THEN ASM.CmtS('Spill'); END;
               |ConsBase.Regst,ConsBase.Regst1:
                  IF ARG.OptionCommentsInAsm THEN ASM.CmtLnS('			Spill '); ASM.CmtR(reg); END;
               |ebp,esp:
                  ASM.C1 ( pushl  ,  ASM.R(ConsBase.RegNil) ); IF ARG.OptionCommentsInAsm THEN ASM.CmtR(reg); END;
               ELSE 
                  ASM.C1 ( pushl  ,  ASM.R(ASM.SizedRegTab[reg,l]) ); 
                  IF ARG.OptionCommentsInAsm THEN 
                     ASM.CmtS('Spill'); 
                     IF reg#ASM.SizedRegTab[reg,l] THEN ASM.CmtS(' '); ASM.CmtR(reg); END;
                  END;
               END;

               IF ARG.OptionShowStatistics THEN INC(FIL.ActP^.nofSpills); END;
              END Spill;
            
              PROCEDURE Restore(reg:IR.Register; loc:RegAlloc.Spilllocation);
              VAR sz:ASM.tSize;
              BEGIN
               CASE reg OF
               |ConsBase.Regal..ConsBase.Regdh:
                  ASM.CS2( mov,ASM.RegSizeTab[reg]  ,  ASM.B(esp),ASM.R(reg)   ); 
                  IF ARG.OptionCommentsInAsm THEN ASM.CmtS('Restore'); END;
                  ASM.CS2( add,l                    ,  ASM.i(4),ASM.R(esp) ); 
               |ConsBase.Regst,ConsBase.Regst1:
                  IF ARG.OptionCommentsInAsm THEN ASM.CmtLnS('			Restore '); ASM.CmtR(reg); END;
               ELSE 
                  ASM.C1 ( popl  ,  ASM.R(ASM.SizedRegTab[reg,l]) ); 
                  IF ARG.OptionCommentsInAsm THEN 
                     ASM.CmtS('Restore'); 
                     IF reg#ASM.SizedRegTab[reg,l] THEN ASM.CmtS(' '); ASM.CmtR(reg); END;
                  END;
               END; (* CASE *)
              END Restore; 

(*------ end   insertion IpEmit_i ------*)

PROCEDURE PerformActions (ai : RegAlloc.AllocIndex);
VAR i :LONGINT; 
BEGIN
(*<<<<<<<<<<<<<<<
   WITH RegAlloc.allocation [ai] DO
>>>>>>>>>>>>>>>*)
      FOR i:=1 TO RegAlloc.allocation [ai].num DO 
(*<<<<<<<<<<<<<<<
	 WITH a[i] DO
>>>>>>>>>>>>>>>*)
	    IF RegAlloc.allocation [ai].a[i].action=RegAlloc.aLr THEN   
             LR (RegAlloc.allocation [ai].a[i].regto, RegAlloc.allocation [ai].a[i].regfrom);
    IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Copy Register ');
                IR.PrintRegister (RegAlloc.allocation [ai].a[i].regfrom);
                InOut.WriteString (' into ');
                IR.PrintRegister (RegAlloc.allocation [ai].a[i].regto);
                InOut.WriteLn;
    END;
	    ELSE 
	       Restore (reg, RegAlloc.allocation [ai].a[i].spilllocation);
    IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Restore Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' from ');
                InOut.WriteInt (RegAlloc.allocation [ai].a[i].spilllocation,1);
                InOut.WriteLn;
    END;
	 END;
     END;
END PerformActions;
 
PROCEDURE WriteNest (i : INTEGER);
VAR j : INTEGER;
BEGIN
   FOR j:=1 TO i DO InOut.WriteString ('.  '); END;
END WriteNest;
PROCEDURE WriteAttrBReg (at: NtAttributes);
BEGIN
END WriteAttrBReg;
PROCEDURE WriteAttrWReg (at: NtAttributes);
BEGIN
END WriteAttrWReg;
PROCEDURE WriteAttrLReg (at: NtAttributes);
BEGIN
END WriteAttrLReg;
PROCEDURE WriteAttrReg (at: NtAttributes);
BEGIN
END WriteAttrReg;
PROCEDURE WriteAttrFXReg (at: NtAttributes);
BEGIN
END WriteAttrFXReg;
PROCEDURE WriteAttrFYReg (at: NtAttributes);
BEGIN
END WriteAttrFYReg;
PROCEDURE WriteAttrConstant (at: NtAttributes);
BEGIN
END WriteAttrConstant;
PROCEDURE WriteAttrGv (at: NtAttributes);
BEGIN
       InOut.WriteString ('loc=');
       BETO.PrinttLocation ( at.Gv.loc ); 
       InOut.Write (' ');
END WriteAttrGv;
PROCEDURE WriteAttrIreg (at: NtAttributes);
BEGIN
       InOut.WriteString ('loc=');
       BETO.PrinttLocation ( at.Ireg.loc ); 
       InOut.Write (' ');
END WriteAttrIreg;
PROCEDURE WriteAttrBreg (at: NtAttributes);
BEGIN
       InOut.WriteString ('loc=');
       BETO.PrinttLocation ( at.Breg.loc ); 
       InOut.Write (' ');
END WriteAttrBreg;
PROCEDURE WriteAttrBregIreg (at: NtAttributes);
BEGIN
       InOut.WriteString ('loc=');
       BETO.PrinttLocation ( at.BregIreg.loc ); 
       InOut.Write (' ');
END WriteAttrBregIreg;
PROCEDURE WriteAttrMemory (at: NtAttributes);
BEGIN
       InOut.WriteString ('loc=');
       BETO.PrinttLocation ( at.Memory.loc ); 
       InOut.Write (' ');
END WriteAttrMemory;
PROCEDURE WriteAttrLab (at: NtAttributes);
BEGIN
END WriteAttrLab;
PROCEDURE WriteAttrCond (at: NtAttributes);
BEGIN
       InOut.WriteString ('rel=');
       BETO.PrinttRelation ( at.Cond.rel ); 
       InOut.Write (' ');
END WriteAttrCond;
PROCEDURE WriteAttrBool (at: NtAttributes);
BEGIN
END WriteAttrBool;
PROCEDURE WriteAttrReducedStack (at: NtAttributes);
BEGIN
       InOut.WriteString ('headerBaseReg=');
       IR.PrintRegister ( at.ReducedStack.headerBaseReg ); 
       InOut.Write (' ');
       InOut.WriteString ('displacementReg=');
       IR.PrintRegister ( at.ReducedStack.displacementReg ); 
       InOut.Write (' ');
       InOut.WriteString ('sizeReg=');
       IR.PrintRegister ( at.ReducedStack.sizeReg ); 
       InOut.Write (' ');
       InOut.WriteString ('tmpReg=');
       IR.PrintRegister ( at.ReducedStack.tmpReg ); 
       InOut.Write (' ');
END WriteAttrReducedStack;
PROCEDURE WriteAttrStrCopyArgs (at: NtAttributes);
BEGIN
END WriteAttrStrCopyArgs;
PROCEDURE WriteAttrArgs (at: NtAttributes);
BEGIN
END WriteAttrArgs;
PROCEDURE WriteAttrRetyp (at: NtAttributes);
BEGIN
END WriteAttrRetyp;
PROCEDURE WriteAttrAMem (at: NtAttributes);
BEGIN
       InOut.WriteString ('oper=');
       BETO.PrinttOperand ( at.AMem.oper ); 
       InOut.Write (' ');
END WriteAttrAMem;
PROCEDURE WriteAttrAReg (at: NtAttributes);
BEGIN
       InOut.WriteString ('oper=');
       BETO.PrinttOperand ( at.AReg.oper ); 
       InOut.Write (' ');
END WriteAttrAReg;
PROCEDURE WriteAttrAImm (at: NtAttributes);
BEGIN
       InOut.WriteString ('oper=');
       BETO.PrinttOperand ( at.AImm.oper ); 
       InOut.Write (' ');
END WriteAttrAImm;
PROCEDURE WriteAttrAMemAReg (at: NtAttributes);
BEGIN
       InOut.WriteString ('oper=');
       BETO.PrinttOperand ( at.AMemAReg.oper ); 
       InOut.Write (' ');
END WriteAttrAMemAReg;
PROCEDURE WriteAttrAMemAImm (at: NtAttributes);
BEGIN
       InOut.WriteString ('oper=');
       BETO.PrinttOperand ( at.AMemAImm.oper ); 
       InOut.Write (' ');
END WriteAttrAMemAImm;
PROCEDURE WriteAttrARegAImm (at: NtAttributes);
BEGIN
       InOut.WriteString ('oper=');
       BETO.PrinttOperand ( at.ARegAImm.oper ); 
       InOut.Write (' ');
END WriteAttrARegAImm;
PROCEDURE WriteAttrAMemARegAImm (at: NtAttributes);
BEGIN
       InOut.WriteString ('oper=');
       BETO.PrinttOperand ( at.AMemARegAImm.oper ); 
       InOut.Write (' ');
END WriteAttrAMemARegAImm;
PROCEDURE WriteAttrAVar (at: NtAttributes);
BEGIN
END WriteAttrAVar;

PROCEDURE EmitNtBReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntBReg] OF 
   | 359 : 
  EmitNtLab(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtFXReg(e^.son[1]^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 359/3679 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.FlagSetOperTab[ASM.RevRelTab[e^.son[1]^.son[1]^.attr^.FloatCompare.rel],(*isSignedRelation:=*)0]; 
      NDP.CS1( fcomp,e^.son[1]^.son[1]^.son[2]^.gcg^.AMem.size  ,  ASM.Operand(AT1.AMem.oper)  );
      NDP.C1 ( fstsw         ,  ASM.R(ax)            );
      ASM.C0 ( sahf                              ); 
      ASM.C1 ( oper          ,  ASM.R(RegAlloc.allocation[ai].reg)             ); 
   | 358 : 
  EmitNtLab(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtAMem(e^.son[1]^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 358/3667 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.FlagSetOperTab[e^.son[1]^.son[1]^.attr^.FloatCompare.rel,(*isSignedRelation:=*)0]; 
      NDP.CS1( fcomp,e^.son[1]^.son[1]^.son[3]^.gcg^.AMem.size  ,  ASM.Operand(AT2.AMem.oper)  );
      NDP.C1 ( fstsw         ,  ASM.R(ax)            );
      ASM.C0 ( sahf                              ); 
      ASM.C1 ( oper          ,  ASM.R(RegAlloc.allocation[ai].reg)             ); 
   | 336 : 
  EmitNtLab(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFYReg(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtFXReg(e^.son[1]^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 336/3499 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.FlagSetOperTab[ASM.RevRelTab[e^.son[1]^.son[1]^.attr^.FloatCompare.rel],(*isSignedRelation:=*)0]; 
      NDP.C0( fcompp           );
      NDP.C1( fstsw   ,  ASM.R(ax) );
      ASM.C0( sahf             ); 
      ASM.C1( oper    ,  ASM.R(RegAlloc.allocation[ai].reg)  ); 
   | 335 : 
  EmitNtLab(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtFYReg(e^.son[1]^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 335/3487 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.FlagSetOperTab[e^.son[1]^.son[1]^.attr^.FloatCompare.rel,(*isSignedRelation:=*)0]; 
      NDP.C0( fcompp           );
      NDP.C1( fstsw   ,  ASM.R(ax) );
      ASM.C0( sahf             ); 
      ASM.C1( oper    ,  ASM.R(RegAlloc.allocation[ai].reg)  ); 
   | 267 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 267/3118 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 266 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 266/3117 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 265 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 265/3116 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 264 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 264/3115 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 263 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 263/3113 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 262 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 262/3112 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 261 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 261/3111 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 260 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 260/3110 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 247 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 247/3053 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Retype2Data ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2   ( mov,b   ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 244 : 
  EmitNtReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 244/3048 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Retype2Data ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.RegCopy(RegAlloc.allocation[ai].op[1],RegAlloc.allocation[ai].reg); 
   | 236 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 236/2963 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF    e^.son[1]^.attr^.Cc.condcoding=ASM.codeCF THEN ASM.C1 ( setc    ,  ASM.R(RegAlloc.allocation[ai].reg)                    );
      ELSIF e^.son[1]^.attr^.Cc.condcoding=ASM.codePF THEN ASM.C1 ( setp    ,  ASM.R(RegAlloc.allocation[ai].reg)                    );
      ELSIF e^.son[1]^.attr^.Cc.condcoding=ASM.codeZF THEN ASM.C1 ( setz    ,  ASM.R(RegAlloc.allocation[ai].reg)                    );
      ELSIF e^.son[1]^.attr^.Cc.condcoding=ASM.codeSF THEN ASM.C1 ( sets    ,  ASM.R(RegAlloc.allocation[ai].reg)                    );
      ELSIF e^.son[1]^.attr^.Cc.condcoding=ASM.codeOF THEN ASM.C1 ( seto    ,  ASM.R(RegAlloc.allocation[ai].reg)                    );
                                     ELSE ASM.C0 ( pushf                              );
                                          ASM.C1 ( popl    ,  ASM.R(eax)                  );
                                          ASM.CS2( test,l  ,  ASM.x(e^.son[1]^.attr^.Cc.condcoding),ASM.R(eax) );
                                          ASM.C1 ( setz    ,  ASM.R(RegAlloc.allocation[ai].reg)                    );
      END; 
   | 235 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 235/2956 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( bt,l  ,  ASM.R(RegAlloc.allocation[ai].op[3]),ASM.Loc(AT1.Memory.loc) );
      ASM.C1 ( setc  ,  ASM.R(RegAlloc.allocation[ai].reg)            ); 
   | 234 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[1]^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 234/2949 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,b  ,  ASM.i(1),ASM.Operand(AT1.AMem.oper) );
      ASM.C1 ( setnz   ,  ASM.R(RegAlloc.allocation[ai].reg)                 ); 
   | 233 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[1]^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 233/2938 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF RegAlloc.allocation[ai].reg=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],b] THEN 
      ASM.CS2( and,b        ,  ASM.i(1),ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],b]) ); 
      ELSE 
         ASM.CS2( test,b       ,  ASM.i(1),ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],b]) );
         ASM.C1 ( setnz        ,  ASM.R(RegAlloc.allocation[ai].reg)                         );
      END; 
   | 232 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 232/2930 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,l  ,  ASM.iL(e^.son[1]^.attr^.Is.typeLabel),ASM.oB(e^.son[1]^.attr^.Is.ttableElemOfs,RegAlloc.allocation[ai].op[2]) );
      ASM.C1 ( setz   ,  ASM.R(RegAlloc.allocation[ai].reg)                                      ); 
   | 231 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtAMemAReg(e^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 231/2922 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 set:={}; INCL(set,e^.son[1]^.son[2]^.gcg^.Constant.val); 
      ASM.CS2( test,l  ,  ASM.i(SYSTEM.VAL(LONGINT,set)),ASM.Operand(AT2.AMemAReg.oper) ); 
      ASM.C1 ( setnz   ,  ASM.R(RegAlloc.allocation[ai].reg)                             ); 
   | 230 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtAMemAReg(e^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 230/2912 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])            );
      ASM.C1 ( ja     ,  ASM.L(LAB.New(label))      );
      ASM.CS2( bt,l   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.Operand(AT2.AMemAReg.oper) ); 
      ASM.Label(label); 
      ASM.C1 ( setc   ,  ASM.R(RegAlloc.allocation[ai].reg)                   ); 
   | 229 : 
  EmitNtLab(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtBReg(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 229/2904 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 228 : 
  EmitNtCond(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 228/2897 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.FlagSetOperTab[AT0.Cond.rel,SYSTEM.VAL(SHORTINT,e^.son[1]^.attr^.Branch.isSigned)]; 
      ASM.C1 ( oper  ,  ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 219 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 219/2708 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Mod ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.gcg^.Constant.val=1 THEN 
         ASM.CS2( xor,b   ,  ASM.R(ah),ASM.R(ah)       ); 
      ELSIF ADR.IntLog2(e^.son[2]^.gcg^.Constant.val,shift) THEN
         ASM.CS2( mov,b   ,  ASM.R(al),ASM.R(ah)       ); 
         ASM.CS2( and,b   ,  ASM.i(e^.son[2]^.gcg^.Constant.val-1),ASM.R(ah) ); 
      ELSE 
         ASM.C0 ( cbw                          ); 
         ASM.CS2( mov,b   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].scr[1])  ); 
         ASM.CS1( idiv,b  ,  ASM.R(RegAlloc.allocation[ai].scr[1])            ); 
         ASM.CS2( test,b  ,  ASM.R(ah),ASM.R(ah)       ); 
         ASM.C1 ( jge     ,  ASM.L(LAB.New(label)) );
         ASM.CS2( add,b   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(ah)   );
         ASM.Label(label); 
      END; 
   | 216 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 216/2650 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Div ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.gcg^.Constant.val=1 THEN 
               (* nop                          *)
      ELSIF ADR.IntLog2(e^.son[2]^.gcg^.Constant.val,shift) THEN
         ASM.CS2( sar,b   ,  ASM.i(shift),ASM.R(RegAlloc.allocation[ai].op[1]) ); 
      ELSE 
         ASM.CS2( mov,b   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].scr[1])  ); 
         ASM.C0 ( cbw                          ); 
         ASM.CS1( idiv,b  ,  ASM.R(RegAlloc.allocation[ai].scr[1])            ); 
         ASM.CS2( test,b  ,  ASM.R(ah),ASM.R(ah)       ); 
         ASM.C1 ( jge     ,  ASM.L(LAB.New(label)) );
         ASM.CS1( dec,b   ,  ASM.R(al)             );
         ASM.Label(label);
      END; 
   | 175 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 175/2271 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,b   ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].op[1],b]),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 174 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 174/2270 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,b   ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].op[1],b]),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 173 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 173/2269 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Card2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 161 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 161/2226 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,l  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].scr[1])                    ); 
      ASM.CS2( mov,b  ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].scr[1],b]),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 146 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 146/2139 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 145 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 145/2138 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 144 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 144/2137 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 143 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 143/2136 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 142 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 142/2128 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,w  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].scr[1])                    ); 
      ASM.CS2( mov,b  ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].scr[1],b]),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 141 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 141/2126 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 140 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 140/2125 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 139 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 139/2124 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 138 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 138/2123 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 137 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 137/2119 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Int2Shortint ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 132 : 
  EmitNtRetyp(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 132/2087 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Retype2Data ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,b  ,  ASM.oB(e^.son[1]^.gcg^.Retyp.tmpOfs,ebp),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 116 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 116/1803 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Cap ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,b  ,  ASM.i(97),ASM.R(RegAlloc.allocation[ai].op[1])        );
      ASM.C1 ( jl     ,  ASM.L(LAB.New(label)) ); 
      ASM.CS2( cmp,b  ,  ASM.i(122),ASM.R(RegAlloc.allocation[ai].op[1])       );
      ASM.C1 ( jg     ,  ASM.L(label)          ); 
      ASM.CS2( sub,b  ,  ASM.i(32),ASM.R(RegAlloc.allocation[ai].op[1])        ); 
      ASM.Label(label); 
   | 96 : 
  EmitNtBool(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 96/1654 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' BoolVal ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.Label(e^.attr^.BoolVal.trueLabel); 
      ASM.CS2( mov,b  ,  ASM.i(1),ASM.R(RegAlloc.allocation[ai].reg)         ); 
      ASM.C1 ( jmp    ,  ASM.L(LAB.New(label)) );
      ASM.Label(e^.attr^.BoolVal.falseLabel); 
      ASM.CS2( xor,b  ,  ASM.R(RegAlloc.allocation[ai].reg),ASM.R(RegAlloc.allocation[ai].reg)         ); 
      ASM.Label(label); 
   | 89 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
  EmitNtBReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 89/1575 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Mod ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( test,b  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])       ); 
         ASM.C1 ( jle     ,  ASM.L(LAB.DivFault)   );
      END;
      ASM.C0    ( cbw                          ); 
      ASM.CS1   ( idiv,b  ,  ASM.R(RegAlloc.allocation[ai].op[2])             ); 
      ASM.CS2   ( test,b  ,  ASM.R(ah),ASM.R(ah)       ); 
      ASM.C1    ( jge     ,  ASM.L(LAB.New(label)) );
      ASM.CS2   ( add,b   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(ah)       );
      ASM.Label(label); 
   | 86 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
  EmitNtBReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 86/1529 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Div ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( test,b  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])       ); 
         ASM.C1 ( jle     ,  ASM.L(LAB.DivFault)   );
      END;
      ASM.C0    ( cbw                          ); 
      ASM.CS1   ( idiv,b  ,  ASM.R(RegAlloc.allocation[ai].op[2])             ); 
      ASM.CS2   ( test,b  ,  ASM.R(ah),ASM.R(ah)       ); 
      ASM.C1    ( jge     ,  ASM.L(LAB.New(label)) );
      ASM.CS1   ( dec,b   ,  ASM.R(al)             );
      ASM.Label(label); 
   | 77 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 77/1443 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' FuncResultOf ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 40 : 
  EmitNtAMemAImm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 40/1113 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' AMemAImm ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,b  ,  ASM.Operand(AT0.AMemAImm.oper),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 4 : 
  EmitNtReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 4/990 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBReg],1);
          InOut.WriteString (' Reg ->   BReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrBReg (resAttributes);
       InOut.WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
(*<<<<<<<<<<<<<<<
      WITH RegAlloc.allocation[ai] DO 
>>>>>>>>>>>>>>>*)
         IF RegAlloc.allocation[ai].spilllocation#0 THEN 
            Spill (reg, RegAlloc.allocation[ai].spilllocation);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Spill Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                InOut.WriteInt (RegAlloc.allocation[ai].spilllocation,1);
                InOut.WriteLn;
            END;
         ELSE 
            LR (RegAlloc.allocation[ai].regmove, RegAlloc.allocation[ai].reg);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Copy Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                IR.PrintRegister (RegAlloc.allocation[ai].regmove);
                InOut.WriteLn;
            END;
         END;   
   END;                                           (* -- he 08/91 *)
END EmitNtBReg;

PROCEDURE EmitNtWReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntWReg] OF 
   | 277 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 277/3130 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 276 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 276/3129 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 275 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 275/3128 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 274 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 274/3127 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 273 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 273/3126 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 272 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 272/3125 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 271 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 271/3123 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( xor,b  ,  ASM.R(dh),ASM.R(dh)      ); 
   | 270 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 270/3122 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( xor,b  ,  ASM.R(ch),ASM.R(ch)      ); 
   | 269 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 269/3121 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( xor,b  ,  ASM.R(bh),ASM.R(bh)      ); 
   | 268 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 268/3120 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( xor,b  ,  ASM.R(ah),ASM.R(ah)      ); 
   | 252 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 252/3089 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C0( cbw ); 
   | 248 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 248/3057 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Retype2Data ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[1]^.attr^.Addr2Retype.srcLen=1 THEN
         ASM.C2 ( movzbw  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
      ELSE 
         ASM.CS2( mov,w   ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
      END; 
   | 245 : 
  EmitNtReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 245/3049 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Retype2Data ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.RegCopy(RegAlloc.allocation[ai].op[1],RegAlloc.allocation[ai].reg); 
   | 220 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 220/2726 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Mod ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.gcg^.Constant.val=1 THEN 
         ASM.CS2( xor,w   ,  ASM.R(dx),ASM.R(dx)       ); 
      ELSIF ADR.IntLog2(e^.son[2]^.gcg^.Constant.val,shift) THEN
         ASM.CS2( mov,w   ,  ASM.R(ax),ASM.R(dx)       ); 
         ASM.CS2( and,w   ,  ASM.i(e^.son[2]^.gcg^.Constant.val-1),ASM.R(dx) ); 
      ELSE 
         ASM.CS2( mov,w   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].scr[1])  ); 
         ASM.C0 ( cwd                          ); 
         ASM.CS1( idiv,w  ,  ASM.R(RegAlloc.allocation[ai].scr[1])            ); 
         ASM.CS2( test,w  ,  ASM.R(dx),ASM.R(dx)       ); 
         ASM.C1 ( jge     ,  ASM.L(LAB.New(label)) );
         ASM.CS2( add,w   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(dx)   );
         ASM.Label(label); 
      END; 
   | 217 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 217/2669 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Div ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.gcg^.Constant.val=1 THEN 
               (* nop                          *)
      ELSIF ADR.IntLog2(e^.son[2]^.gcg^.Constant.val,shift) THEN
         ASM.CS2( sar,w   ,  ASM.i(shift),ASM.R(RegAlloc.allocation[ai].op[1])    ); 
      ELSE 
         ASM.CS2( mov,w   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].scr[1])  ); 
         ASM.C0 ( cwd                          ); 
         ASM.CS1( idiv,w  ,  ASM.R(RegAlloc.allocation[ai].scr[1])            ); 
         ASM.CS2( test,w  ,  ASM.R(dx),ASM.R(dx)       ); 
         ASM.C1 ( jge     ,  ASM.L(LAB.New(label)) );
         ASM.CS1( dec,b   ,  ASM.R(ax)             );
         ASM.Label(label);
      END; 
   | 178 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 178/2277 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,b   ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].op[1],w]),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 177 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 177/2276 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 176 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 176/2275 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Card2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2 ( movzbw  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].reg)                    ); 
   | 169 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 169/2251 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 168 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 168/2250 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 167 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 167/2249 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 166 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 166/2248 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 165 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 165/2247 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 164 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 164/2246 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 163 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 163/2242 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 162 : 
  EmitNtAMemAReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 162/2235 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Int2Integer ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2( movsbw  ,  ASM.Operand(AT0.AMemAReg.oper),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 133 : 
  EmitNtRetyp(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 133/2092 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Retype2Data ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,w  ,  ASM.oB(e^.son[1]^.gcg^.Retyp.tmpOfs,ebp),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 90 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
  EmitNtWReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 90/1588 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Mod ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( test,w  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])       ); 
         ASM.C1 ( jle     ,  ASM.L(LAB.DivFault)   );
      END;
      ASM.C0    ( cwd                          ); 
      ASM.CS1   ( idiv,w  ,  ASM.R(RegAlloc.allocation[ai].op[2])             ); 
      ASM.CS2   ( test,w  ,  ASM.R(dx),ASM.R(dx)       ); 
      ASM.C1    ( jge     ,  ASM.L(LAB.New(label)) );
      ASM.CS2   ( add,w   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(dx)       );
      ASM.Label(label); 
   | 87 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
  EmitNtWReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 87/1544 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Div ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( test,w  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])       ); 
         ASM.C1 ( jle     ,  ASM.L(LAB.DivFault)   );
      END;
      ASM.C0    ( cwd                          ); 
      ASM.CS1   ( idiv,w  ,  ASM.R(RegAlloc.allocation[ai].op[2])             ); 
      ASM.CS2   ( test,w  ,  ASM.R(dx),ASM.R(dx)       ); 
      ASM.C1    ( jge     ,  ASM.L(LAB.New(label)) );
      ASM.CS1   ( dec,w   ,  ASM.R(ax)             );
      ASM.Label(label); 
   | 78 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 78/1447 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' FuncResultOf ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 41 : 
  EmitNtAMemAImm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 41/1118 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' AMemAImm ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,w  ,  ASM.Operand(AT0.AMemAImm.oper),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 5 : 
  EmitNtReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 5/991 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntWReg],1);
          InOut.WriteString (' Reg ->   WReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrWReg (resAttributes);
       InOut.WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
(*<<<<<<<<<<<<<<<
      WITH RegAlloc.allocation[ai] DO 
>>>>>>>>>>>>>>>*)
         IF RegAlloc.allocation[ai].spilllocation#0 THEN 
            Spill (reg, RegAlloc.allocation[ai].spilllocation);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Spill Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                InOut.WriteInt (RegAlloc.allocation[ai].spilllocation,1);
                InOut.WriteLn;
            END;
         ELSE 
            LR (RegAlloc.allocation[ai].regmove, reg);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Copy Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                IR.PrintRegister (RegAlloc.allocation[ai].regmove);
                InOut.WriteLn;
            END;
         END;   
   END;                                           (* -- he 08/91 *)
END EmitNtWReg;

PROCEDURE EmitNtLReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;
    AT3   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntLReg] OF 
   | 338 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 338/3517 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Entier ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( sub,l    ,  ASM.i(4),ASM.R(esp) );
      NDP.CS1( fistp,l  ,  ASM.B(esp)      ); 
      ASM.C1 ( popl     ,  ASM.R(RegAlloc.allocation[ai].reg)        ); 
   | 320 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtLReg(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
  EmitNtConstant(e^.son[2]^.son[2]^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 320/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[2],RegAlloc.allocation[ai].op[3],e^.son[2]^.son[2]^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 319 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
  EmitNtLReg(e^.son[2]^.son[2]^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 319/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[2],RegAlloc.allocation[ai].op[4],e^.son[2]^.son[2]^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 318 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[1]^.son[2],nest+1,AT2 ); 
  EmitNtLReg(e^.son[2]^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 318/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[4],RegAlloc.allocation[ai].op[2],e^.son[2]^.son[1]^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 317 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtLReg(e^.son[2]^.son[1]^.son[2],nest+1,AT2 ); 
  EmitNtLReg(e^.son[2]^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 317/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[4],RegAlloc.allocation[ai].op[3],e^.son[2]^.son[1]^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 316 : 
  EmitNtLReg(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[1]^.son[2]^.son[2],nest+1,AT2 ); 
  EmitNtConstant(e^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 316/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[1],RegAlloc.allocation[ai].op[2],e^.son[1]^.son[2]^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 315 : 
  EmitNtLReg(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[2]^.son[2],nest+1,AT2 ); 
  EmitNtConstant(e^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 315/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[1],RegAlloc.allocation[ai].op[3],e^.son[1]^.son[2]^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 314 : 
  EmitNtLReg(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT2 ); 
  EmitNtConstant(e^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 314/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[3],RegAlloc.allocation[ai].op[1],e^.son[1]^.son[1]^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 313 : 
  EmitNtConstant(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT2 ); 
  EmitNtConstant(e^.son[2],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 313/3382 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[3],RegAlloc.allocation[ai].op[2],e^.son[1]^.son[1]^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 312 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 312/3372 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[2],RegAlloc.allocation[ai].op[2],e^.son[2]^.son[2]^.gcg^.Constant.val-1),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 311 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtLReg(e^.son[2]^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 311/3372 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[3],RegAlloc.allocation[ai].op[3],e^.son[2]^.son[1]^.gcg^.Constant.val-1),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 310 : 
  EmitNtLReg(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 310/3372 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[1],RegAlloc.allocation[ai].op[1],e^.son[1]^.son[2]^.gcg^.Constant.val-1),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 309 : 
  EmitNtConstant(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 309/3372 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oBIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[2],RegAlloc.allocation[ai].op[2],e^.son[1]^.son[1]^.gcg^.Constant.val-1),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 308 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 308/3362 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[2],e^.son[2]^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 307 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtLReg(e^.son[2]^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 307/3362 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oIf(e^.son[1]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[3],e^.son[2]^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 306 : 
  EmitNtLReg(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 306/3362 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[1],e^.son[1]^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 305 : 
  EmitNtConstant(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 305/3362 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SymDyOper ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.oIf(e^.son[2]^.gcg^.Constant.val,RegAlloc.allocation[ai].op[2],e^.son[1]^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 290 : 
  EmitNtLReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 290/3185 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' OpenIndexStart ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 289 : 
  EmitNtMemory(e^.son[1]^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[1]^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 289/3164 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' NilCheck ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2   ( mov,l   ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].op[2])                         ); 
      IF ARG.OptionNilChecking THEN 
         ASM.CS2( test,l  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])                               ); 
         ASM.C1 ( jz      ,  ASM.L(LAB.NilFault)                         ); 
      END;
      ASM.CS2   ( mov,l   ,  ASM.oB(-4,RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[3])                         ); 
      ASM.CS2   ( cmp,l   ,  ASM.iL(e^.son[1]^.son[1]^.son[1]^.attr^.PointerGuard.typeLabel),ASM.oB(e^.son[1]^.son[1]^.son[1]^.attr^.PointerGuard.ttableElemOfs,RegAlloc.allocation[ai].op[3]) );
      ASM.C1    ( jz      ,  ASM.L(LAB.New(label1))                      );
      ASM.C1    ( pushl   ,  ASM.oL(-12,e^.son[1]^.son[1]^.son[1]^.attr^.PointerGuard.typeLabel)                     );
      ASM.C1    ( pushl   ,  ASM.oB(-12,RegAlloc.allocation[ai].op[3])                             );
      ASM.C1    ( jmp     ,  ASM.L(LAB.GuardFault)                       ); 
      ASM.Label(label1); 
   | 288 : 
  EmitNtMemory(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 288/3145 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' ContentOf ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2   ( mov,l   ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].op[2])                         ); 
      IF ARG.OptionNilChecking THEN 
         ASM.CS2( test,l  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])                               ); 
         ASM.C1 ( jz      ,  ASM.L(LAB.NilFault)                         ); 
      END;
      ASM.CS2   ( mov,l   ,  ASM.oB(-4,RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[3])                         ); 
      ASM.CS2   ( cmp,l   ,  ASM.iL(e^.son[1]^.son[1]^.attr^.PointerGuard.typeLabel),ASM.oB(e^.son[1]^.son[1]^.attr^.PointerGuard.ttableElemOfs,RegAlloc.allocation[ai].op[3]) );
      ASM.C1    ( jz      ,  ASM.L(LAB.New(label1))                      );
      ASM.C1    ( pushl   ,  ASM.oL(-12,e^.son[1]^.son[1]^.attr^.PointerGuard.typeLabel)                     );
      ASM.C1    ( pushl   ,  ASM.oB(-12,RegAlloc.allocation[ai].op[3])                             );
      ASM.C1    ( jmp     ,  ASM.L(LAB.GuardFault)                       ); 
      ASM.Label(label1); 
   | 287 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 287/3142 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFFFH),ASM.R(edi) ); 
   | 286 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 286/3141 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFFFH),ASM.R(esi) ); 
   | 285 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 285/3140 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFFFH),ASM.R(edx) ); 
   | 284 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 284/3139 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFFFH),ASM.R(ecx) ); 
   | 283 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 283/3138 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFFFH),ASM.R(ebx) ); 
   | 282 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 282/3137 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFFFH),ASM.R(eax) ); 
   | 281 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 281/3135 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(edx)   ); 
   | 280 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 280/3134 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(ecx)   ); 
   | 279 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 279/3133 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(ebx)   ); 
   | 278 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 278/3132 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(eax)   ); 
   | 258 : 
  EmitNtBReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 258/3104 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 257 : 
  EmitNtBReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 257/3103 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 256 : 
  EmitNtBReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 256/3102 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 255 : 
  EmitNtBReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 255/3101 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.x(0FFH),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 254 : 
  EmitNtBReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 254/3097 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2( movsbl  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 253 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 253/3093 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C0( cwde ); 
   | 249 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 249/3065 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Retype2Data ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[1]^.attr^.Addr2Retype.srcLen=1 THEN
         ASM.C2 ( movzbl  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
      ELSIF e^.son[1]^.attr^.Addr2Retype.srcLen=2 THEN
         ASM.C2 ( movzwl  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
      ELSIF e^.son[1]^.attr^.Addr2Retype.srcLen=3 THEN
         ASM.CS2( mov,l   ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
         ASM.CS2( and,l   ,  ASM.x(0FFFFFFH),ASM.R(RegAlloc.allocation[ai].reg)  ); 
      ELSE 
         ASM.CS2( mov,l   ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
      END; 
   | 246 : 
  EmitNtReg(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 246/3050 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Retype2Data ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.RegCopy(RegAlloc.allocation[ai].op[1],RegAlloc.allocation[ai].reg); 
   | 240 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 240/3003 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Ash ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ABS(e^.son[2]^.attr^.LongintConst.val)<ASM.BitSizeTab[ASM.RegSizeTab[RegAlloc.allocation[ai].op[1]]] THEN 
         IF e^.son[2]^.attr^.LongintConst.val>0 THEN 
            ASM.CS2( shl,l  ,  ASM.i(e^.son[2]^.attr^.LongintConst.val),ASM.R(RegAlloc.allocation[ai].op[1])  );
         ELSIF e^.son[2]^.attr^.LongintConst.val<0 THEN
            ASM.CS2( sar,l  ,  ASM.i(-e^.son[2]^.attr^.LongintConst.val),ASM.R(RegAlloc.allocation[ai].op[1]) );
         END;
      ELSE 
         IF e^.son[2]^.attr^.LongintConst.val<0 THEN
            ASM.CS2( mov,l  ,  ASM.i(-1),ASM.R(RegAlloc.allocation[ai].op[1])      );
         ELSE
            ASM.CS2( xor,l  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])      );
         END;
      END; 
   | 227 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 227/2869 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SetExtendByRange ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])                        );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault)                );
      END;                                                     
      IF e^.son[3]^.gcg^.Constant.val=31 THEN                                        
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[2],4),ASM.R(RegAlloc.allocation[ai].op[2])    ); 
         ASM.CS1( not,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])                              ); 
      ELSIF e^.son[3]^.gcg^.Constant.val=0 THEN
         ASM.CS2( test,l ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])                        );
         ASM.C1 ( jnz    ,  ASM.L(LAB.New(label))                  );
         ASM.CS2( mov,l  ,  ASM.x(1),ASM.R(RegAlloc.allocation[ai].op[2])                         );
         ASM.Label(label);
      ELSE 
         ASM.CS2( cmp,l  ,  ASM.i(e^.son[3]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[2])                    );
         ASM.C1 ( jg     ,  ASM.L(LAB.New(label))                  );
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[2],4),ASM.R(RegAlloc.allocation[ai].op[2])    ); 
         ASM.CS1( not,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])                              ); 
         ASM.CS2( and,l  ,  ASM.x(ADR.BitRangeTab[1+e^.son[3]^.gcg^.Constant.val]),ASM.R(RegAlloc.allocation[ai].op[2]) ); 
         ASM.Label(label);
      END; 
      IF e^.son[1]^.gcg^.Constant.val#0 THEN 
         ASM.CS2( or,l   ,  ASM.x(e^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[2])                      ); 
      END; 
   | 226 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 226/2842 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SetExtendByRange ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[3])                         );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault)                 );
      END;                                                      
      IF e^.son[2]^.gcg^.Constant.val=0 THEN                                          
         ASM.CS1( inc,l  ,  ASM.R(RegAlloc.allocation[ai].op[3])                               ); 
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[3],4),ASM.R(RegAlloc.allocation[ai].op[3])     ); 
      ELSIF e^.son[2]^.gcg^.Constant.val=31 THEN
         ASM.CS2( cmp,l  ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[3])                     );
         ASM.C1 ( jl     ,  ASM.L(LAB.New(label))                   );
         ASM.CS2( mov,l  ,  ASM.x(ADR.InvBitRangeTab[e^.son[2]^.gcg^.Constant.val]),ASM.R(RegAlloc.allocation[ai].op[3]) );
         ASM.Label(label);
      ELSE
         ASM.CS2( cmp,l  ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[3])                     );
         ASM.C1 ( jl     ,  ASM.L(LAB.New(label))                   );
         ASM.CS1( inc,l  ,  ASM.R(RegAlloc.allocation[ai].op[3])                               ); 
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[3],4),ASM.R(RegAlloc.allocation[ai].op[3])     ); 
         ASM.CS2( and,l  ,  ASM.x(ADR.InvBitRangeTab[e^.son[2]^.gcg^.Constant.val]),ASM.R(RegAlloc.allocation[ai].op[3]) );
         ASM.Label(label);
      END;
      IF e^.son[1]^.gcg^.Constant.val#0 THEN
         ASM.CS2( or,l   ,  ASM.x(e^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[3])                      ); 
      END; 
   | 225 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 225/2822 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SetExtendByRange ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])                     );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault)             );
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[3])                     );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault)             );
      END;
      ASM.CS2   ( cmp,l  ,  ASM.R(RegAlloc.allocation[ai].op[3]),ASM.R(RegAlloc.allocation[ai].op[2])                     );
      ASM.C1    ( jg     ,  ASM.L(LAB.New(label))               );
      ASM.CS2   ( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[2],4),ASM.R(RegAlloc.allocation[ai].op[2]) ); 
      ASM.CS1   ( not,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])                           ); 
      ASM.CS1   ( inc,l  ,  ASM.R(RegAlloc.allocation[ai].op[3])                           ); 
      ASM.CS2   ( and,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[3],4),ASM.R(RegAlloc.allocation[ai].op[2]) ); 
      IF e^.son[1]^.gcg^.Constant.val#0 THEN 
         ASM.CS2( or,l   ,  ASM.x(e^.son[1]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[2])                  ); 
      END;
      ASM.Label(label); 
   | 224 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 224/2795 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SetExtendByRange ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])                        );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault)                );
      END;                                                         
      IF e^.son[3]^.gcg^.Constant.val=31 THEN                                            
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[2],4),ASM.R(RegAlloc.allocation[ai].op[2])    ); 
         ASM.CS1( not,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])                              ); 
         ASM.CS2( or,l   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[1])                         ); 
      ELSIF e^.son[3]^.gcg^.Constant.val=0 THEN
         ASM.CS2( test,l ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])                        );
         ASM.C1 ( jnz    ,  ASM.L(LAB.New(label))                  );
         ASM.CS2( or,l   ,  ASM.x(1),ASM.R(RegAlloc.allocation[ai].op[1])                          ); 
         ASM.Label(label);
      ELSE 
         ASM.CS2( cmp,l  ,  ASM.i(e^.son[3]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[2])                    );
         ASM.C1 ( jg     ,  ASM.L(LAB.New(label))                  );
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[2],4),ASM.R(RegAlloc.allocation[ai].op[2])    ); 
         ASM.CS1( not,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])                              ); 
         ASM.CS2( and,l  ,  ASM.x(ADR.BitRangeTab[1+e^.son[3]^.gcg^.Constant.val]),ASM.R(RegAlloc.allocation[ai].op[2]) ); 
         ASM.CS2( or,l   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[1])                         ); 
         ASM.Label(label);
      END; 
   | 223 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 223/2769 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SetExtendByRange ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[3])                         );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault)                 );
      END;                                                          
      IF e^.son[2]^.gcg^.Constant.val=0 THEN                                              
         ASM.CS1( inc,l  ,  ASM.R(RegAlloc.allocation[ai].op[3])                               ); 
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[3],4),ASM.R(RegAlloc.allocation[ai].op[3])     ); 
         ASM.CS2( or,l   ,  ASM.R(RegAlloc.allocation[ai].op[3]),ASM.R(RegAlloc.allocation[ai].op[1])                          ); 
      ELSIF e^.son[2]^.gcg^.Constant.val=31 THEN
         ASM.CS2( cmp,l  ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[3])                     );
         ASM.C1 ( jl     ,  ASM.L(LAB.New(label))                   );
         ASM.CS2( or,l   ,  ASM.x(ADR.InvBitRangeTab[e^.son[2]^.gcg^.Constant.val]),ASM.R(RegAlloc.allocation[ai].op[1])  ); 
         ASM.Label(label);
      ELSE 
         ASM.CS2( cmp,l  ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].op[3])                     );
         ASM.C1 ( jl     ,  ASM.L(LAB.New(label))                   );
         ASM.CS1( inc,l  ,  ASM.R(RegAlloc.allocation[ai].op[3])                               ); 
         ASM.CS2( mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[3],4),ASM.R(RegAlloc.allocation[ai].op[3])     ); 
         ASM.CS2( and,l  ,  ASM.x(ADR.InvBitRangeTab[e^.son[2]^.gcg^.Constant.val]),ASM.R(RegAlloc.allocation[ai].op[3]) );
         ASM.CS2( or,l   ,  ASM.R(RegAlloc.allocation[ai].op[3]),ASM.R(RegAlloc.allocation[ai].op[1])                          ); 
         ASM.Label(label);
      END; 
   | 222 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 222/2763 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Difference ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( and,l  ,  ASM.i(SYSTEM.VAL(LONGINT,SYSTEM.VAL(SET,-1)-SYSTEM.VAL(SET,e^.son[2]^.gcg^.Constant.val))),ASM.R(RegAlloc.allocation[ai].op[1]) ); 
   | 221 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 221/2744 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Mod ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.gcg^.Constant.val=1 THEN 
         ASM.CS2( xor,l   ,  ASM.R(edx),ASM.R(edx)      ); 
      ELSIF ADR.IntLog2(e^.son[2]^.gcg^.Constant.val,shift) THEN
         ASM.CS2( mov,l   ,  ASM.R(eax),ASM.R(edx)      ); 
         ASM.CS2( and,l   ,  ASM.i(e^.son[2]^.gcg^.Constant.val-1),ASM.R(edx) ); 
      ELSE 
         ASM.CS2( mov,l   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].scr[1])   ); 
         ASM.C0 ( cdq                           ); 
         ASM.CS1( idiv,l  ,  ASM.R(RegAlloc.allocation[ai].scr[1])             ); 
         ASM.CS2( test,l  ,  ASM.R(edx),ASM.R(edx)      ); 
         ASM.C1 ( jge     ,  ASM.L(LAB.New(label))  );
         ASM.CS2( add,l   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(edx)   );
         ASM.Label(label); 
      END; 
   | 218 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 218/2688 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Div ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.gcg^.Constant.val=1 THEN 
               (* nop                          *)
      ELSIF ADR.IntLog2(e^.son[2]^.gcg^.Constant.val,shift) THEN
         ASM.CS2( sar,l   ,  ASM.i(shift),ASM.R(RegAlloc.allocation[ai].op[1])    ); 
      ELSE 
         ASM.CS2( mov,l   ,  ASM.i(e^.son[2]^.gcg^.Constant.val),ASM.R(RegAlloc.allocation[ai].scr[1])  ); 
         ASM.C0 ( cdq                          ); 
         ASM.CS1( idiv,l  ,  ASM.R(RegAlloc.allocation[ai].scr[1])            ); 
         ASM.CS2( test,l  ,  ASM.R(edx),ASM.R(edx)     ); 
         ASM.C1 ( jge     ,  ASM.L(LAB.New(label)) );
         ASM.CS1( dec,l   ,  ASM.R(eax)            );
         ASM.Label(label);
      END; 
   | 215 : 
  EmitNtMemory(e^.son[1]^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 215/2640 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' AddressOf ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 214 : 
  EmitNtMemory(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 214/2632 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' AddressOf ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 206 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 206/2478 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' ConjureRegister ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 200 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 200/2409 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' OpenIndexPush ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionIndexChecking THEN 
         ASM.CS2( cmp,l   ,  ASM.oB(e^.attr^.OpenIndexPush.lenOfs,RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[2]) );
         ASM.C1 ( jae     ,  ASM.L(LAB.IndexFault)                     );
      END;
      ASM.C1    ( pushl   ,  ASM.R(RegAlloc.allocation[ai].op[2])                             ); 
   | 199 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 199/2405 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' OpenIndexStart ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 198 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 198/2401 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' OpenIndexStartLocal ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,l  ,  ASM.R(ebp),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 194 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 194/2356 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' NilCheck ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,l  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])       ); 
      ASM.C1 ( jz      ,  ASM.L(LAB.NilFault) ); 
   | 193 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 193/2350 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' IndexCheck ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,l  ,  ASM.i(e^.attr^.IndexCheck.len),ASM.R(RegAlloc.allocation[ai].op[1])    ); 
      ASM.C1 ( jae    ,  ASM.L(LAB.IndexFault) ); 
   | 191 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 191/2322 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' PointerGuard ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2   ( mov,l   ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].op[2])                           ); 
      IF ARG.OptionNilChecking THEN 
         ASM.CS2( test,l  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])                                 ); 
         ASM.C1 ( jz      ,  ASM.L(LAB.NilFault)                           ); 
      END;
      ASM.CS2   ( mov,l   ,  ASM.oB(-4,RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[3])                           ); 
      ASM.CS2   ( cmp,l   ,  ASM.iL(e^.attr^.PointerGuard.typeLabel),ASM.oB(e^.attr^.PointerGuard.ttableElemOfs,RegAlloc.allocation[ai].op[3]) );
      ASM.C1    ( jz      ,  ASM.L(LAB.New(label1))                        );
      ASM.C1    ( pushl   ,  ASM.oL(-12,e^.attr^.PointerGuard.typeLabel)                      );
      ASM.C1    ( pushl   ,  ASM.oB(-12,RegAlloc.allocation[ai].op[3])                               );
      ASM.C1    ( jmp     ,  ASM.L(LAB.GuardFault)                         ); 
      ASM.Label(label1); 
   | 181 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 181/2283 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 180 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 180/2282 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2 ( movzwl  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].reg)                    ); 
   | 179 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 179/2281 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Card2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2 ( movzbl  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].reg)                    ); 
   | 172 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 172/2264 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 171 : 
  EmitNtAMemAReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 171/2260 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2( movswl  ,  ASM.Operand(AT0.AMemAReg.oper),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 170 : 
  EmitNtAMemAReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 170/2256 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Int2Longint ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2( movsbl  ,  ASM.Operand(AT0.AMemAReg.oper),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 159 : 
  EmitNtBregIreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 159/2213 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' BregIreg ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.Loc(AT0.BregIreg.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 134 : 
  EmitNtRetyp(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 134/2097 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Retype2Data ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,l  ,  ASM.oB(e^.son[1]^.gcg^.Retyp.tmpOfs,ebp),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 123 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 123/1872 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' LenCheck ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,l  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])       );
      ASM.C1 ( jle     ,  ASM.L(LAB.LenFault) ); 
   | 115 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 115/1790 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Ash ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,ASM.RegSizeTab[RegAlloc.allocation[ai].op[2]]  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])        ); 
      ASM.C1 ( js                       ,  ASM.L(LAB.New(label1)) );
      ASM.CS2( shl,l                    ,  ASM.R(cl),ASM.R(RegAlloc.allocation[ai].op[1])        );
      ASM.C1 ( jmp                      ,  ASM.L(LAB.New(label2)) );
      ASM.Label(label1);
      ASM.CS1( neg,ASM.RegSizeTab[RegAlloc.allocation[ai].op[2]]   ,  ASM.R(RegAlloc.allocation[ai].op[2])              ); 
      ASM.CS2( sar,l                    ,  ASM.R(cl),ASM.R(RegAlloc.allocation[ai].op[1])        );
      ASM.Label(label2); 
   | 94 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 94/1630 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SetExtendByRange ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2(        cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])                      );
         ASM.C1 (        ja     ,  ASM.L(LAB.ElementFault)              );
         ASM.CS2(        cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[3])                      );
         ASM.C1 (        ja     ,  ASM.L(LAB.ElementFault)              );
      END;	         					    
      ASM.CS2   (        cmp,l  ,  ASM.R(RegAlloc.allocation[ai].op[3]),ASM.R(RegAlloc.allocation[ai].op[2])                      );
      ASM.C1    (        jg     ,  ASM.L(LAB.New(label))                );
      ASM.CS2   (        mov,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[2],4),ASM.R(RegAlloc.allocation[ai].op[2])  ); 
      ASM.CS1   (        not,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])                            ); 
      ASM.CS1   (        inc,l  ,  ASM.R(RegAlloc.allocation[ai].op[3])                            ); 
      ASM.CS2   (        and,l  ,  ASM.LIf(LAB.BitRangeTab,RegAlloc.allocation[ai].op[3],4),ASM.R(RegAlloc.allocation[ai].op[2])  ); 
      ASM.CS2   (        or,l   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[1])                       ); 
      ASM.Label (  label                                            ); 
   | 93 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 93/1622 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' SetExtendByElem ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])          );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault) );
      END;
      ASM.CS2   ( bts,l  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[1])           ); 
   | 92 : 
  EmitNtAMemARegAImm(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 92/1615 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Difference ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS1( not,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])                  );
      ASM.CS2( and,l  ,  ASM.Operand(AT0.AMemARegAImm.oper),ASM.R(RegAlloc.allocation[ai].op[2]) ); 
   | 91 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 91/1601 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Mod ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( test,l  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])       ); 
         ASM.C1 ( jle     ,  ASM.L(LAB.DivFault)   );
      END;
      ASM.C0    ( cdq ); 
      ASM.CS1   ( idiv,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])             ); 
      ASM.CS2   ( test,l  ,  ASM.R(edx),ASM.R(edx)     ); 
      ASM.C1    ( jge     ,  ASM.L(LAB.New(label)) );
      ASM.CS2   ( add,l   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(edx)      );
      ASM.Label(label); 
   | 88 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 88/1559 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Div ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( test,l  ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])       ); 
         ASM.C1 ( jle     ,  ASM.L(LAB.DivFault)   );
      END;
      ASM.C0    ( cdq ); 
      ASM.CS1   ( idiv,l  ,  ASM.R(RegAlloc.allocation[ai].op[2])             ); 
      ASM.CS2   ( test,l  ,  ASM.R(edx),ASM.R(edx)     ); 
      ASM.C1    ( jge     ,  ASM.L(LAB.New(label)) );
      ASM.CS1   ( dec,l   ,  ASM.R(eax)            );
      ASM.Label(label); 
   | 79 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 79/1451 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' FuncResultOf ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 51 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 51/1208 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Implicify ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 INC(AT0.Memory.loc.ofs,e^.attr^.Implicify.lenOfs);
      ASM.C1    ( pushl  ,  ASM.Loc(AT0.Memory.loc)      ); 
      DEC(AT0.Memory.loc.ofs,e^.attr^.Implicify.lenOfs);

      INC(AT0.Memory.loc.ofs,e^.attr^.Implicify.objOfs);
      IF e^.attr^.Implicify.isStackObject THEN
         ASM.CS2( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) );
      ELSE
         ASM.CS2( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) );
      END; 
   | 50 : 
  EmitNtReducedStack(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 50/1197 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' ImplicifyOpenIndexed ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1    ( pushl  ,  ASM.oB(e^.attr^.ImplicifyOpenIndexed.lenOfs,AT0.ReducedStack.headerBaseReg)                         );

      IF e^.attr^.ImplicifyOpenIndexed.isStackObject THEN
         ASM.CS2( mov,l  ,  ASM.oB(e^.attr^.ImplicifyOpenIndexed.objOfs,AT0.ReducedStack.headerBaseReg),ASM.R(RegAlloc.allocation[ai].reg)                    );
         ASM.CS2( add,l  ,  ASM.R(AT0.ReducedStack.displacementReg),ASM.R(RegAlloc.allocation[ai].reg)                             ); 
      ELSE
         ASM.CS2( lea,l  ,  ASM.oBI(e^.attr^.ImplicifyOpenIndexed.objOfs,AT0.ReducedStack.headerBaseReg,AT0.ReducedStack.displacementReg),ASM.R(RegAlloc.allocation[ai].reg) );
      END; 
   | 49 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 49/1192 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' ImplicifyConst ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1 ( pushl  ,  ASM.i(e^.attr^.ImplicifyConst.len)            );
      ASM.CS2( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 43 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 43/1129 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' AddressOf ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 42 : 
  EmitNtAMemAImm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 42/1123 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' AMemAImm ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,l  ,  ASM.Operand(AT0.AMemAImm.oper),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 37 : 
  EmitNtBregIreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 37/1095 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' BregIreg ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( lea,l  ,  ASM.Loc(AT0.BregIreg.loc),ASM.R(RegAlloc.allocation[ai].reg) ); 
   | 6 : 
  EmitNtReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 6/992 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLReg],1);
          InOut.WriteString (' Reg ->   LReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrLReg (resAttributes);
       InOut.WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
(*<<<<<<<<<<<<<<<
      WITH RegAlloc.allocation[ai]. DO 
>>>>>>>>>>>>>>>*)
         IF RegAlloc.allocation[ai].spilllocation#0 THEN 
            Spill (reg, RegAlloc.allocation[ai].spilllocation);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Spill Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                InOut.WriteInt (RegAlloc.allocation[ai].spilllocation,1);
                InOut.WriteLn;
            END;
         ELSE 
            LR (RegAlloc.allocation[ai].regmove, reg);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Copy Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                IR.PrintRegister (RegAlloc.allocation[ai].regmove);
                InOut.WriteLn;
            END;
         END;   
   END;                                           (* -- he 08/91 *)
END EmitNtLReg;

PROCEDURE EmitNtReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntReg] OF 
   | 243 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 243/3032 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' ShiftOrRotate ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF ASMOP.IsRotateOper[e^.attr^.ShiftOrRotate.code] OR (ABS(e^.son[2]^.attr^.LongintConst.val)<ASM.BitSizeTab[ASM.RegSizeTab[RegAlloc.allocation[ai].op[1]]]) THEN 
         IF e^.son[2]^.attr^.LongintConst.val>0 THEN 
            ASM.CS2( e^.attr^.ShiftOrRotate.code,ASM.RegSizeTab[RegAlloc.allocation[ai].op[1]]  ,  ASM.i(e^.son[2]^.attr^.LongintConst.val),ASM.R(RegAlloc.allocation[ai].op[1])  );
         ELSIF e^.son[2]^.attr^.LongintConst.val<0 THEN
            e^.attr^.ShiftOrRotate.code:=ASMOP.InvDirTab[e^.attr^.ShiftOrRotate.code]; 
            ASM.CS2( e^.attr^.ShiftOrRotate.code,ASM.RegSizeTab[RegAlloc.allocation[ai].op[1]]  ,  ASM.i(-e^.son[2]^.attr^.LongintConst.val),ASM.R(RegAlloc.allocation[ai].op[1]) );
         END;
      ELSE 
         ASM.CS2   ( xor,ASM.RegSizeTab[RegAlloc.allocation[ai].op[1]]      ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])      );
      END; 
   | 197 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 197/2385 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' ShortRangeCheck ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[1]^.gcg^.Reg.size=w THEN 
         ASM.CS2( cmp,w       ,  ASM.i( 127),ASM.R(RegAlloc.allocation[ai].op[1])      ); 
         ASM.C1 ( jg          ,  ASM.L(LAB.ShortFault) );
         ASM.CS2( cmp,w       ,  ASM.i(-128),ASM.R(RegAlloc.allocation[ai].op[1])      ); 
         ASM.C1 ( jl          ,  ASM.L(LAB.ShortFault) );
      ELSE 
         ASM.CS2( cmp,l       ,  ASM.i( 32767),ASM.R(RegAlloc.allocation[ai].op[1])    ); 
         ASM.C1 ( jg          ,  ASM.L(LAB.ShortFault) );
         ASM.CS2( cmp,l       ,  ASM.i(-32768),ASM.R(RegAlloc.allocation[ai].op[1])    ); 
         ASM.C1 ( jl          ,  ASM.L(LAB.ShortFault) );
      END; 
   | 196 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 196/2374 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' ChrRangeCheck ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[1]^.gcg^.Reg.size=b THEN 
         ASM.CS2( cmp,b       ,  ASM.i(7FH),ASM.R(RegAlloc.allocation[ai].op[1])     ); 
      ELSE 
         ASM.CS2( cmp,e^.son[1]^.gcg^.Reg.size  ,  ASM.i(0FFH),ASM.R(RegAlloc.allocation[ai].op[1])    ); 
      END;
      ASM.C1    ( ja          ,  ASM.L(LAB.ChrFault) ); 
   | 195 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 195/2363 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' MinIntCheck ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 CASE e^.son[1]^.gcg^.Reg.size OF
      |b: ASM.CS2( cmp,b  ,  ASM.i(-128),ASM.R(RegAlloc.allocation[ai].op[1])      ); 
      |w: ASM.CS2( cmp,w  ,  ASM.i(-32768),ASM.R(RegAlloc.allocation[ai].op[1])    ); 
      |l: ASM.CS2( cmp,l  ,  ASM.x(80000000H),ASM.R(RegAlloc.allocation[ai].op[1]) ); 
      END;
      ASM.C1     ( jz     ,  ASM.L(e^.attr^.MinIntCheck.faultLabel)  ); 
   | 120 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 120/1835 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' ShiftOrRotate ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,ASM.RegSizeTab[RegAlloc.allocation[ai].op[2]]     ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].op[2])        ); 
      ASM.C1 ( js                          ,  ASM.L(LAB.New(label1)) );
      ASM.CS2( e^.attr^.ShiftOrRotate.code,ASM.RegSizeTab[RegAlloc.allocation[ai].op[1]]  ,  ASM.R(cl),ASM.R(RegAlloc.allocation[ai].op[1])        );
      ASM.C1 ( jmp                         ,  ASM.L(LAB.New(label2)) );
      ASM.Label(label1);
      ASM.CS1( neg,ASM.RegSizeTab[RegAlloc.allocation[ai].op[2]]      ,  ASM.R(RegAlloc.allocation[ai].op[2])              ); 
      e^.attr^.ShiftOrRotate.code:=ASMOP.InvDirTab[e^.attr^.ShiftOrRotate.code]; 
      ASM.CS2( e^.attr^.ShiftOrRotate.code,ASM.RegSizeTab[RegAlloc.allocation[ai].op[1]]  ,  ASM.R(cl),ASM.R(RegAlloc.allocation[ai].op[1])        );
      ASM.Label(label2); 
   | 114 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 114/1781 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' Abs ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,e^.son[1]^.gcg^.Reg.size  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])         ); 
      ASM.C1 ( jge          ,  ASM.L(LAB.New(label)) ); 
      ASM.CS1( neg,e^.son[1]^.gcg^.Reg.size   ,  ASM.R(RegAlloc.allocation[ai].op[1])              ); 
      ASM.Label(label); 
   | 85 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
  EmitNtAMemARegAImm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 85/1522 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' Sub ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( sub,e^.son[1]^.gcg^.Reg.size  ,  ASM.Operand(AT1.AMemARegAImm.oper),ASM.R(RegAlloc.allocation[ai].op[1]) ); 
   | 84 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
  EmitNtAMemARegAImm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 84/1515 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' SymDyOper ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( e^.attr^.SymDyOper.code,e^.son[1]^.gcg^.Reg.size  ,  ASM.Operand(AT1.AMemARegAImm.oper),ASM.R(RegAlloc.allocation[ai].op[1]) ); 
   | 83 : 
  EmitNtAMemARegAImm(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 83/1515 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' SymDyOper ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( e^.attr^.SymDyOper.code,e^.son[2]^.gcg^.Reg.size  ,  ASM.Operand(AT0.AMemARegAImm.oper),ASM.R(RegAlloc.allocation[ai].op[2]) ); 
   | 82 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 82/1508 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' MonOper ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS1( e^.attr^.MonOper.code,e^.son[1]^.gcg^.Reg.size  ,  ASM.R(RegAlloc.allocation[ai].op[1]) ); 
   | 3 : 
  EmitNtLReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 3/988 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' LReg ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 2 : 
  EmitNtWReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 2/987 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' WReg ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 1 : 
  EmitNtBReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 1/986 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReg],1);
          InOut.WriteString (' BReg ->   Reg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrReg (resAttributes);
       InOut.WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
(*<<<<<<<<<<<<<<<
      WITH RegAlloc.allocation[ai] DO 
>>>>>>>>>>>>>>>*)
         IF RegAlloc.allocation[ai].spilllocation#0 THEN 
            Spill (reg, RegAlloc.allocation[ai].spilllocation);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Spill Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                InOut.WriteInt (RegAlloc.allocation[ai].spilllocation,1);
                InOut.WriteLn;
            END;
         ELSE 
            LR (RegAlloc.allocation[ai].regmove, reg);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Copy Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                IR.PrintRegister (RegAlloc.allocation[ai].regmove);
                InOut.WriteLn;
            END;
         END;   
   END;                                           (* -- he 08/91 *)
END EmitNtReg;

PROCEDURE EmitNtFXReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntFXReg] OF 
   | 361 : 
  EmitNtAMem(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 361/3700 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Int2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[1]^.gcg^.AMem.size=b THEN 
         ASM.C2 ( movsbl       ,  ASM.Operand(AT0.AMem.oper),ASM.R(RegAlloc.allocation[ai].scr[1]) ); 
         ASM.C1 ( pushl        ,  ASM.R(RegAlloc.allocation[ai].scr[1])                 ); 
         NDP.CS1( fild,l       ,  ASM.B(esp)                 );
         ASM.CS2( add,l        ,  ASM.i(4),ASM.R(esp)            );
      ELSE 
         NDP.CS1( fild,e^.son[1]^.gcg^.AMem.size  ,  ASM.Operand(AT0.AMem.oper)        );
      END; 
   | 360 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 360/3692 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Int2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C0 ( cbw                    ); 
      ASM.C1 ( pushl   ,  ASM.R(eax)      ); 
      NDP.CS1( fild,w  ,  ASM.B(esp)      );
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp) ); 
   | 355 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 355/3631 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.son[1]^.gcg^.AMem.size=w THEN sz:=s; ELSE sz:=e^.son[2]^.son[1]^.gcg^.AMem.size; END;
      NDP.CS1( ASMOP.IntFloatTab[e^.attr^.FloatDyOper.code],sz  ,  ASM.Operand(AT1.AMem.oper) ); 
   | 354 : 
  EmitNtAMem(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 354/3621 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[1]^.son[1]^.gcg^.AMem.size=w THEN sz:=s; ELSE sz:=e^.son[1]^.son[1]^.gcg^.AMem.size; END;
      NDP.CS1( ASMOP.RevFloatTab[ASMOP.IntFloatTab[e^.attr^.FloatDyOper.code]],sz  ,  ASM.Operand(AT0.AMem.oper) ); 
   | 353 : 
  EmitNtAMem(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 353/3611 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatSymDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[1]^.son[1]^.gcg^.AMem.size=w THEN sz:=s; ELSE sz:=e^.son[1]^.son[1]^.gcg^.AMem.size; END;
      NDP.CS1( ASMOP.IntFloatTab[e^.attr^.FloatSymDyOper.code],sz  ,  ASM.Operand(AT0.AMem.oper) ); 
   | 352 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 352/3611 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatSymDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.son[2]^.son[1]^.gcg^.AMem.size=w THEN sz:=s; ELSE sz:=e^.son[2]^.son[1]^.gcg^.AMem.size; END;
      NDP.CS1( ASMOP.IntFloatTab[e^.attr^.FloatSymDyOper.code],sz  ,  ASM.Operand(AT1.AMem.oper) ); 
   | 351 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 351/3605 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( e^.attr^.FloatDyOper.code,e^.son[2]^.gcg^.AMem.size  ,  ASM.Operand(AT1.AMem.oper) ); 
   | 350 : 
  EmitNtAMem(e^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 350/3600 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( ASMOP.RevFloatTab[e^.attr^.FloatDyOper.code],e^.son[1]^.gcg^.AMem.size  ,  ASM.Operand(AT0.AMem.oper) ); 
   | 349 : 
  EmitNtAMem(e^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 349/3595 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatSymDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( e^.attr^.FloatSymDyOper.code,e^.son[1]^.gcg^.AMem.size  ,  ASM.Operand(AT0.AMem.oper) ); 
   | 348 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 348/3595 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatSymDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( e^.attr^.FloatSymDyOper.code,e^.son[2]^.gcg^.AMem.size  ,  ASM.Operand(AT1.AMem.oper) ); 
   | 346 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 346/3571 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Longreal2Real ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 345 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 345/3568 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Real2Longreal ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 344 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 344/3561 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Card2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].op[1])        ); 
      NDP.CS1( fld,s   ,  ASM.B(esp)      );
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp) ); 
   | 343 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 343/3553 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Card2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2 ( movzwl  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].scr[1]) ); 
      ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])      ); 
      NDP.CS1( fld,s   ,  ASM.B(esp)      );
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp) ); 
   | 342 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 342/3545 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Card2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2 ( movzbl  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].scr[1]) ); 
      ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])      ); 
      NDP.CS1( fld,s   ,  ASM.B(esp)      );
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp) ); 
   | 341 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 341/3538 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Int2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].op[1])                      ); 
      NDP.CS1( fild,l  ,  ASM.B(esp)                    );
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp)               ); 
   | 340 : 
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 340/3532 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Int2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1 ( pushl   ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[ai].op[1],l])   ); 
      NDP.CS1( fild,w  ,  ASM.B(esp)                    );
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp)               ); 
   | 339 : 
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 339/3524 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Int2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C2 ( movsbl  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].scr[1]) ); 
      ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])      ); 
      NDP.CS1( fild,l  ,  ASM.B(esp)      );
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp) ); 
   | 337 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 337/3512 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Abs ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.C0( fabs ); 
   | 332 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
  EmitNtFYReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 332/3456 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.C0( ASMOP.PopFloatTab[e^.attr^.FloatDyOper.code] ); 
   | 331 : 
  EmitNtFYReg(e^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 331/3451 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.C0( ASMOP.RevFloatTab[ASMOP.PopFloatTab[e^.attr^.FloatDyOper.code]] ); 
   | 330 : 
  EmitNtFYReg(e^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 330/3445 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatSymDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.C0( ASMOP.PopFloatTab[e^.attr^.FloatSymDyOper.code] ); 
   | 329 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
  EmitNtFYReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 329/3445 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatSymDyOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.C0( ASMOP.PopFloatTab[e^.attr^.FloatSymDyOper.code] ); 
   | 328 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 328/3440 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' MonOper ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.C0( fchs ); 
   | 327 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 327/3435 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' FloatFuncResultOf ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.SetTop(1); 
   | 324 : 
  EmitNtAMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 324/3418 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' AMem ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( fld,e^.gcg^.AMem.size  ,  ASM.Operand(AT0.AMem.oper) ); 
   | 250 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 250/3079 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Retype2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( fld,ASM.FloatSizeTab[e^.son[1]^.attr^.Addr2Retype.dstLen]  ,  ASM.Loc(AT0.Memory.loc) ); 
   | 135 : 
  EmitNtRetyp(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 135/2102 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFXReg],1);
          InOut.WriteString (' Retype2Float ->   FXReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( fld,ASM.FloatSizeTab[e^.son[1]^.gcg^.Retyp.dstLen]  ,  ASM.oB(e^.son[1]^.gcg^.Retyp.tmpOfs,ebp) ); 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrFXReg (resAttributes);
       InOut.WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
(*<<<<<<<<<<<<<<<
      WITH RegAlloc.allocation[ai] DO 
>>>>>>>>>>>>>>>*)
         IF RegAlloc.allocation[ai].spilllocation#0 THEN 
            Spill (reg, RegAlloc.allocation[ai].spilllocation);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Spill Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                InOut.WriteInt (RegAlloc.allocation[ai].spilllocation,1);
                InOut.WriteLn;
            END;
         ELSE 
            LR (RegAlloc.allocation[ai].regmove, reg);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Copy Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                IR.PrintRegister (RegAlloc.allocation[ai].regmove);
                InOut.WriteLn;
            END;
         END;   
   END;                                           (* -- he 08/91 *)
END EmitNtFXReg;

PROCEDURE EmitNtFYReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntFYReg] OF 
   | 321 : 
  EmitNtFXReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 321/3402 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntFYReg],1);
          InOut.WriteString (' FXReg ->   FYReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CmtLnS('			st -> st(1)'); 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrFYReg (resAttributes);
       InOut.WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ; 
(*<<<<<<<<<<<<<<<
      WITH RegAlloc.allocation[ai] DO 
>>>>>>>>>>>>>>>*)
         IF RegAlloc.allocation[ai].spilllocation#0 THEN 
            Spill (reg, RegAlloc.allocation[ai].spilllocation);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Spill Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                InOut.WriteInt (RegAlloc.allocation[ai].spilllocation,1);
                InOut.WriteLn;
            END;
         ELSE 
            LR (RegAlloc.allocation[ai].regmove, reg);
            IF IR.OptEmitMatch THEN 
                InOut.WriteString (' Copy Register ');
                IR.PrintRegister (reg);
                InOut.WriteString (' into ');
                IR.PrintRegister (RegAlloc.allocation[ai].regmove);
                InOut.WriteLn;
            END;
         END;   
   END;                                           (* -- he 08/91 *)
END EmitNtFYReg;

PROCEDURE EmitNtConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntConstant] OF 
   | 259 : 
  EmitNtConstant(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 259/3106 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' Int2Longint ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 189 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 189/2307 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' SetConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 188 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 188/2304 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' RealConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 187 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 187/2301 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' IntConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 186 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 186/2298 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' LongintConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 185 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 185/2295 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' IntegerConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 184 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 184/2292 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' ShortintConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 183 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 183/2289 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' BooleanConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 182 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 182/2286 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntConstant],1);
          InOut.WriteString (' CharConst ->   Constant');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrConstant (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtConstant;

PROCEDURE EmitNtGv (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntGv] OF 
   | 149 : 
  EmitNtGv(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 149/2161 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntGv],1);
          InOut.WriteString (' Selector ->   Gv');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Gv.loc:=AT0.Gv.loc; INC(resAttributes.Gv.loc.ofs,e^.attr^.Selector.ofs); 
   | 147 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 147/2142 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntGv],1);
          InOut.WriteString (' GlobalVariable ->   Gv');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Gv.loc          := ASM.mtLocation;
      resAttributes.Gv.loc.label    := e^.attr^.GlobalVariable.label; 
      resAttributes.Gv.loc.ofs      := e^.attr^.GlobalVariable.adr; 
      resAttributes.Gv.loc.breg     := ConsBase.RegNil; 
      resAttributes.Gv.loc.ireg     := ConsBase.RegNil; 
      resAttributes.Gv.loc.factor   := 1; 
      resAttributes.Gv.loc.cmtIdent := e^.attr^.GlobalVariable.cmtIdent; 
   | 27 : 
  EmitNtGv(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 27/1043 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntGv],1);
          InOut.WriteString (' Selector ->   Gv');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Gv.loc:=AT0.Gv.loc; INC(resAttributes.Gv.loc.ofs,e^.attr^.Selector.ofs); 
   | 25 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 25/1024 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntGv],1);
          InOut.WriteString (' GlobalVariable ->   Gv');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Gv.loc          := ASM.mtLocation;
      resAttributes.Gv.loc.label    := e^.attr^.GlobalVariable.label; 
      resAttributes.Gv.loc.ofs      := e^.attr^.GlobalVariable.adr; 
      resAttributes.Gv.loc.breg     := ConsBase.RegNil; 
      resAttributes.Gv.loc.ireg     := ConsBase.RegNil; 
      resAttributes.Gv.loc.factor   := 1; 
      resAttributes.Gv.loc.cmtIdent := e^.attr^.GlobalVariable.cmtIdent; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrGv (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtGv;

PROCEDURE EmitNtIreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntIreg] OF 
   | 153 : 
  EmitNtGv(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 153/2174 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntIreg],1);
          InOut.WriteString (' Index ->   Ireg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Ireg.loc        := AT0.Gv.loc; 
      resAttributes.Ireg.loc.ireg   := RegAlloc.allocation[ai].op[2];  
      resAttributes.Ireg.loc.factor := e^.attr^.Index.factor; 
   | 150 : 
  EmitNtIreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 150/2164 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntIreg],1);
          InOut.WriteString (' Selector ->   Ireg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Ireg.loc:=AT0.Ireg.loc; INC(resAttributes.Ireg.loc.ofs,e^.attr^.Selector.ofs); 
   | 31 : 
  EmitNtGv(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 31/1056 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntIreg],1);
          InOut.WriteString (' Index ->   Ireg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Ireg.loc        := AT0.Gv.loc; 
      resAttributes.Ireg.loc.ireg   := RegAlloc.allocation[ai].op[2];  
      resAttributes.Ireg.loc.factor := e^.attr^.Index.factor; 
   | 28 : 
  EmitNtIreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 28/1046 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntIreg],1);
          InOut.WriteString (' Selector ->   Ireg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Ireg.loc:=AT0.Ireg.loc; INC(resAttributes.Ireg.loc.ofs,e^.attr^.Selector.ofs); 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrIreg (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtIreg;

PROCEDURE EmitNtBreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntBreg] OF 
   | 160 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 160/2217 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' PointerFrom ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc        := ASM.mtLocation;
      resAttributes.Breg.loc.label  := LAB.MT; 
      resAttributes.Breg.loc.ofs    := 0; 
      resAttributes.Breg.loc.breg   := RegAlloc.allocation[ai].op[1];  
      resAttributes.Breg.loc.ireg   := ConsBase.RegNil; 
      resAttributes.Breg.loc.factor := 1; 
   | 154 : 
  EmitNtGv(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 154/2180 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' Index ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc        := AT0.Gv.loc;  
      resAttributes.Breg.loc.breg   := RegAlloc.allocation[ai].op[2]; 
   | 151 : 
  EmitNtBreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 151/2167 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' Selector ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc:=AT0.Breg.loc; INC(resAttributes.Breg.loc.ofs,e^.attr^.Selector.ofs); 
   | 148 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 148/2151 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' LocalVariable ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc          := ASM.mtLocation;
      resAttributes.Breg.loc.label    := LAB.MT; 
      resAttributes.Breg.loc.ofs      := e^.attr^.LocalVariable.adr; 
      resAttributes.Breg.loc.breg     := ConsBase.Regebp; 
      resAttributes.Breg.loc.ireg     := ConsBase.RegNil; 
      resAttributes.Breg.loc.factor   := 1; 
      resAttributes.Breg.loc.cmtIdent := e^.attr^.LocalVariable.cmtIdent; 
   | 136 : 
  EmitNtRetyp(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 136/2106 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' Retype2Addr ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc          := ASM.mtLocation;
      resAttributes.Breg.loc.label    := LAB.MT; 
      resAttributes.Breg.loc.ofs      := e^.son[1]^.gcg^.Retyp.tmpOfs; 
      resAttributes.Breg.loc.breg     := ConsBase.Regebp; 
      resAttributes.Breg.loc.ireg     := ConsBase.RegNil; 
      resAttributes.Breg.loc.factor   := 1; 
      resAttributes.Breg.loc.cmtIdent := Idents.NoIdent; 
   | 38 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 38/1099 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' PointerFrom ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc        := ASM.mtLocation;
      resAttributes.Breg.loc.label  := LAB.MT; 
      resAttributes.Breg.loc.ofs    := 0; 
      resAttributes.Breg.loc.breg   := RegAlloc.allocation[ai].op[1];  
      resAttributes.Breg.loc.ireg   := ConsBase.RegNil; 
      resAttributes.Breg.loc.factor := 1; 
   | 32 : 
  EmitNtGv(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 32/1062 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' Index ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc        := AT0.Gv.loc;  
      resAttributes.Breg.loc.breg   := RegAlloc.allocation[ai].op[2]; 
   | 29 : 
  EmitNtBreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 29/1049 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' Selector ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc:=AT0.Breg.loc; INC(resAttributes.Breg.loc.ofs,e^.attr^.Selector.ofs); 
   | 26 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 26/1033 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBreg],1);
          InOut.WriteString (' LocalVariable ->   Breg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Breg.loc          := ASM.mtLocation;
      resAttributes.Breg.loc.label    := LAB.MT; 
      resAttributes.Breg.loc.ofs      := e^.attr^.LocalVariable.adr; 
      resAttributes.Breg.loc.breg     := ConsBase.Regebp; 
      resAttributes.Breg.loc.ireg     := ConsBase.RegNil; 
      resAttributes.Breg.loc.factor   := 1; 
      resAttributes.Breg.loc.cmtIdent := e^.attr^.LocalVariable.cmtIdent; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrBreg (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtBreg;

PROCEDURE EmitNtBregIreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntBregIreg] OF 
   | 205 : 
  EmitNtReducedStack(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 205/2470 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' HeapOpenIndexApplication ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := ASM.mtLocation;
      resAttributes.BregIreg.loc.label  := LAB.MT; 
      resAttributes.BregIreg.loc.ofs    := e^.attr^.HeapOpenIndexApplication.objOfs; 
      resAttributes.BregIreg.loc.breg   := AT0.ReducedStack.headerBaseReg;
      resAttributes.BregIreg.loc.ireg   := AT0.ReducedStack.displacementReg; 
      resAttributes.BregIreg.loc.factor := 1; 
   | 204 : 
  EmitNtReducedStack(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 204/2462 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' OpenIndexApplication ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := ASM.mtLocation;
      resAttributes.BregIreg.loc.label  := LAB.MT; 
      resAttributes.BregIreg.loc.ofs    := 0; 
      resAttributes.BregIreg.loc.breg   := RegAlloc.allocation[ai].op[2];  
      resAttributes.BregIreg.loc.ireg   := AT0.ReducedStack.displacementReg; 
      resAttributes.BregIreg.loc.factor := 1; 
   | 158 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 158/2205 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := ASM.mtLocation;
      resAttributes.BregIreg.loc.label  := LAB.MT; 
      resAttributes.BregIreg.loc.ofs    := 0; 
      resAttributes.BregIreg.loc.breg   := RegAlloc.allocation[ai].op[1]; 
      resAttributes.BregIreg.loc.ireg   := RegAlloc.allocation[ai].op[2];  
      resAttributes.BregIreg.loc.factor := e^.attr^.Index.factor; 
   | 157 : 
  EmitNtBreg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 157/2200 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := AT0.Breg.loc; 
      resAttributes.BregIreg.loc.ireg   := RegAlloc.allocation[ai].op[2];  
      resAttributes.BregIreg.loc.factor := e^.attr^.Index.factor; 
   | 156 : 
  EmitNtIreg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 156/2195 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := AT0.Ireg.loc;  
      resAttributes.BregIreg.loc.breg   := RegAlloc.allocation[ai].op[2]; 
   | 155 : 
  EmitNtIreg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 155/2185 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := ASM.mtLocation;
      resAttributes.BregIreg.loc.label  := LAB.MT; 
      resAttributes.BregIreg.loc.ofs    := 0; 
      resAttributes.BregIreg.loc.breg   := AT0.Ireg.loc.ireg; 
      resAttributes.BregIreg.loc.ireg   := RegAlloc.allocation[ai].op[2]; 
      resAttributes.BregIreg.loc.factor := e^.attr^.Index.factor;  
      ASM.CS2( lea,l  ,  ASM.Loc(AT0.Ireg.loc),ASM.R(AT0.Ireg.loc.ireg) ); 
   | 152 : 
  EmitNtBregIreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 152/2170 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Selector ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc:=AT0.BregIreg.loc; INC(resAttributes.BregIreg.loc.ofs,e^.attr^.Selector.ofs); 
   | 36 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 36/1087 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := ASM.mtLocation;
      resAttributes.BregIreg.loc.label  := LAB.MT; 
      resAttributes.BregIreg.loc.ofs    := 0; 
      resAttributes.BregIreg.loc.breg   := RegAlloc.allocation[ai].op[1]; 
      resAttributes.BregIreg.loc.ireg   := RegAlloc.allocation[ai].op[2];  
      resAttributes.BregIreg.loc.factor := e^.attr^.Index.factor; 
   | 35 : 
  EmitNtBreg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 35/1082 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := AT0.Breg.loc; 
      resAttributes.BregIreg.loc.ireg   := RegAlloc.allocation[ai].op[2];  
      resAttributes.BregIreg.loc.factor := e^.attr^.Index.factor; 
   | 34 : 
  EmitNtIreg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 34/1077 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := AT0.Ireg.loc;  
      resAttributes.BregIreg.loc.breg   := RegAlloc.allocation[ai].op[2]; 
   | 33 : 
  EmitNtIreg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 33/1067 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Index ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc        := ASM.mtLocation;
      resAttributes.BregIreg.loc.label  := LAB.MT; 
      resAttributes.BregIreg.loc.ofs    := 0; 
      resAttributes.BregIreg.loc.breg   := AT0.Ireg.loc.ireg; 
      resAttributes.BregIreg.loc.ireg   := RegAlloc.allocation[ai].op[2]; 
      resAttributes.BregIreg.loc.factor := e^.attr^.Index.factor;  
      ASM.CS2( lea,l  ,  ASM.Loc(AT0.Ireg.loc),ASM.R(AT0.Ireg.loc.ireg) ); 
   | 30 : 
  EmitNtBregIreg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 30/1052 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBregIreg],1);
          InOut.WriteString (' Selector ->   BregIreg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.BregIreg.loc:=AT0.BregIreg.loc; INC(resAttributes.BregIreg.loc.ofs,e^.attr^.Selector.ofs); 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrBregIreg (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtBregIreg;

PROCEDURE EmitNtMemory (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntMemory] OF 
   | 251 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 251/3084 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' Retype2Addr ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=AT0.Memory.loc; 
   | 192 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 192/2338 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' SimpleGuard ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=AT0.Memory.loc;  
      INC(AT0.Memory.loc.ofs,e^.attr^.SimpleGuard.tagOfs); 
      ASM.CS2( cmp,l  ,  ASM.iL(e^.attr^.SimpleGuard.typeLabel),ASM.Loc(AT0.Memory.loc) );
      ASM.C1 ( jz     ,  ASM.L(LAB.New(label1))          );
      ASM.C1 ( pushl  ,  ASM.oL(-12,e^.attr^.SimpleGuard.typeLabel)        );
      ASM.CS2( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(eax)           );
      ASM.C1 ( pushl  ,  ASM.oB(-12,eax)                 );
      ASM.C1 ( jmp    ,  ASM.L(LAB.GuardFault)           ); 
      ASM.Label(label1); 
   | 190 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 190/2310 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' RecordGuard ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=AT0.Memory.loc;  
      INC(AT0.Memory.loc.ofs,e^.attr^.RecordGuard.tagOfs); 
      ASM.CS2( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[ai].op[2])                         ); 
      ASM.CS2( cmp,l  ,  ASM.iL(e^.attr^.RecordGuard.typeLabel),ASM.oB(e^.attr^.RecordGuard.ttableElemOfs,RegAlloc.allocation[ai].op[2]) );
      ASM.C1 ( jz     ,  ASM.L(LAB.New(label1))                      );
      ASM.C1 ( pushl  ,  ASM.oL(-12,e^.attr^.RecordGuard.typeLabel)                    );
      ASM.C1 ( pushl  ,  ASM.oB(-12,RegAlloc.allocation[ai].op[2])                               );
      ASM.C1 ( jmp    ,  ASM.L(LAB.GuardFault)                       ); 
      ASM.Label(label1); 
      DEC(AT0.Memory.loc.ofs,e^.attr^.RecordGuard.tagOfs); 
   | 71 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtArgs(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 71/1404 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' BoundCall_FRec_ARec ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=ASM.mtLocation;  
      NDP.Save;
      ASM.C1    ( pushl  ,  ASM.R(RegAlloc.allocation[ai].op[1])                    ); 
      IF e^.attr^.BoundCall_FRec_ARec.bprocLab=LAB.MT THEN 
         ASM.CS2( mov,l  ,  ASM.oB(e^.attr^.BoundCall_FRec_ARec.procOfs,RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])   );
         ASM.C1 ( call   ,  ASM.R(RegAlloc.allocation[ai].op[1])                    ); 
      ELSE 
         ASM.C1 ( call   ,  ASM.L(e^.attr^.BoundCall_FRec_ARec.bprocLab)          );
      END;
      IF e^.attr^.BoundCall_FRec_ARec.paramSpace#0 THEN 
         ASM.CS2( add,l  ,  ASM.i(e^.attr^.BoundCall_FRec_ARec.paramSpace),ASM.R(esp) ); 
      END; 
   | 70 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtArgs(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 70/1388 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' BoundCall_FRec_APtr ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=ASM.mtLocation;  
      NDP.Save;
      ASM.C1    ( pushl  ,  ASM.R(RegAlloc.allocation[ai].op[1])                    ); 
      ASM.CS2   ( mov,l  ,  ASM.oB(-4,RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])           ); 
      ASM.C1    ( pushl  ,  ASM.R(RegAlloc.allocation[ai].op[1])                    ); 
      IF e^.attr^.BoundCall_FRec_APtr.bprocLab=LAB.MT THEN 
         ASM.CS2( mov,l  ,  ASM.oB(e^.attr^.BoundCall_FRec_APtr.procOfs,RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])   );
         ASM.C1 ( call   ,  ASM.R(RegAlloc.allocation[ai].op[1])                    ); 
      ELSE 
         ASM.C1 ( call   ,  ASM.L(e^.attr^.BoundCall_FRec_APtr.bprocLab)          );
      END;
      IF e^.attr^.BoundCall_FRec_APtr.paramSpace#0 THEN 
         ASM.CS2( add,l  ,  ASM.i(e^.attr^.BoundCall_FRec_APtr.paramSpace),ASM.R(esp) ); 
      END; 
   | 69 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtArgs(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 69/1373 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' BoundCall_FPtr_APtr ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=ASM.mtLocation;  
      NDP.Save;
      ASM.C1 (    pushl  ,  ASM.R(RegAlloc.allocation[ai].op[1])                    ); 
      ASM.CS2(    mov,l  ,  ASM.oB(-4,RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])           ); 
      IF e^.attr^.BoundCall_FPtr_APtr.bprocLab=LAB.MT THEN 
         ASM.CS2( mov,l  ,  ASM.oB(e^.attr^.BoundCall_FPtr_APtr.procOfs,RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[1])   );
         ASM.C1 ( call   ,  ASM.R(RegAlloc.allocation[ai].op[1])                    ); 
      ELSE 
         ASM.C1 ( call   ,  ASM.L(e^.attr^.BoundCall_FPtr_APtr.bprocLab)          );
      END;
      IF e^.attr^.BoundCall_FPtr_APtr.paramSpace#0 THEN 
         ASM.CS2( add,l  ,  ASM.i(e^.attr^.BoundCall_FPtr_APtr.paramSpace),ASM.R(esp) ); 
      END; 
   | 68 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtArgs(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 68/1365 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' IndirectCall ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=ASM.mtLocation; 
      NDP.Save;
      ASM.C1( call  ,  ASM.R(RegAlloc.allocation[ai].op[1]) ); 
      IF e^.attr^.IndirectCall.paramSpace#0 THEN 
         ASM.CS2( add,l  ,  ASM.i(e^.attr^.IndirectCall.paramSpace),ASM.R(esp) ); 
      END; 
   | 67 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 67/1357 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' DirectCall ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=ASM.mtLocation;  
      NDP.Save;
      ASM.C1( call  ,  ASM.L(e^.attr^.DirectCall.label) ); 
      IF e^.attr^.DirectCall.paramSpace#0 THEN 
         ASM.CS2( add,l  ,  ASM.i(e^.attr^.DirectCall.paramSpace),ASM.R(esp) ); 
      END; 
   | 10 : 
  EmitNtBregIreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 10/997 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' BregIreg ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=AT0.BregIreg.loc; 
   | 9 : 
  EmitNtBreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 9/996 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' Breg ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=AT0.Breg.loc; 
   | 8 : 
  EmitNtIreg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 8/995 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' Ireg ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=AT0.Ireg.loc; 
   | 7 : 
  EmitNtGv(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 7/994 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntMemory],1);
          InOut.WriteString (' Gv ->   Memory');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.Memory.loc:=AT0.Gv.loc; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrMemory (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtMemory;

PROCEDURE EmitNtLab (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR

BEGIN
   CASE e^.gcg^.rule [ntLab] OF 
   | 102 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 102/1683 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntLab],1);
          InOut.WriteString (' LabelDef ->   Lab');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.Label(e^.attr^.LabelDef.label); 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrLab (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtLab;

PROCEDURE EmitNtCond (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntCond] OF 
   | 108 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 108/1730 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntCond],1);
          InOut.WriteString (' ConstStringCompare ->   Cond');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.ConstStringCompare(e^.attr^.ConstStringCompare.str,RegAlloc.allocation[ai].op[2]); 
      resAttributes.Cond.rel:=e^.attr^.ConstStringCompare.rel; 
   | 107 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 107/1712 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntCond],1);
          InOut.WriteString (' StringCompare ->   Cond');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 r1:=ASM.LoRegTab[RegAlloc.allocation[ai].scr[1]]; r2:=ASM.HiRegTab[RegAlloc.allocation[ai].scr[1]]; 
      ASM.Label(LAB.New(label1)); 
      ASM.CS2( mov,b   ,  ASM.B(esi),ASM.R(r1)       ); 
      ASM.CS2( mov,b   ,  ASM.B(edi),ASM.R(r2)       ); 
      ASM.CS2( cmp,b   ,  ASM.R(r2),ASM.R(r1)        ); 
      ASM.C1 ( jnz     ,  ASM.L(LAB.New(label2)) );
      ASM.CS1( inc,l   ,  ASM.R(esi)             );
      ASM.CS1( inc,l   ,  ASM.R(edi)             );

      ASM.CS2( test,b  ,  ASM.R(r1),ASM.R(r2)        ); 
      ASM.C1 ( jnz     ,  ASM.L(label1)          );

      ASM.Label(label2); 
      resAttributes.Cond.rel:=e^.attr^.StringCompare.rel; 
   | 106 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtAImm(e^.son[2],nest+1,AT1 ); 
  EmitNtAMemAReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 106/1705 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntCond],1);
          InOut.WriteString (' Compare ->   Cond');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,e^.son[2]^.gcg^.AImm.size  ,  ASM.Operand(AT1.AImm.oper),ASM.Operand(AT2.AMemAReg.oper) ); 
      resAttributes.Cond.rel:=ASM.RevRelTab[e^.attr^.Compare.rel]; 
   | 105 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtAReg(e^.son[2],nest+1,AT1 ); 
  EmitNtAMemARegAImm(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 105/1699 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntCond],1);
          InOut.WriteString (' Compare ->   Cond');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,e^.son[2]^.gcg^.AReg.size  ,  ASM.Operand(AT2.AMemARegAImm.oper),ASM.Operand(AT1.AReg.oper) ); 
      resAttributes.Cond.rel:=e^.attr^.Compare.rel; 
   | 104 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[2],nest+1,AT1 ); 
  EmitNtARegAImm(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 104/1693 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntCond],1);
          InOut.WriteString (' Compare ->   Cond');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,e^.son[2]^.gcg^.AMem.size  ,  ASM.Operand(AT2.ARegAImm.oper),ASM.Operand(AT1.AMem.oper) ); 
      resAttributes.Cond.rel:=e^.attr^.Compare.rel; 
   | 103 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtBReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 103/1687 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntCond],1);
          InOut.WriteString (' Flag ->   Cond');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,b  ,  ASM.i(1),ASM.R(RegAlloc.allocation[ai].op[2]) ); 
      resAttributes.Cond.rel:=e^.attr^.Flag.rel; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrCond (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtCond;

PROCEDURE EmitNtBool (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntBool] OF 
   | 357 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtFXReg(e^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 357/3654 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Branch ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.BranchOperTab[ASM.InvRelTab[ASM.RevRelTab[e^.son[1]^.attr^.FloatCompare.rel]],(*isSignedRelation:=*)0]; 
      NDP.CS1( fcomp,e^.son[1]^.son[2]^.gcg^.AMem.size  ,  ASM.Operand(AT1.AMem.oper)  );
      NDP.C1 ( fstsw         ,  ASM.R(ax)            );
      ASM.C0 ( sahf                              ); 
      ASM.C1 ( oper          ,  ASM.L(e^.attr^.Branch.falseLabel) );
      ASM.C1 ( jmp           ,  ASM.L(e^.attr^.Branch.trueLabel)  ); 
   | 356 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtAMem(e^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 356/3642 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Branch ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.BranchOperTab[ASM.InvRelTab[e^.son[1]^.attr^.FloatCompare.rel],(*isSignedRelation:=*)0]; 
      NDP.CS1( fcomp,e^.son[1]^.son[3]^.gcg^.AMem.size  ,  ASM.Operand(AT2.AMem.oper)  );
      NDP.C1 ( fstsw         ,  ASM.R(ax)            );
      ASM.C0 ( sahf                              ); 
      ASM.C1 ( oper          ,  ASM.L(e^.attr^.Branch.falseLabel) );
      ASM.C1 ( jmp           ,  ASM.L(e^.attr^.Branch.trueLabel)  ); 
   | 334 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFYReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtFXReg(e^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 334/3474 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Branch ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.BranchOperTab[ASM.InvRelTab[ASM.RevRelTab[e^.son[1]^.attr^.FloatCompare.rel]],(*isSignedRelation:=*)0]; 
      NDP.C0( fcompp                      );
      NDP.C1( fstsw   ,  ASM.R(ax)            );
      ASM.C0( sahf                        ); 
      ASM.C1( oper    ,  ASM.L(e^.attr^.Branch.falseLabel) );
      ASM.C1( jmp     ,  ASM.L(e^.attr^.Branch.trueLabel)  ); 
   | 333 : 
  EmitNtLab(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtFYReg(e^.son[1]^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 333/3462 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Branch ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.BranchOperTab[ASM.InvRelTab[e^.son[1]^.attr^.FloatCompare.rel],(*isSignedRelation:=*)0]; 
      NDP.C0( fcompp                      );
      NDP.C1( fstsw   ,  ASM.R(ax)            );
      ASM.C0( sahf                        ); 
      ASM.C1( oper    ,  ASM.L(e^.attr^.Branch.falseLabel) );
      ASM.C1( jmp     ,  ASM.L(e^.attr^.Branch.trueLabel)  ); 
   | 239 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtAMem(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 239/2996 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Odd ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,b  ,  ASM.i(1),ASM.Operand(AT1.AMem.oper) );
      ASM.C1 ( jz      ,  ASM.L(e^.attr^.Odd.falseLabel)     );
      ASM.C1 ( jmp     ,  ASM.L(e^.attr^.Odd.trueLabel)      ); 
   | 238 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2],nest+1,AT1 ); 
  EmitNtAMemAReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 238/2988 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' In ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 set:={}; INCL(set,e^.son[2]^.gcg^.Constant.val); 
      ASM.CS2( test,l  ,  ASM.i(SYSTEM.VAL(LONGINT,set)),ASM.Operand(AT2.AMemAReg.oper) ); 
      ASM.C1 ( jz      ,  ASM.L(e^.attr^.In.falseLabel)                 );
      ASM.C1 ( jmp     ,  ASM.L(e^.attr^.In.trueLabel)                  ); 
   | 237 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtConstant(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 237/2980 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' In ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,l   ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])                          );
      ASM.C1 ( ja      ,  ASM.L(e^.attr^.In.falseLabel)                     );
      ASM.CS2( test,l  ,  ASM.i(e^.son[3]^.gcg^.Constant.val),ASM.LIf(LAB.SingleBitTab,RegAlloc.allocation[ai].op[2],4) ); 
      ASM.C1 ( jz      ,  ASM.L(e^.attr^.In.falseLabel)                     );
      ASM.C1 ( jmp     ,  ASM.L(e^.attr^.In.trueLabel)                      ); 
   | 113 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 113/1763 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Cc ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF    e^.attr^.Cc.condcoding=ASM.codeCF THEN ASM.C1 ( jnc     ,  ASM.L(e^.attr^.Cc.falseLabel)        );
      ELSIF e^.attr^.Cc.condcoding=ASM.codePF THEN ASM.C1 ( jnp     ,  ASM.L(e^.attr^.Cc.falseLabel)        );
      ELSIF e^.attr^.Cc.condcoding=ASM.codeZF THEN ASM.C1 ( jnz     ,  ASM.L(e^.attr^.Cc.falseLabel)        );
      ELSIF e^.attr^.Cc.condcoding=ASM.codeSF THEN ASM.C1 ( jns     ,  ASM.L(e^.attr^.Cc.falseLabel)        );
      ELSIF e^.attr^.Cc.condcoding=ASM.codeOF THEN ASM.C1 ( jno     ,  ASM.L(e^.attr^.Cc.falseLabel)        );
                                     ELSE ASM.C0 ( pushf                              );
                                          ASM.C1 ( popl    ,  ASM.R(eax)                  );
                                          ASM.CS2( test,l  ,  ASM.x(e^.attr^.Cc.condcoding),ASM.R(eax) );
                                          ASM.C1 ( jnz     ,  ASM.L(e^.attr^.Cc.falseLabel)        );
      END;
      ASM.C1                                     ( jmp     ,  ASM.L(e^.attr^.Cc.trueLabel)         ); 
   | 112 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 112/1757 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Bit ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( bt,l  ,  ASM.R(RegAlloc.allocation[ai].op[3]),ASM.Loc(AT1.Memory.loc)  );
      ASM.C1 ( jnc   ,  ASM.L(e^.attr^.Bit.falseLabel) );
      ASM.C1 ( jmp   ,  ASM.L(e^.attr^.Bit.trueLabel)  ); 
   | 111 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 111/1751 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Odd ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( test,e^.son[2]^.gcg^.Reg.size  ,  ASM.i(1),ASM.R(RegAlloc.allocation[ai].op[2])        );
      ASM.C1 ( jz           ,  ASM.L(e^.attr^.Odd.falseLabel) );
      ASM.C1 ( jmp          ,  ASM.L(e^.attr^.Odd.trueLabel)  ); 
   | 110 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 110/1744 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Is ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,l  ,  ASM.iL(e^.attr^.Is.typeLabel),ASM.oB(e^.attr^.Is.ttableElemOfs,RegAlloc.allocation[ai].op[2]) );
      ASM.C1 ( jnz    ,  ASM.L(e^.attr^.Is.falseLabel)                          );
      ASM.C1 ( jmp    ,  ASM.L(e^.attr^.Is.trueLabel)                           ); 
   | 109 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtAMemAReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 109/1736 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' In ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[ai].op[2])            );
      ASM.C1 ( ja     ,  ASM.L(e^.attr^.In.falseLabel)       );
      ASM.CS2( bt,l   ,  ASM.R(RegAlloc.allocation[ai].op[2]),ASM.Operand(AT2.AMemAReg.oper) ); 
      ASM.C1 ( jnc    ,  ASM.L(e^.attr^.In.falseLabel)       );
      ASM.C1 ( jmp    ,  ASM.L(e^.attr^.In.trueLabel)        ); 
   | 101 : 
  EmitNtCond(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 101/1676 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Branch ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 oper:=ASM.BranchOperTab[ASM.InvRelTab[AT0.Cond.rel],SYSTEM.VAL(SHORTINT,e^.attr^.Branch.isSigned)]; 
      ASM.C1( oper  ,  ASM.L(e^.attr^.Branch.falseLabel) );
      ASM.C1( jmp   ,  ASM.L(e^.attr^.Branch.trueLabel)  ); 
   | 100 : 
  EmitNtLab(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 100/1668 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' ConstBranch ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF e^.attr^.ConstBranch.value THEN 
         ASM.C1( jmp  ,  ASM.L(e^.attr^.ConstBranch.trueLabel)   ); 
      ELSE 
         ASM.C1( jmp  ,  ASM.L(e^.attr^.ConstBranch.falseLabel)  ); 
      END; 
   | 99 : 
  EmitNtBool(e^.son[1],nest+1,AT0 ); 
  EmitNtBool(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 99/1665 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' And ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 98 : 
  EmitNtBool(e^.son[1],nest+1,AT0 ); 
  EmitNtBool(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 98/1664 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Or ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 97 : 
  EmitNtBool(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 97/1663 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntBool],1);
          InOut.WriteString (' Not ->   Bool');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrBool (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtBool;

PROCEDURE EmitNtReducedStack (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;
    AT3   :  NtAttributes;
    AT4   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntReducedStack] OF 
   | 293 : 
  EmitNtLReg(e^.son[1]^.son[1]^.son[2],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[3],nest+1,AT2 ); 
  EmitNtLReg(e^.son[1]^.son[4],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 293/3239 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReducedStack],1);
          InOut.WriteString (' OpenIndexPop ->   ReducedStack');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ReducedStack.headerBaseReg   := ebp; 
      resAttributes.ReducedStack.displacementReg := RegAlloc.allocation[ai].op[1]; 
      reg                  := RegAlloc.allocation[ai].op[2]; (* RegAlloc.allocation[ai].op[2]application due to error suppression *)
      resAttributes.ReducedStack.sizeReg         := RegAlloc.allocation[ai].op[3]; 
      resAttributes.ReducedStack.tmpReg          := RegAlloc.allocation[ai].op[4];

      IF ARG.OptionCommentsInAsm THEN 
         ASM.CmtS("headerBaseReg="); ASM.CmtR(resAttributes.ReducedStack.headerBaseReg); 
         ASM.CmtS(" displacementReg="); ASM.CmtR(resAttributes.ReducedStack.displacementReg); 
         ASM.CmtS(" sizeReg="); ASM.CmtR(resAttributes.ReducedStack.sizeReg); 
         ASM.CmtS(" tmpReg="); ASM.CmtR(resAttributes.ReducedStack.tmpReg); 
      END; 

      IF ARG.OptionIndexChecking THEN 
         ASM.CS2( cmp,l   ,  ASM.oB(e^.son[1]^.son[1]^.attr^.OpenIndexPush.lenOfs,ebp),ASM.R(RegAlloc.allocation[ai].op[1])                   );
         ASM.C1 ( jae     ,  ASM.L(LAB.IndexFault)                              );
      END;

      ASM.CS2   ( imul,l  ,  ASM.i(e^.son[1]^.attr^.OpenIndexStaticBase.size),ASM.R(RegAlloc.allocation[ai].op[1])                          );
      IF ~e^.attr^.OpenIndexPop.isFirstIndex THEN 				            
         ASM.CS3( imul,l  ,  ASM.i(e^.son[1]^.attr^.OpenIndexStaticBase.size),ASM.oB(e^.attr^.OpenIndexPop.lenOfs,ebp),ASM.R(resAttributes.ReducedStack.sizeReg) );
      END;  

   | 292 : 
  EmitNtLReg(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT2 ); 
  EmitNtLReg(e^.son[1]^.son[3],nest+1,AT3 ); 
  EmitNtLReg(e^.son[1]^.son[4],nest+1,AT4 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 292/3209 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReducedStack],1);
          InOut.WriteString (' OpenIndexPop ->   ReducedStack');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ReducedStack.headerBaseReg   := RegAlloc.allocation[ai].op[1]; 
      resAttributes.ReducedStack.displacementReg := RegAlloc.allocation[ai].op[2]; 
      reg                  := RegAlloc.allocation[ai].op[3]; (* RegAlloc.allocation[ai].op[3]application due to error suppression *)
      resAttributes.ReducedStack.sizeReg         := RegAlloc.allocation[ai].op[4]; 
      resAttributes.ReducedStack.tmpReg          := RegAlloc.allocation[ai].op[5];

      IF ARG.OptionCommentsInAsm THEN 
         ASM.CmtS("headerBaseReg="); ASM.CmtR(resAttributes.ReducedStack.headerBaseReg); 
         ASM.CmtS(" displacementReg="); ASM.CmtR(resAttributes.ReducedStack.displacementReg); 
         ASM.CmtS(" sizeReg="); ASM.CmtR(resAttributes.ReducedStack.sizeReg); 
         ASM.CmtS(" tmpReg="); ASM.CmtR(resAttributes.ReducedStack.tmpReg); 
      END; 

      IF ARG.OptionIndexChecking THEN 
         ASM.CS2( cmp,l   ,  ASM.oB(e^.son[1]^.son[1]^.attr^.OpenIndexPush.lenOfs,RegAlloc.allocation[ai].op[1]),ASM.R(RegAlloc.allocation[ai].op[2])                   );
         ASM.C1 ( jae     ,  ASM.L(LAB.IndexFault)                                        );
      END;

      ASM.CS2   ( imul,l  ,  ASM.i(e^.son[1]^.attr^.OpenIndexStaticBase.size),ASM.R(RegAlloc.allocation[ai].op[2])                                    );
      IF ~e^.attr^.OpenIndexPop.isFirstIndex THEN 				            
         ASM.CS3( imul,l  ,  ASM.i(e^.son[1]^.attr^.OpenIndexStaticBase.size),ASM.oB(e^.attr^.OpenIndexPop.lenOfs,RegAlloc.allocation[ai].op[1]),ASM.R(resAttributes.ReducedStack.sizeReg) );
      END;  

   | 291 : 
  EmitNtLReg(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[1]^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[1]^.son[3],nest+1,AT2 ); 
  EmitNtLReg(e^.son[1]^.son[4],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 291/3191 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReducedStack],1);
          InOut.WriteString (' OpenIndexOpenBase ->   ReducedStack');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ReducedStack.headerBaseReg   := RegAlloc.allocation[ai].op[1]; 
      resAttributes.ReducedStack.displacementReg := RegAlloc.allocation[ai].op[2]; 
      resAttributes.ReducedStack.sizeReg         := RegAlloc.allocation[ai].op[3]; 
      resAttributes.ReducedStack.tmpReg          := RegAlloc.allocation[ai].op[4]; 

      ASM.CS3( imul,l  ,  ASM.i(e^.son[1]^.attr^.OpenIndexStaticBase.size),ASM.oB(e^.attr^.OpenIndexOpenBase.lenOfs,RegAlloc.allocation[ai].op[1]),ASM.R(resAttributes.ReducedStack.sizeReg) );

      IF ARG.OptionCommentsInAsm THEN 
         ASM.CmtS("headerBaseReg="); ASM.CmtR(resAttributes.ReducedStack.headerBaseReg); 
         ASM.CmtS(" displacementReg="); ASM.CmtR(resAttributes.ReducedStack.displacementReg); 
         ASM.CmtS(" sizeReg="); ASM.CmtR(resAttributes.ReducedStack.sizeReg); 
         ASM.CmtS(" tmpReg="); ASM.CmtR(resAttributes.ReducedStack.tmpReg); 
      END; 
   | 203 : 
  EmitNtReducedStack(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 203/2443 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReducedStack],1);
          InOut.WriteString (' OpenIndexPop ->   ReducedStack');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ReducedStack.headerBaseReg   := AT0.ReducedStack.headerBaseReg; 
      resAttributes.ReducedStack.displacementReg := AT0.ReducedStack.displacementReg; 
      resAttributes.ReducedStack.sizeReg         := AT0.ReducedStack.sizeReg; 
      resAttributes.ReducedStack.tmpReg          := AT0.ReducedStack.tmpReg;

      IF e^.attr^.OpenIndexPop.isLastIndex THEN 
         ASM.C1 ( popl    ,  ASM.R(AT0.ReducedStack.displacementReg)                       );
         ASM.CS2( imul,l  ,  ASM.R(AT0.ReducedStack.sizeReg),ASM.R(AT0.ReducedStack.displacementReg)          );
      ELSE
         ASM.C1 ( popl    ,  ASM.R(AT0.ReducedStack.tmpReg)                                );
         ASM.CS2( imul,l  ,  ASM.R(AT0.ReducedStack.sizeReg),ASM.R(AT0.ReducedStack.tmpReg)                   );
         ASM.CS2( add,l   ,  ASM.R(AT0.ReducedStack.tmpReg),ASM.R(AT0.ReducedStack.displacementReg)           );
      END;
      IF ~e^.attr^.OpenIndexPop.isFirstIndex THEN
         ASM.CS2( imul,l  ,  ASM.oB(e^.attr^.OpenIndexPop.lenOfs,AT0.ReducedStack.headerBaseReg),ASM.R(AT0.ReducedStack.sizeReg) );
      END; 
   | 202 : 
  EmitNtReducedStack(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 202/2434 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReducedStack],1);
          InOut.WriteString (' OpenIndexOpenBase ->   ReducedStack');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ReducedStack.headerBaseReg   := AT0.ReducedStack.headerBaseReg; 
      resAttributes.ReducedStack.displacementReg := AT0.ReducedStack.displacementReg; 
      resAttributes.ReducedStack.sizeReg         := AT0.ReducedStack.sizeReg; 
      resAttributes.ReducedStack.tmpReg          := AT0.ReducedStack.tmpReg;

      ASM.CS2( imul,l  ,  ASM.oB(e^.attr^.OpenIndexOpenBase.lenOfs,AT0.ReducedStack.headerBaseReg),ASM.R(AT0.ReducedStack.sizeReg) ); 
   | 201 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
  EmitNtLReg(e^.son[4],nest+1,AT3 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 201/2418 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntReducedStack],1);
          InOut.WriteString (' OpenIndexStaticBase ->   ReducedStack');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ReducedStack.headerBaseReg   := RegAlloc.allocation[ai].op[1]; 
      resAttributes.ReducedStack.displacementReg := RegAlloc.allocation[ai].op[2]; 
      resAttributes.ReducedStack.sizeReg         := RegAlloc.allocation[ai].op[3]; 
      resAttributes.ReducedStack.tmpReg          := RegAlloc.allocation[ai].op[4]; 
 
      ASM.CS2( mov,l  ,  ASM.i(e^.attr^.OpenIndexStaticBase.size),ASM.R(resAttributes.ReducedStack.sizeReg) ); 

      IF ARG.OptionCommentsInAsm THEN 
         ASM.CmtS("headerBaseReg="); ASM.CmtR(resAttributes.ReducedStack.headerBaseReg); 
         ASM.CmtS(" displacementReg="); ASM.CmtR(resAttributes.ReducedStack.displacementReg); 
         ASM.CmtS(" sizeReg="); ASM.CmtR(resAttributes.ReducedStack.sizeReg); 
         ASM.CmtS(" tmpReg="); ASM.CmtR(resAttributes.ReducedStack.tmpReg); 
      END; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrReducedStack (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtReducedStack;

PROCEDURE EmitNtStrCopyArgs (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntStrCopyArgs] OF 
   | 210 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 210/2580 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntStrCopyArgs],1);
          InOut.WriteString (' StrCopyArguments ->   StrCopyArgs');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 INC(AT0.Memory.loc.ofs,e^.son[1]^.attr^.Implicify.lenOfs);
      ASM.CS2   ( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(ecx) ); 
      ASM.CS2   ( cmp,l  ,  ASM.i(e^.son[2]^.attr^.ImplicifyConst.len),ASM.R(ecx)     ); 
      ASM.C1    ( jle    ,  ASM.L(LAB.New(label))   );
      ASM.CS2   ( mov,l  ,  ASM.i(e^.son[2]^.attr^.ImplicifyConst.len),ASM.R(ecx)     ); 
      ASM.Label(label);                      
      DEC(AT0.Memory.loc.ofs,e^.son[1]^.attr^.Implicify.lenOfs);

      INC(AT0.Memory.loc.ofs,e^.son[1]^.attr^.Implicify.objOfs);
      IF e^.son[1]^.attr^.Implicify.isStackObject THEN
         ASM.CS2( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(esi) );
      ELSE
         ASM.CS2( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(esi) );
      END;
      
      ASM.CS2   ( lea,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(edi) ); 
   | 209 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 209/2558 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntStrCopyArgs],1);
          InOut.WriteString (' StrCopyArguments ->   StrCopyArgs');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 INC(AT1.Memory.loc.ofs,e^.son[2]^.attr^.Implicify.lenOfs);
      ASM.CS2   ( mov,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(ecx) ); 
      ASM.CS2   ( cmp,l  ,  ASM.i(e^.son[1]^.attr^.ImplicifyConst.len),ASM.R(ecx)     ); 
      ASM.C1    ( jle    ,  ASM.L(LAB.New(label))   );
      ASM.CS2   ( mov,l  ,  ASM.i(e^.son[1]^.attr^.ImplicifyConst.len),ASM.R(ecx)     ); 
      ASM.Label(label);                      
      DEC(AT1.Memory.loc.ofs,e^.son[2]^.attr^.Implicify.lenOfs);

      ASM.CS2   ( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(esi) );
      
      INC(AT1.Memory.loc.ofs,e^.son[2]^.attr^.Implicify.objOfs);
      IF e^.son[2]^.attr^.Implicify.isStackObject THEN
         ASM.CS2( mov,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(edi) );
      ELSE
         ASM.CS2( lea,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(edi) );
      END; 
   | 208 : 
  EmitNtMemory(e^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 208/2528 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntStrCopyArgs],1);
          InOut.WriteString (' StrCopyArguments ->   StrCopyArgs');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 INC(AT0.Memory.loc.ofs,e^.son[1]^.attr^.Implicify.lenOfs);
      ASM.CS2   ( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(ecx) ); 
      DEC(AT0.Memory.loc.ofs,e^.son[1]^.attr^.Implicify.lenOfs);

      INC(AT1.Memory.loc.ofs,e^.son[2]^.attr^.Implicify.lenOfs);
      ASM.CS2   ( cmp,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(ecx) ); 
      ASM.C1    ( jle    ,  ASM.L(LAB.New(label1))  );
      ASM.CS2   ( mov,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(ecx) ); 
      ASM.Label(label1);                      
      DEC(AT1.Memory.loc.ofs,e^.son[2]^.attr^.Implicify.lenOfs);

      INC(AT0.Memory.loc.ofs,e^.son[1]^.attr^.Implicify.objOfs);
      IF e^.son[1]^.attr^.Implicify.isStackObject THEN
         ASM.CS2( mov,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(esi) );
      ELSE
         ASM.CS2( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(esi) );
      END;
      
      INC(AT1.Memory.loc.ofs,e^.son[2]^.attr^.Implicify.objOfs);
      IF e^.son[2]^.attr^.Implicify.isStackObject THEN
         ASM.CS2( mov,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(edi) );
      ELSE
         ASM.CS2( lea,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(edi) );
      END; 
   | 48 : 
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 48/1182 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntStrCopyArgs],1);
          InOut.WriteString (' StrCopyArguments ->   StrCopyArgs');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1 ( popl    ,  ASM.R(ecx)             );
      ASM.CS2( cmp,l   ,  ASM.B(esp),ASM.R(ecx)      );
      ASM.C1 ( jle     ,  ASM.L(LAB.New(label1)) );
      ASM.CS2( mov,l   ,  ASM.B(esp),ASM.R(ecx)      );
      ASM.Label(label1);
      ASM.CS2( add,l   ,  ASM.i(4),ASM.R(esp)        ); 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrStrCopyArgs (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtStrCopyArgs;

PROCEDURE EmitNtArgs (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntArgs] OF 
   | 325 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 325/3423 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' FloatParam ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( sub,l         ,  ASM.i(ASM.FloatByteSizeTab[e^.attr^.FloatParam.size]),ASM.R(esp) );
      NDP.CS1( fstp,e^.attr^.FloatParam.size  ,  ASM.B(esp)                                  ); 
   | 213 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2]^.son[1]^.son[1]^.son[1]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 213/2620 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1( pushl  ,  ASM.Loc(AT1.Memory.loc) ); 
   | 212 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2]^.son[1]^.son[1]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 212/2610 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1( pushl  ,  ASM.Loc(AT1.Memory.loc) ); 
   | 211 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtGv(e^.son[2]^.son[1],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 211/2603 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1( pushl  ,  ASM.ioL(AT1.Gv.loc.ofs,AT1.Gv.loc.label) ); 
   | 66 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReducedStack(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 66/1351 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_PartialOArrSizeAndAddrOfPtr ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1 ( pushl  ,  ASM.R(AT1.ReducedStack.sizeReg)                                                  );
      ASM.CS2( lea,l  ,  ASM.oBI(e^.attr^.Param_PartialOArrSizeAndAddrOfPtr.objOfs,AT1.ReducedStack.headerBaseReg,AT1.ReducedStack.displacementReg),ASM.R(AT1.ReducedStack.sizeReg) );
      ASM.C1 ( pushl  ,  ASM.R(AT1.ReducedStack.sizeReg)                                                  ); 
   | 65 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReducedStack(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 65/1346 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_PartialOArrSizeAndAddrOfPar ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1 ( pushl  ,  ASM.R(AT1.ReducedStack.sizeReg)                       );
      ASM.CS2( add,l  ,  ASM.R(AT1.ReducedStack.displacementReg),ASM.R(RegAlloc.allocation[ai].op[3]) );
      ASM.C1 ( pushl  ,  ASM.R(RegAlloc.allocation[ai].op[3])                      ); 
   | 64 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 64/1334 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_OArrSizeAndAddr ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],l]; 
      IF e^.attr^.Param_OArrSizeAndAddr.elemSize=1 THEN 
         ASM.C1  ( pushl   ,  ASM.B(reg)                     );
      ELSE 
         ASM.CS3 ( imul,l  ,  ASM.i(e^.attr^.Param_OArrSizeAndAddr.elemSize),ASM.B(RegAlloc.allocation[ai].op[2]),ASM.R(RegAlloc.allocation[ai].scr[1]) );
         ASM.C1  ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])                     );
      END;
      ASM.CS2    ( lea,l   ,  ASM.oB(e^.attr^.Param_OArrSizeAndAddr.objOfs,reg),ASM.R(reg)   ); 
      ASM.C1     ( pushl   ,  ASM.R(reg)                     ); 
   | 63 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 63/1327 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_RecordSizeAndAddr ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],l]; 
      ASM.CS2( mov,l  ,  ASM.oB(-4,reg),ASM.R(RegAlloc.allocation[ai].scr[1]) ); 
      ASM.C1 ( pushl  ,  ASM.oB(-8,RegAlloc.allocation[ai].scr[1])        );
      ASM.C1 ( pushl  ,  ASM.R(reg)            ); 
   | 62 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 62/1298 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_LensAndNewNofElems ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],l]; 
      IF e^.attr^.Param_LensAndNewNofElems.nofOpenLens=1 THEN 
         IF e^.attr^.Param_LensAndNewNofElems.nofOpenLens=1 THEN 
            ASM.C1 ( pushl   ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs,reg)                          );
            ASM.C1 ( pushl   ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs,reg)                          );
         ELSE
            ASM.C1 ( pushl   ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs,reg)                          );
            ASM.CS3( imul,l  ,  ASM.i(e^.attr^.Param_LensAndNewNofElems.nofOpenLens),ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs,reg),ASM.R(RegAlloc.allocation[ai].scr[1]) );
            ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])                                         );
         END;
      ELSE
         IF e^.attr^.Param_LensAndNewNofElems.nofOpenLens=1 THEN
            ASM.CS2( mov,l   ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs,reg),ASM.R(RegAlloc.allocation[ai].scr[1])                   );
            ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])                                         );
         ELSE 							     	  
            ASM.CS2( mov,l   ,  ASM.i(e^.attr^.Param_LensAndNewNofElems.nofOpenLens),ASM.R(RegAlloc.allocation[ai].scr[1])                       ); 
            ASM.C1 ( pushl   ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs,reg)                          );
            ASM.CS2( imul,l  ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs,reg),ASM.R(RegAlloc.allocation[ai].scr[1])                   );
         END;
         FOR ii:=1 TO e^.attr^.Param_LensAndNewNofElems.nofOpenLens-1 DO
          ASM.C1   ( pushl   ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs-4*ii,reg)                     );
          ASM.CS2  ( imul,l  ,  ASM.oB(e^.attr^.Param_LensAndNewNofElems.lastLenOfs-4*ii,reg),ASM.R(RegAlloc.allocation[ai].scr[1])              );
         END;
         ASM.C1    ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])                                         );
      END; 
   | 61 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 61/1292 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_Lens ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],l]; 
      FOR ii:=0 TO e^.attr^.Param_Lens.nofOpenLens-1 DO
       ASM.C1( pushl  ,  ASM.oB(e^.attr^.Param_Lens.lastLenOfs-4*ii,reg) );
      END; 
   | 60 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 60/1263 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_LensAndNewNofElemsAndAddr ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],l]; 
      IF e^.attr^.Param_LensAndNewNofElemsAndAddr.nofOpenLens=1 THEN 
         IF e^.attr^.Param_LensAndNewNofElemsAndAddr.baseNofElems=1 THEN 
            ASM.C1 ( pushl   ,  ASM.oB(-4,reg)                           );
            ASM.C1 ( pushl   ,  ASM.oB(-4,reg)                           );
         ELSE 					                     		        	  
            ASM.C1 ( pushl   ,  ASM.oB(-4,reg)                           );
            ASM.CS3( imul,l  ,  ASM.i(e^.attr^.Param_LensAndNewNofElemsAndAddr.baseNofElems),ASM.oB(-4,reg),ASM.R(RegAlloc.allocation[ai].scr[1]) );
            ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])                               );
         END;
      ELSE 
         IF e^.attr^.Param_LensAndNewNofElemsAndAddr.baseNofElems=1 THEN 
            ASM.CS2( mov,l   ,  ASM.oB(-4,reg),ASM.R(RegAlloc.allocation[ai].scr[1])                    );
            ASM.C1 ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])                               );
         ELSE 							   
            ASM.CS2( mov,l   ,  ASM.i(e^.attr^.Param_LensAndNewNofElemsAndAddr.baseNofElems),ASM.R(RegAlloc.allocation[ai].scr[1])            ); 
            ASM.C1 ( pushl   ,  ASM.oB(-4,reg)                           );
            ASM.CS2( imul,l  ,  ASM.oB(-4,reg),ASM.R(RegAlloc.allocation[ai].scr[1])                    );
         END;
         FOR ii:=2 TO e^.attr^.Param_LensAndNewNofElemsAndAddr.nofOpenLens DO				   
          ASM.C1   ( pushl   ,  ASM.oB(-4*ii,reg)                        );
          ASM.CS2  ( imul,l  ,  ASM.oB(-4*ii,reg),ASM.R(RegAlloc.allocation[ai].scr[1])                 );
         END;
         ASM.C1    ( pushl   ,  ASM.R(RegAlloc.allocation[ai].scr[1])                               );
      END; 							     
      ASM.C1       ( pushl   ,  ASM.R(reg)                               ); 
   | 59 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 59/1256 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_LensAndAddr ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],l]; 
      FOR ii:=1 TO e^.attr^.Param_LensAndAddr.nofOpenLens DO
       ASM.C1( pushl  ,  ASM.oB(-4*ii,reg) );
      END; 
      ASM.C1 ( pushl  ,  ASM.R(reg)        ); 
   | 58 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 58/1250 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param_AddrAndTag ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[ai].op[2],l]; 
      ASM.C1( pushl  ,  ASM.R(reg)     );
      ASM.C1( pushl  ,  ASM.oB(-4,reg) ); 
   | 57 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 57/1245 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param8 ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.C1( pushl  ,  ASM.i(e^.attr^.Param8.lrHi) ); 
      ASM.C1( pushl  ,  ASM.i(e^.attr^.Param8.lrLo) ); 
   | 56 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtReg(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 56/1243 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param0 ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 55 : 
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtAMemARegAImm(e^.son[2],nest+1,AT1 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 55/1235 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' Param ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 IF AT1.AMemARegAImm.oper.kind=ASM.okRegister THEN 
         ASM.C1( pushl  ,  ASM.R(ASM.SizedRegTab[AT1.AMemARegAImm.oper.reg,l]) );
      ELSE 
         ASM.C1( pushl  ,  ASM.Operand(AT1.AMemARegAImm.oper)                  );
      END; 
   | 54 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 54/1233 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntArgs],1);
          InOut.WriteString (' NoParam ->   Args');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrArgs (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtArgs;

PROCEDURE EmitNtRetyp (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntRetyp] OF 
   | 131 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 131/2078 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntRetyp],1);
          InOut.WriteString (' Addr2Retype ->   Retyp');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.MemCopy(ASM.Loc(AT0.Memory.loc),ASM.oB(e^.attr^.Addr2Retype.tmpOfs,ebp),RegAlloc.allocation[ai].scr[1],e^.attr^.Addr2Retype.srcLen,(*isStringCopy:=*)FALSE); 

      ASM.FillZ(ASM.oB(e^.attr^.Addr2Retype.tmpOfs+e^.attr^.Addr2Retype.srcLen,ebp),RegAlloc.allocation[ai].scr[1],e^.attr^.Addr2Retype.dstLen-e^.attr^.Addr2Retype.srcLen); 
   | 130 : 
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 130/2069 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntRetyp],1);
          InOut.WriteString (' Data2Retype ->   Retyp');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 NDP.CS1( fstp,ASM.FloatSizeTab[e^.attr^.Data2Retype.srcLen]  ,  ASM.oB(e^.attr^.Data2Retype.tmpOfs,ebp) ); 

      ASM.FillZ(ASM.oB(e^.attr^.Data2Retype.tmpOfs+e^.attr^.Data2Retype.srcLen,ebp),RegAlloc.allocation[ai].scr[1],e^.attr^.Data2Retype.dstLen-e^.attr^.Data2Retype.srcLen); 
   | 129 : 
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 129/2059 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntRetyp],1);
          InOut.WriteString (' Data2Retype ->   Retyp');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 ASM.CS2( mov,e^.son[1]^.gcg^.Reg.size  ,  ASM.R(RegAlloc.allocation[ai].op[1]),ASM.oB(e^.attr^.Data2Retype.tmpOfs,ebp) ); 

      len:=ASM.ByteSizeTab[e^.son[1]^.gcg^.Reg.size]; 
      ASM.FillZ(ASM.oB(e^.attr^.Data2Retype.tmpOfs+len,ebp),RegAlloc.allocation[ai].scr[1],e^.attr^.Data2Retype.dstLen-len); 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrRetyp (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtRetyp;

PROCEDURE EmitNtAMem (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntAMem] OF 
   | 323 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 323/3412 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMem],1);
          InOut.WriteString (' FloatContentOf ->   AMem');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMem.oper.kind := ASM.okMemory; 
      resAttributes.AMem.oper.loc  := AT0.Memory.loc; 
   | 39 : 
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 39/1108 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMem],1);
          InOut.WriteString (' ContentOf ->   AMem');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMem.oper.kind := ASM.okMemory; 
      resAttributes.AMem.oper.loc  := AT0.Memory.loc; 
   | 11 : 
  EmitNtMemory(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 11/1001 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMem],1);
          InOut.WriteString (' Memory ->   AMem');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMem.oper.kind:=ASM.okMemory   ; resAttributes.AMem.oper.loc:=AT0.Memory.loc; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrAMem (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtAMem;

PROCEDURE EmitNtAReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntAReg] OF 
   | 14 : 
  EmitNtLReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 14/1004 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAReg],1);
          InOut.WriteString (' LReg ->   AReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AReg.oper.kind:=ASM.okRegister ; resAttributes.AReg.oper.reg:=RegAlloc.allocation[ai].op[1]; 
   | 13 : 
  EmitNtWReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 13/1003 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAReg],1);
          InOut.WriteString (' WReg ->   AReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AReg.oper.kind:=ASM.okRegister ; resAttributes.AReg.oper.reg:=RegAlloc.allocation[ai].op[1]; 
   | 12 : 
  EmitNtBReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 12/1002 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAReg],1);
          InOut.WriteString (' BReg ->   AReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AReg.oper.kind:=ASM.okRegister ; resAttributes.AReg.oper.reg:=RegAlloc.allocation[ai].op[1]; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrAReg (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtAReg;

PROCEDURE EmitNtAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntAImm] OF 
   | 15 : 
  EmitNtConstant(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 15/1005 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAImm],1);
          InOut.WriteString (' Constant ->   AImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AImm.oper.kind:=ASM.okImmediate; resAttributes.AImm.oper.val:=e^.gcg^.Constant.val; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrAImm (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtAImm;

PROCEDURE EmitNtAMemAReg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntAMemAReg] OF 
   | 17 : 
  EmitNtAReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 17/1008 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMemAReg],1);
          InOut.WriteString (' AReg ->   AMemAReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMemAReg.oper:=AT0.AReg.oper; 
   | 16 : 
  EmitNtAMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 16/1007 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMemAReg],1);
          InOut.WriteString (' AMem ->   AMemAReg');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMemAReg.oper:=AT0.AMem.oper; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrAMemAReg (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtAMemAReg;

PROCEDURE EmitNtAMemAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntAMemAImm] OF 
   | 19 : 
  EmitNtAImm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 19/1011 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMemAImm],1);
          InOut.WriteString (' AImm ->   AMemAImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMemAImm.oper:=AT0.AImm.oper; 
   | 18 : 
  EmitNtAMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 18/1010 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMemAImm],1);
          InOut.WriteString (' AMem ->   AMemAImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMemAImm.oper:=AT0.AMem.oper; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrAMemAImm (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtAMemAImm;

PROCEDURE EmitNtARegAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntARegAImm] OF 
   | 21 : 
  EmitNtAImm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 21/1014 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntARegAImm],1);
          InOut.WriteString (' AImm ->   ARegAImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ARegAImm.oper:=AT0.AImm.oper; 
   | 20 : 
  EmitNtAReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 20/1013 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntARegAImm],1);
          InOut.WriteString (' AReg ->   ARegAImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.ARegAImm.oper:=AT0.AReg.oper; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrARegAImm (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtARegAImm;

PROCEDURE EmitNtAMemARegAImm (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntAMemARegAImm] OF 
   | 24 : 
  EmitNtAImm(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 24/1018 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMemARegAImm],1);
          InOut.WriteString (' AImm ->   AMemARegAImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMemARegAImm.oper:=AT0.AImm.oper; 
   | 23 : 
  EmitNtAReg(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 23/1017 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMemARegAImm],1);
          InOut.WriteString (' AReg ->   AMemARegAImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMemARegAImm.oper:=AT0.AReg.oper; 
   | 22 : 
  EmitNtAMem(e,nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 22/1016 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAMemARegAImm],1);
          InOut.WriteString (' AMem ->   AMemARegAImm');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;
 resAttributes.AMemARegAImm.oper:=AT0.AMem.oper; 
   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrAMemARegAImm (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtAMemARegAImm;

PROCEDURE EmitNtAVar (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes); 
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntAVar] OF 
   | 297 : 
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 297/3298 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAVar],1);
          InOut.WriteString (' Selector ->   AVar');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 296 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 296/3288 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAVar],1);
          InOut.WriteString (' Selector ->   AVar');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 295 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 295/3281 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAVar],1);
          InOut.WriteString (' LocalVariable ->   AVar');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   | 294 : 
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN 
          PerformActions (SHORT(ai));
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          InOut.WriteString ('Rule 294/3274 Cost=');
          InOut.WriteInt    (e^.gcg^.cost [ntAVar],1);
          InOut.WriteString (' GlobalVariable ->   AVar');
          InOut.WriteLn;
          WriteNest (nest); 
          InOut.WriteCard (SYSTEM.VAL(LONGINT,e),1); InOut.Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE InOut.WriteLn; END;
          WriteNest (nest); 
          RegAlloc.PrintAllocation (SHORT(ai)); 
       END;

   END;
   IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       WriteAttrAVar (resAttributes);
       InOut.WriteLn;
   END;
END EmitNtAVar;

PROCEDURE EmitStatement* (e : IR.Expression);
CONST nest = 0;  
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

VAR yyDIV0var:INTEGER;
BEGIN
   ai := RegAlloc.ai;
   IF e^.gcg^.stmtcost >= IR.infcost THEN 
     (*************** Compiler Error ******************)
     (******** No code selected, no cover found *******)
     InOut.WriteString ('no code selected'); InOut.WriteLn;
     IR.PrintInstrCosts (e);
     InOut.WriteLn;
     IR.Error ('internal error');
yyDIV0var:=0; yyDIV0var:=1 DIV yyDIV0var; HALT(0);
   ELSE
     CASE e^.gcg^.stmtrule OF 
     | 44 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtARegAImm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 44/1134 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,e^.son[2]^.gcg^.ARegAImm.size  ,  ASM.Operand(AT1.ARegAImm.oper),ASM.Loc(AT0.Memory.loc) ); 
     | 45 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 45/1139 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' MemCopy');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.MemCopy(ASM.Loc(AT1.Memory.loc),ASM.Loc(AT0.Memory.loc),RegAlloc.allocation[1].scr[1],e^.attr^.MemCopy.len,e^.attr^.MemCopy.isStringCopy); 
     | 46 :
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 46/1145 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' ShortConstStrCopy');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 CASE e^.attr^.ShortConstStrCopy.len OF
      |0: ASM.C1 ( popl    ,  ASM.R(ecx)                      );
          ASM.CS2( test,l  ,  ASM.R(ecx),ASM.R(ecx)               );
          ASM.C1 ( jle     ,  ASM.L(LAB.New(label1))          );
          ASM.CS2( mov,b   ,  ASM.i(0),ASM.B(edi)                 );
          ASM.Label(label1);

      |1: ASM.C1 ( popl    ,  ASM.R(ecx)                      );
          ASM.CS2( cmp,l   ,  ASM.i(1),ASM.R(ecx)                 );
          ASM.C1 ( jl      ,  ASM.L(LAB.New(label2))          );
          ASM.C1 ( jz      ,  ASM.L(LAB.New(label1))          );
          ASM.CS2( mov,b   ,  ASM.i(e^.attr^.ShortConstStrCopy.strVal MOD 256),ASM.B(edi) );
          ASM.CS1( inc,l   ,  ASM.R(edi)                      );
          ASM.Label(label1);
          ASM.CS2( mov,b   ,  ASM.i(0),ASM.B(edi)                 );
          ASM.Label(label2);
      END; 
     | 47 :
  EmitNtStrCopyArgs(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 47/1166 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' StrCopy');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( sub,l   ,  ASM.i(1),ASM.R(ecx)        );
      ASM.C1 ( jl      ,  ASM.L(LAB.New(label4)) );
      ASM.C1 ( jz      ,  ASM.L(LAB.New(label3)) );

      ASM.C0 ( cld                           );
      ASM.Label(LAB.New(label2));
      ASM.CS0( lods,b                        );
      ASM.CS0( stos,b                        );
      ASM.CS2( test,b  ,  ASM.R(al),ASM.R(al)        );
      ASM.C1 ( loopnz  ,  ASM.L(label2)          );
      ASM.C1 ( jz      ,  ASM.L(label4)          );
      ASM.Label(label3);
      ASM.CS2( mov,b   ,  ASM.i(0),ASM.B(edi)        );
      ASM.Label(label4); 
     | 52 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 52/1222 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' MemSet3');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,w  ,  ASM.i(e^.attr^.MemSet3.v MOD 65536),ASM.Loc(AT0.Memory.loc) ); 
      INC(AT0.Memory.loc.ofs,2);
      ASM.CS2( mov,b  ,  ASM.i(e^.attr^.MemSet3.v DIV 65536),ASM.Loc(AT0.Memory.loc) ); 
     | 53 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 53/1227 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' MemSet8');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,l  ,  ASM.i(e^.attr^.MemSet8.lrLo),ASM.Loc(AT0.Memory.loc) ); 
      INC(AT0.Memory.loc.ofs,4);
      ASM.CS2( mov,l  ,  ASM.i(e^.attr^.MemSet8.lrHi),ASM.Loc(AT0.Memory.loc) ); 
     | 72 :
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 72/1419 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' ProcReturn');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,l  ,  ASM.R(ebp),ASM.R(esp) ); 
      ASM.C1 ( popl   ,  ASM.R(ebp)        );
      ASM.C0 ( ret                     ); 
     | 73 :
  EmitNtBReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 73/1424 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' FuncReturn');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,l  ,  ASM.R(ebp),ASM.R(esp) ); 
      ASM.C1 ( popl   ,  ASM.R(ebp)        );
      ASM.C0 ( ret                     ); 
     | 74 :
  EmitNtWReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 74/1429 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' FuncReturn');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,l  ,  ASM.R(ebp),ASM.R(esp) ); 
      ASM.C1 ( popl   ,  ASM.R(ebp)        );
      ASM.C0 ( ret                     ); 
     | 75 :
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 75/1434 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' FuncReturn');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,l  ,  ASM.R(ebp),ASM.R(esp) ); 
      ASM.C1 ( popl   ,  ASM.R(ebp)        );
      ASM.C0 ( ret                     ); 
     | 76 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 76/1440 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' NoFuncResult');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;

     | 80 :
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 80/1458 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' CaseExpr');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 reg:=ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l]; 
      IF e^.attr^.CaseExpr.isChar THEN 
         ASM.CS2           ( and,l   ,  ASM.x(0FFH),ASM.R(reg)                ); 
      ELSIF e^.son[1]^.gcg^.Reg.size=b THEN
         ASM.C2            ( movsbl  ,  ASM.R(RegAlloc.allocation[1].op[1]),ASM.R(reg)                   );
      ELSIF RegAlloc.allocation[1].op[1]=ax THEN
         ASM.C0            ( cwde                                     );
      ELSIF e^.son[1]^.gcg^.Reg.size=w THEN
         ASM.C2            ( movswl  ,  ASM.R(RegAlloc.allocation[1].op[1]),ASM.R(reg)                   );
      END;                                               

      IF e^.attr^.CaseExpr.minVal>0 THEN 
         ASM.CS2           ( sub,l   ,  ASM.i(e^.attr^.CaseExpr.minVal),ASM.R(reg)           ); 
      ELSIF e^.attr^.CaseExpr.minVal<0 THEN                            
         ASM.CS2           ( add,l   ,  ASM.i(-e^.attr^.CaseExpr.minVal),ASM.R(reg)          ); 
      ELSIF ~e^.attr^.CaseExpr.isChar THEN
         ASM.CS2           ( test,l  ,  ASM.R(reg),ASM.R(reg)                 ); 
      END;
      ASM.C1               ( jl      ,  ASM.L(e^.attr^.CaseExpr.elseLabel)               );
      		   
      ASM.CS2              ( cmp,l   ,  ASM.i(e^.attr^.CaseExpr.maxVal-e^.attr^.CaseExpr.minVal),ASM.R(reg) ); 
      ASM.C1               ( jg      ,  ASM.L(e^.attr^.CaseExpr.elseLabel)               );
      ASM.C1               ( jmp     ,  ASM.LIf(e^.attr^.CaseExpr.tabLabel,reg,4)        ); 
     | 81 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 81/1483 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' ForStmt');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 IF e^.attr^.ForStmt.step>1 THEN 
         ASM.CS2           ( add,e^.attr^.ForStmt.size  ,  ASM.i(e^.attr^.ForStmt.step),ASM.Loc(AT0.Memory.loc)     ); 
      ELSIF e^.attr^.ForStmt.step<-1 THEN
         ASM.CS2           ( sub,e^.attr^.ForStmt.size  ,  ASM.i(-e^.attr^.ForStmt.step),ASM.Loc(AT0.Memory.loc)    ); 
      ELSIF e^.attr^.ForStmt.step=-1 THEN
         ASM.CS1           ( dec,e^.attr^.ForStmt.size  ,  ASM.Loc(AT0.Memory.loc)                ); 
      ELSE                                                  
         ASM.CS1           ( inc,e^.attr^.ForStmt.size  ,  ASM.Loc(AT0.Memory.loc)                ); 
      END;          
      
      reg:=ASM.SizedRegTab[RegAlloc.allocation[1].scr[1],e^.attr^.ForStmt.size]; 
      ASM.Label            ( e^.attr^.ForStmt.condLabel                              ); 
      ASM.CS2              ( mov,e^.attr^.ForStmt.size  ,  ASM.oB(e^.attr^.ForStmt.tempOfs,ebp),ASM.R(reg) );
      ASM.CS2              ( cmp,e^.attr^.ForStmt.size  ,  ASM.R(reg),ASM.Loc(AT0.Memory.loc)         );
      IF e^.attr^.ForStmt.step<0 THEN 
         ASM.C1            ( jge          ,  ASM.L(e^.attr^.ForStmt.loopLabel)           );
      ELSE 
         ASM.C1            ( jle          ,  ASM.L(e^.attr^.ForStmt.loopLabel)           );
      END; 
     | 95 :
  EmitNtBool(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 95/1651 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' NoBoolVal');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;

     | 117 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtARegAImm(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 117/1813 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' IncOrDec');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( e^.attr^.IncOrDec.code,e^.son[2]^.gcg^.ARegAImm.size  ,  ASM.Operand(AT1.ARegAImm.oper),ASM.Loc(AT0.Memory.loc) ); 
     | 118 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 118/1818 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Excl');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[1].op[2])          );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault) );
      END;
      ASM.CS2   ( btr,l  ,  ASM.R(RegAlloc.allocation[1].op[2]),ASM.Loc(AT0.Memory.loc)     ); 
     | 119 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 119/1826 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Incl');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 IF ARG.OptionRangeChecking THEN 
         ASM.CS2( cmp,l  ,  ASM.i(31),ASM.R(RegAlloc.allocation[1].op[2])          );
         ASM.C1 ( ja     ,  ASM.L(LAB.ElementFault) );
      END;
      ASM.CS2   ( bts,l  ,  ASM.R(RegAlloc.allocation[1].op[2]),ASM.Loc(AT0.Memory.loc)     ); 
     | 121 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 121/1850 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' StaticNew');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.C1 ( pushl  ,  ASM.iL(e^.attr^.StaticNew.initLabel)  );
      ASM.C1 ( pushl  ,  ASM.iL(e^.attr^.StaticNew.tdescLabel) );
      ASM.C1 ( pushl  ,  ASM.i(e^.attr^.StaticNew.size)        );
      ASM.CS2( lea,l  ,  ASM.Loc(AT0.Memory.loc),ASM.R(RegAlloc.allocation[1].scr[1])   );
      ASM.C1 ( pushl  ,  ASM.R(RegAlloc.allocation[1].scr[1])              );
      ASM.C1 ( call   ,  ASM.L(LAB.StaticNew)  );
      ASM.CS2( add,l  ,  ASM.i(16),ASM.R(esp)      ); 
     | 122 :
  EmitNtArgs(e^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 122/1861 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' OpenNew');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.C1 ( pushl  ,  ASM.i(e^.attr^.OpenNew.nofLens)           );
      ASM.C1 ( pushl  ,  ASM.iL(e^.attr^.OpenNew.initLabel)        );
      ASM.C1 ( pushl  ,  ASM.iL(e^.attr^.OpenNew.tdescLabel)       );
      ASM.C1 ( pushl  ,  ASM.i(e^.attr^.OpenNew.elemSize)          );
      ASM.CS2( lea,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(RegAlloc.allocation[1].scr[1])         );
      ASM.C1 ( pushl  ,  ASM.R(RegAlloc.allocation[1].scr[1])                    );
      ASM.C1 ( call   ,  ASM.L(LAB.OpenNew)          );
      ASM.CS2( add,l  ,  ASM.i(16+e^.attr^.OpenNew.nofLens),ASM.R(esp) ); 
     | 124 :
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 124/1878 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SystemNew');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.C1 ( pushl  ,  ASM.R(RegAlloc.allocation[1].op[1])             );
      ASM.CS2( lea,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(RegAlloc.allocation[1].op[1])  );
      ASM.C1 ( pushl  ,  ASM.R(RegAlloc.allocation[1].op[1])             );
      ASM.C1 ( call   ,  ASM.L(LAB.SystemNew) );
      ASM.CS2( add,l  ,  ASM.i(8),ASM.R(esp)      ); 
     | 125 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 125/1886 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Getreg');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 IF (ASM.MIN_CodeRegTabRange<=e^.attr^.Getreg.regcoding) & (e^.attr^.Getreg.regcoding<=ASM.MAX_CodeRegTabRange) THEN
         IF e^.attr^.Getreg.dstSize>4 THEN
            sz:=l;
         ELSE 
            sz:=ASM.SizeTab[e^.attr^.Getreg.dstSize]; 
         END;
         reg:=ASM.CodeRegTab[e^.attr^.Getreg.regcoding]; 
      END;

      CASE e^.attr^.Getreg.regcoding OF

      |ASM.codeEAX..ASM.codeEDX: 
         ASM.CS2   ( mov,sz  ,  ASM.R(ASM.SizedRegTab[reg,sz]),ASM.Loc(AT0.Memory.loc) );    

      |ASM.codeESI,ASM.codeEDI:
         IF sz=b THEN
            ASM.CS2( mov,l   ,  ASM.R(reg),ASM.R(RegAlloc.allocation[1].scr[1])                         ); 
            ASM.CS2( mov,b   ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].scr[1],b]),ASM.Loc(AT0.Memory.loc)  );    
         ELSE 
            ASM.CS2( mov,sz  ,  ASM.R(ASM.SizedRegTab[reg,sz]),ASM.Loc(AT0.Memory.loc) );    
         END;

      |ASM.codeEBP,ASM.codeESP:
         IF sz#l THEN
            ASM.CS2( mov,l   ,  ASM.R(reg),ASM.R(RegAlloc.allocation[1].scr[1])                         ); 
            ASM.CS2( mov,sz  ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].scr[1],sz]),ASM.Loc(AT0.Memory.loc) );    
         ELSE 
            ASM.CS2( mov,l   ,  ASM.R(reg),ASM.Loc(AT0.Memory.loc)                     );    
         END;

      |ASM.codeEFLAGS: 
         ASM.C0    ( pushf                                            );
         ASM.C1    ( popl    ,  ASM.R(RegAlloc.allocation[1].scr[1])                                );
         ASM.CS2   ( mov,sz  ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].scr[1],sz]),ASM.Loc(AT0.Memory.loc) );    

      |ASM.codeST0..ASM.codeST7:
         IF reg#st THEN
            ASM.C1 ( fxch    ,  ASM.R(reg)                                );
         END;
         IF e^.attr^.Getreg.dstSize=8 THEN
            ASM.CS1( fst,l   ,  ASM.Loc(AT0.Memory.loc)                            );
         ELSIF e^.attr^.Getreg.dstSize=4 THEN
            ASM.CS1( fst,s   ,  ASM.Loc(AT0.Memory.loc)                            );
         ELSE
            ASM.CS2( sub,l   ,  ASM.i(4),ASM.R(esp)                           );
            ASM.CS1( fst,s   ,  ASM.B(esp)                                );
            ASM.C1 ( popl    ,  ASM.R(RegAlloc.allocation[1].scr[1])                                );
            ASM.CS2( mov,sz  ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].scr[1],sz]),ASM.Loc(AT0.Memory.loc) );    
         END;
         IF reg#st THEN
            ASM.C1 ( fxch    ,  ASM.R(reg)                                );
         END;
      ELSE 
      END; 
     | 126 :
  EmitNtReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 126/1944 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Putreg');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 IF (ASM.MIN_CodeRegTabRange<=e^.attr^.Putreg.regcoding) & (e^.attr^.Putreg.regcoding<=ASM.MAX_CodeRegTabRange) THEN
         reg:=ASM.CodeRegTab[e^.attr^.Putreg.regcoding]; 
      END;

      CASE e^.attr^.Putreg.regcoding OF

      |ASM.codeEAX..ASM.codeESP: 
         CASE RegAlloc.allocation[1].op[1]OF
         |ah,bh,ch,dh: ASM.CS2   ( ror,l    ,  ASM.i(8),ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l])   );
                       IF ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l]#reg THEN
                          ASM.CS2( mov,l    ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l]),ASM.R(reg) ); 
                       END;
                       ASM.CS2   ( rol,l    ,  ASM.i(8),ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l])   );
         ELSE          IF ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l]#reg THEN
                          ASM.CS2( mov,l    ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l]),ASM.R(reg) ); 
                       END;
         END;
         CASE e^.son[1]^.gcg^.Reg.size OF
         |b: ASM.CS2             ( and,l    ,  ASM.x(0FFH),ASM.R(reg)                 );
         |w: ASM.CS2             ( and,l    ,  ASM.x(0FFFFH),ASM.R(reg)               );
         ELSE
         END;

      |ASM.codeEFLAGS:
         ASM.C1                  ( pushl    ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l])        ); 
         CASE e^.son[1]^.gcg^.Reg.size OF
         |b: ASM.CS2             ( and,l    ,  ASM.x(0FFH),ASM.B(esp)                 );
         |w: ASM.CS2             ( and,l    ,  ASM.x(0FFFFH),ASM.B(esp)               );
         ELSE
         END;
         ASM.C0                  ( popf                                       );

      |ASM.codeST0..ASM.codeST7:
         CASE RegAlloc.allocation[1].op[1]OF
         |ah,bh,ch,dh: ASM.CS2   ( ror,l    ,  ASM.i(8),ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l])   );
                       ASM.C1    ( pushl    ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l])        ); 
                       ASM.CS2   ( rol,l    ,  ASM.i(8),ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l])   );
         ELSE          ASM.C1    ( pushl    ,  ASM.R(ASM.SizedRegTab[RegAlloc.allocation[1].op[1],l])        ); 
         END;
         CASE e^.son[1]^.gcg^.Reg.size OF
         |b: ASM.CS2             ( and,l    ,  ASM.x(0FFH),ASM.B(esp)                 );
         |w: ASM.CS2             ( and,l    ,  ASM.x(0FFFFH),ASM.B(esp)               );
         ELSE
         END;
         IF reg#st THEN	         
            ASM.C1               ( fxch     ,  ASM.R(reg)                         );
         END;
         ASM.C0                  ( fdecstp                                    );
         ASM.CS1                 ( fld,s    ,  ASM.B(esp)                         );
         IF reg#st THEN	         
            ASM.C1               ( fxch     ,  ASM.R(reg)                         );
         END;
         ASM.CS2                 ( add,l    ,  ASM.i(4),ASM.R(esp)                    );

      ELSE 
      END; 
     | 127 :
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 127/2002 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Putreg');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 IF (ASM.MIN_CodeRegTabRange<=e^.attr^.Putreg.regcoding) & (e^.attr^.Putreg.regcoding<=ASM.MAX_CodeRegTabRange) THEN
         reg:=ASM.CodeRegTab[e^.attr^.Putreg.regcoding]; 
         sz:=ASM.RegSizeTab[reg]; 
      END;

      CASE e^.attr^.Putreg.regcoding OF

      |ASM.codeEAX..ASM.codeEBP: 
         ASM.CS2   ( sub,l    ,  ASM.i(4),ASM.R(esp)   );
         NDP.CS1   ( fstp,s   ,  ASM.B(esp)        );
         IF sz=l THEN
            ASM.C1 ( popl     ,  ASM.R(reg)        );
         ELSE
            ASM.CS2( mov,sz   ,  ASM.B(esp),ASM.R(reg) );
            ASM.CS2( add,l    ,  ASM.i(4),ASM.R(esp)   );
         END;

      |ASM.codeESP:
         ASM.CS2   ( sub,l    ,  ASM.i(4),ASM.R(esp)   );
         NDP.CS1   ( fstp,s   ,  ASM.B(esp)        );
         ASM.C1    ( popl     ,  ASM.R(RegAlloc.allocation[1].scr[1])        );
         ASM.CS2   ( mov,l    ,  ASM.R(RegAlloc.allocation[1].scr[1]),ASM.R(esp) );

      |ASM.codeEFLAGS:         
         ASM.CS2   ( sub,l    ,  ASM.i(4),ASM.R(esp)   );
         NDP.CS1   ( fstp,s   ,  ASM.B(esp)        );
         ASM.C0    ( popf                      );

      |ASM.codeST1..ASM.codeST7:
         ASM.C1    ( fst      ,  ASM.R(reg)        );

      ELSE 
      END; 
     | 128 :
  EmitNtLReg(e^.son[1],nest+1,AT0 ); 
  EmitNtLReg(e^.son[2],nest+1,AT1 ); 
  EmitNtLReg(e^.son[3],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 128/2039 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Move');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,l   ,  ASM.R(ecx),ASM.R(eax)       ); 
      ASM.CS2( shr,l   ,  ASM.i(2),ASM.R(ecx)         ); 
      ASM.C0 ( cld                            ); 
      ASM.C0 ( repz                           ); 
      ASM.CS0( movs,l                         ); 

      ASM.CS2( test,l  ,  ASM.i(2),ASM.R(eax)         );
      ASM.C1 ( jz      ,  ASM.L(LAB.New(label1))  );
      ASM.CS0( movs,w                         ); 
      ASM.Label(label1); 

      ASM.CS2( test,l  ,  ASM.i(1),ASM.R(eax)         );
      ASM.C1 ( jz      ,  ASM.L(LAB.New(label2))  );
      ASM.CS0( movs,b                         ); 
      ASM.Label(label2); 
     | 207 :
  EmitNtMemory(e^.son[1]^.son[1]^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[1]^.son[2]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 207/2488 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' StrCopy');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 IF e^.son[1]^.son[2]^.attr^.ImplicifyConst.len<e^.son[1]^.son[1]^.attr^.ImplicifyConst.len THEN e^.son[1]^.son[1]^.attr^.ImplicifyConst.len:=e^.son[1]^.son[2]^.attr^.ImplicifyConst.len; END;

      CASE e^.son[1]^.son[1]^.attr^.ImplicifyConst.len OF
      |0:  ;

      |1:  ASM.CS2( mov,b   ,  ASM.i(0),ASM.Loc(AT1.Memory.loc)     ); 

      |2:  ASM.CS2( mov,w   ,  ASM.Loc(AT0.Memory.loc),ASM.R(ax)    ); 
           ASM.CS2( xor,b   ,  ASM.R(ah),ASM.R(ah)           ); 
           ASM.CS2( mov,w   ,  ASM.R(ax),ASM.Loc(AT1.Memory.loc)    );

      |3:  ASM.CS2( mov,w   ,  ASM.Loc(AT0.Memory.loc),ASM.R(ax)    ); 
           ASM.CS2( mov,w   ,  ASM.R(ax),ASM.Loc(AT1.Memory.loc)    ); 
           INC(AT1.Memory.loc.ofs,2);
           ASM.CS2( mov,b   ,  ASM.i(0),ASM.Loc(AT1.Memory.loc)     );

      |4:  ASM.CS2( mov,l   ,  ASM.Loc(AT0.Memory.loc),ASM.R(eax)   ); 
           ASM.CS2( mov,l   ,  ASM.R(eax),ASM.Loc(AT1.Memory.loc)   ); 
           INC(AT1.Memory.loc.ofs,3);
           ASM.CS2( mov,b   ,  ASM.i(0),ASM.Loc(AT1.Memory.loc)     ); 

      ELSE ASM.CS2( mov,l   ,  ASM.i(e^.son[1]^.son[1]^.attr^.ImplicifyConst.len-1),ASM.R(ecx)     ); 
           ASM.CS2( lea,l   ,  ASM.Loc(AT0.Memory.loc),ASM.R(esi)   ); 
           ASM.CS2( lea,l   ,  ASM.Loc(AT1.Memory.loc),ASM.R(edi)   ); 

           ASM.Label(LAB.New(label1));               
           ASM.CS0( lods,b                           ); 
           ASM.CS0( stos,b                           ); 
           ASM.CS2( test,b  ,  ASM.R(al),ASM.R(al)           ); 
           ASM.C1 ( loopnz  ,  ASM.L(label1)             );
           ASM.C1 ( jz      ,  ASM.L(LAB.New(label2))    );
           ASM.CS2( mov,b   ,  ASM.i(0),ASM.B(edi)           );
           ASM.Label(label2); 
      END; 
     | 241 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 241/3021 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Excl');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 set:={0..31}; EXCL(set,e^.son[2]^.attr^.LongintConst.val); 
      ASM.CS2( and,l  ,  ASM.x(SYSTEM.VAL(LONGINT,set)),ASM.Loc(AT0.Memory.loc) ); 
     | 242 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 242/3026 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' Incl');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 set:={}; INCL(set,e^.son[2]^.attr^.LongintConst.val); 
      ASM.CS2( or,l  ,  ASM.x(SYSTEM.VAL(LONGINT,set)),ASM.Loc(AT0.Memory.loc) ); 
     | 298 :
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
  EmitNtAVar(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 298/3302 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.tmpreg:=RegAlloc.allocation[1].scr[1]; 
      ASM.CS1( e^.son[2]^.attr^.MonOper.code,e^.son[2]^.son[1]^.attr^.ContentOf.size  ,  ASM.Variable(e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var) ); 
     | 299 :
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtAVar(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 299/3313 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var.tmpreg:=RegAlloc.allocation[1].scr[1]; 
      ASM.CS2( shl,e^.son[2]^.son[2]^.attr^.ContentOf.size  ,  ASM.i(e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var.log2),ASM.Variable(e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var) ); 
     | 300 :
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
  EmitNtAVar(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 300/3313 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.tmpreg:=RegAlloc.allocation[1].scr[1]; 
      ASM.CS2( shl,e^.son[2]^.son[1]^.attr^.ContentOf.size  ,  ASM.i(e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.log2),ASM.Variable(e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var) ); 
     | 301 :
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
  EmitNtARegAImm(e^.son[2]^.son[1],nest+1,AT1 ); 
  EmitNtAVar(e^.son[2]^.son[2]^.son[1],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 301/3324 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var.tmpreg:=RegAlloc.allocation[1].scr[1]; 
      ASM.CS2( e^.son[2]^.attr^.SymDyOper.code,e^.son[2]^.son[2]^.attr^.ContentOf.size  ,  ASM.Operand(AT1.ARegAImm.oper),ASM.Variable(e^.son[2]^.son[2]^.son[1]^.gcg^.AVar.var) ); 
     | 302 :
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
  EmitNtAVar(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtARegAImm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 302/3324 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.tmpreg:=RegAlloc.allocation[1].scr[1]; 
      ASM.CS2( e^.son[2]^.attr^.SymDyOper.code,e^.son[2]^.son[1]^.attr^.ContentOf.size  ,  ASM.Operand(AT2.ARegAImm.oper),ASM.Variable(e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var) ); 
     | 303 :
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
  EmitNtAVar(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtARegAImm(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 303/3336 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.tmpreg:=RegAlloc.allocation[1].scr[1]; 
      ASM.CS2( sub,e^.son[2]^.son[1]^.attr^.ContentOf.size  ,  ASM.Operand(AT2.ARegAImm.oper),ASM.Variable(e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var) ); 
     | 304 :
  EmitNtAVar(e^.son[1],nest+1,AT0 ); 
  EmitNtAVar(e^.son[2]^.son[1]^.son[1],nest+1,AT1 ); 
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 304/3348 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' SimpleAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.tmpreg:=RegAlloc.allocation[1].scr[1]; 
      ASM.CS2( sar,e^.son[2]^.son[1]^.attr^.ContentOf.size  ,  ASM.i(e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var.log2),ASM.Variable(e^.son[2]^.son[1]^.son[1]^.gcg^.AVar.var) ); 
     | 322 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtFXReg(e^.son[2],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 322/3407 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' FloatAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 NDP.CS1( fstp,e^.attr^.FloatAssignment.size  ,  ASM.Loc(AT0.Memory.loc) ); 
     | 326 :
  EmitNtFXReg(e^.son[1],nest+1,AT0 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 326/3429 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' FloatFuncReturn');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2( mov,l  ,  ASM.R(ebp),ASM.R(esp) ); 
      ASM.C1 ( popl   ,  ASM.R(ebp)        );
      ASM.C0 ( ret                     ); 
     | 347 :
  EmitNtMemory(e^.son[1],nest+1,AT0 ); 
  EmitNtMemory(e^.son[2]^.son[1],nest+1,AT1 ); 
    IF (RegAlloc.allocation [1]. num>0) THEN 
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN 
       WriteNest (nest);
       InOut.WriteString ('Rule 347/3582 Cost=');
       InOut.WriteInt    (e^.gcg^.stmtcost,1);
       InOut.WriteString (' FloatAssignment');
       InOut.WriteLn;
       WriteNest (nest); 
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; InOut.WriteLn; 
       WriteNest (nest); 
       RegAlloc.PrintAllocation (1); InOut.WriteLn;
    END;
 ASM.CS2   ( mov,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(RegAlloc.allocation[1].scr[1]) ); 
      ASM.CS2   ( mov,l  ,  ASM.R(RegAlloc.allocation[1].scr[1]),ASM.Loc(AT0.Memory.loc) ); 
      IF e^.attr^.FloatAssignment.size=l THEN
         INC(AT1.Memory.loc.ofs,4); INC(AT0.Memory.loc.ofs,4);
         ASM.CS2( mov,l  ,  ASM.Loc(AT1.Memory.loc),ASM.R(RegAlloc.allocation[1].scr[1]) ); 
         ASM.CS2( mov,l  ,  ASM.R(RegAlloc.allocation[1].scr[1]),ASM.Loc(AT0.Memory.loc) ); 
      END; 
    END;
  END;
END EmitStatement;

PROCEDURE EmitInstruction* (e : IR.Expression);
BEGIN
   IF IR.OptEmitIR THEN IR.PrintExpression (e); END;
(******* empty insertion IpEmitI1 *******)
      localavail[0] := { (ConsBase.Regal)-0,  (ConsBase.Regah)-0,  (ConsBase.Regbl)-0,  (ConsBase.Regbh)-0,  (ConsBase.Regcl)-0,  (ConsBase.Regch)-0,  (ConsBase.Regdl)-0,  (ConsBase.Regdh)-0,  (ConsBase.Regax)-0,  (ConsBase.Regbx)-0,  (ConsBase.Regcx)-0,  (ConsBase.Regdx)-0,  (ConsBase.Regsi)-0,  (ConsBase.Regdi)-0,  (ConsBase.Regeax)-0,  (ConsBase.Regebx)-0,  (ConsBase.Regecx)-0,  (ConsBase.Regedx)-0,  (ConsBase.Regesi)-0,  (ConsBase.Regedi)-0,  (ConsBase.Regebp)-0,  (ConsBase.Regesp)-0,  (ConsBase.Regst)-0,  (ConsBase.Regst1)-0,  (ConsBase.Regst2)-0,  (ConsBase.Regst3)-0,  (ConsBase.Regst4)-0,  (ConsBase.Regst5)-0,  (ConsBase.Regst6)-0,  (ConsBase.Regst7)-0};
   RegAlloc.RegAllo (e, localavail);
(******* empty insertion IpEmitI2 *******)
   EmitStatement (e);
END EmitInstruction;
BEGIN
  RegisterSetEmpty [0] := {};
(******* empty insertion IpEmitInit *******)
END Emit.


