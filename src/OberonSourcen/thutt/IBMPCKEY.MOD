MODULE IBMPCKey;
IMPORT SYSTEM, Kernel, DPMI, Modules, Display (* only for FrameMsg *), Fonts (* for Fnt variable *);

CONST
	ModuleName = "IBMPCKey";
	MMEquivScan = 3920H (* space *); (* MM equivalent scancode *)

CONST
	EAX = 0; ECX = 1; EDX = 2; EBX = 3; 
	ESP = 4; EBP = 5; ESI = 6; EDI = 7;

CONST
	Esc* = 1BX; SysRq* = 72X; (* Ctrl-SysRq *)

	(*
		The following codes CANNOT be generated by the hardware when meta 
		keystrokes are being generated.  If they are generated, then the ReadMeta
		procedure will not work.
	*)
	F1* = 0C8X;	F2* = 0C9X;	F3* = 0CAX;	F4* = 0CBX;	F5* = 0CCX;	F6* = 0CDX;
	F7* = 0CEX;	F8* = 0CFX;	F9* = 0D0X;	F10* = 0D1X;
	Home* = 0D2X; Up* = 0D3X; PgUp* = 0D4X; Left* = 0D5X; Right* = 0D6X; 
	End* = 0D7X; Down* = 0D8X; PgDn* = 0D9X; Ins* = 0DAX; Del* = 0DBX;
	F11* = 0DCX;	F12* = 0DEX;

	Nul* = 0X; CR* = 0DX; Tab* = 9X; BS* = 8X; Space* = 20X;
	GreySlash* = 02FX; GreyStar* = 037X; GreyMinus* = 4AX; GreyPlus* = 4EX;
	GreyEnter* = 04CX;

	(* Oberon German support (not implemented yet)
			CASE scan OF
			|	1EX: lch := 080X;	(*A diaeresis*)
    	|	xxx: lch := 083X;	(*a diaeresis*) 
    	|	xxx: lch := 086X;	(*a circumflex*) 
    	|	xxx: lch := 08BX;	(*a grave*) 
    	|	xxx: lch := 081X;	(*O diaeresis*)
    	|	xxx: lch := 082X;	(*U diaeresis*)
    	|	xxx: lch := 084X;	(*o diaeresis*) 
    	|	xxx: lch := 085X;	(*u diaeresis*) 
    	|	xxx: lch := 087X;	(*e circumflex*) 
    	|	xxx: lch := 088X;	(*i circumflex*) 
    	|	xxx: lch := 089X;	(*o circumflex*) 
    	|	xxx: lch := 08AX;	(*u circumflex*)
    	|	xxx: lch := 08CX;	(*e grave*)
    	|	xxx: lch := 08DX;	(*i grave*)
    	|	xxx: lch := 08EX;	(*o grave*) 
    	|	xxx: lch := 08FX;	(*u grave*) 
    	|	xxx: lch := 090X;	(*e acute*) 
    	|	xxx: lch := 091X;	(*e diaeresis*) 
    	|	xxx: lch := 092X;	(*i diaeresis*) 
    	|	xxx: lch := 093X;	(*c cedilla*) 
    	|	xxx: lch := 094X;	(*a acute*)
    	|	xxx: lch := 095X;	(*n tilde*) 
			|	xxx: lch := 0F4X;	(* init colors *)
			|	xxx: lch := 0EFX;	(* must be set in WriteKeys.Text *);
			|	xxx: lch := 0ACX;	(* BREAK *)
			|	xxx: lch := 0ADX;	(* SHIFT-BREAK *)
			|	53X:(* del *)				lch := 07FX;	(* delete *)
			|	49X:(* pgup *)			lch := 091X;	(* PrevScreen: NOSCRLL for Draw *)
			|	84X:(* ctrl-pgup*)	lch := 093X;	(* Ctrl-PrevScreen:CTRL-NOSCRLL for Draw *)
			|	3BX:(* F1 *)				lch := 0A4X;	(* Oberon.SETUP *)
			|	48X:(* up *)				lch := 0C1X;	(* up *)
			|	4BX:(* left *)			lch := 0C4X;	(* left *)
			|	4DX:(* right *)			lch := 0C3X;	(* right *)
			|	50X:(* down *)			lch := 0C2X;	(* down *)
			|	71X:(* alt-F10 *)		lch := 0F1X; (* display on *)
			|	8BX:(* alt-F11 *)		lch := 0F2X; (* display off *)
			|	8CX:(* alt-F12 *)		lch := 0F3X; (* display inverse *)
			ELSE lch := 0X;
			END;
	*)

CONST (* See HelpPC *)
	RShift* = 0; LShift* = 1; Ctrl* = 2; Alt* = 3;
	ScrollLock* = 4; NumLock* = 5; CapsLock* = 6; Insert* = 7;
	LCtrl* = 8; LAlt* = 9; RCtrl* = 10; RAlt* = 11; 
	(* 12..14 are repeats of 4..6, and masked off *) SysReq* = 15;
	Extended* = 31; (* keypress with 0E0X as first byte *)

TYPE
	OrigKbdDesc = RECORD ofs : LONGINT; sel : LONGINT; END;
	InfoDesc = RECORD shiftstate : SET; ch, scancode : CHAR; END;

	MetaInputMsg* = RECORD (Display.FrameMsg)
		id* : INTEGER;
		code* : CHAR;
		shifts* : SET;
		fnt*: Fonts.Font;
		col*, voff*: SHORTINT
	END;

VAR
	base : ARRAY 256 OF CHAR; (* unshifted value for meta keys (based on scan codes) *)
	OrigKbd : OrigKbdDesc;
	kbd : ARRAY 32 OF InfoDesc;
	head, tail : INTEGER;
	MMEquiv* : BOOLEAN; (* TRUE if (MMEquivScan + Alt) is pressed (volatile) *)

PROCEDURE - KeyboardInt 0CDH, 16H;
PROCEDURE - DosInt 0CDH, 21H;

PROCEDURE IsMeta*() : BOOLEAN;
VAR shifts : SET; ch : CHAR;
BEGIN
	shifts := kbd[head].shiftstate; ch := kbd[head].ch;
	RETURN (ch = 0E0X) OR (ch = 0X) OR (LAlt IN shifts) OR (RAlt IN shifts);
END IsMeta;

PROCEDURE Available*(): INTEGER;
BEGIN RETURN (tail - head) MOD LEN(kbd);
END Available;

(*
	When a meta keystroke occurs, it is mapped back onto a 'base' keyboard
	value.  It is the responsibility of the application to check the shifts
	to determine what type of meta has occurred.

	For example, Alt-Ctrl-A will be changed into code='a', and the shifts
	will be set to include Alt and Ctrl.  The function keys, and special
	keys that already are meta keystrokes (pgup, etc.) are mapped onto 
	unused character codes.
*)
PROCEDURE ReadMeta*(VAR code : CHAR; VAR shift : SET);
BEGIN
	IF head # tail THEN
		code := base[ORD(kbd[head].scancode)]; shift := kbd[head].shiftstate;
		head := (head + 1) MOD LEN(kbd);
		IF (LCtrl IN shift) OR (RCtrl IN shift) THEN INCL(shift, Ctrl); END;
		IF (LAlt IN shift) OR (RAlt IN shift) THEN INCL(shift, Alt); END;
	END;
END ReadMeta;

PROCEDURE Read*(VAR ch: CHAR);
VAR lch, scan : CHAR;
BEGIN 
	IF head # tail THEN
		lch := kbd[head].ch;
 		CASE lch OF
 		|	08X: lch := 7FX; (* delete *)
 		ELSE
 		END;
		head := (head + 1) MOD LEN(kbd);
	ELSE lch := 0X; (* not executed -- Read valid iff Available() > 0 *)
	END;
	ch := lch;
END Read;

PROCEDURE - LoadSelectors 66H, 0B8H, 0FH, 00H, 66H, 8EH, 0D8H,
													66H, 8EH, 0C0H, 66H, 8EH, 0E0H, 
													66H, 8EH, 0E8H, 66H, 0B8H, 17H, 00H,
													0FAH, 66H, 8EH, 0D0H, 0FBH;

PROCEDURE Halt;
BEGIN LoadSelectors; SYSTEM.PUTREG(ESP, Kernel.StackOrg); HALT(24);
END Halt;

PROCEDURE - GetEIP  8BH, 1CH, 24H;
PROCEDURE - GetCS  66H, 8BH, 4CH, 24H, 04H;
PROCEDURE - LoadCXWithCS 8CH, 0C9H;
PROCEDURE - LoadDS 66H, 0B8H, 0FH, 00H, 8EH, 0D8H; (* MOV AX, 0FH (data selector for Oberon); MOV DS, AX *)
PROCEDURE - LEAVE 0C9H;
PROCEDURE - PUSHAD 60H; 
PROCEDURE - POPAD 61H; 
PROCEDURE - IRET 0FBH, 0CFH; (* STI, IRET *)
PROCEDURE - ENTER 0C8H, 08H, 00H, 00H;
PROCEDURE - PUSHF 9CH; 
PROCEDURE - CallOriginal 9AH, 069H, 019H, 029H, 012H, 097H, 097H;
PROCEDURE - ModifyEIP 89H, 1CH, 24H;
PROCEDURE - ModifyCS 66H, 89H, 4CH, 24H, 04H;
PROCEDURE - LoadDSCommon 66H, 0BBH, 47H, 00H, 66H, 8EH, 0DBH; (* mov bx, 47h; mov ds, bx *)

PROCEDURE + KeyboardHandler;
VAR k, v : SHORTINT; p : PROCEDURE; cbreak : BOOLEAN; flags : SET; key : LONGINT; ax : INTEGER;
BEGIN
	LEAVE; PUSHAD; ENTER; LoadDS;
	PUSHF; CallOriginal; (* this code is modified by GetKeyboard! *)
	LoadDSCommon; SYSTEM.GET(0, cbreak); SYSTEM.PUT(0, SYSTEM.VAL(SHORTINT, 0)); LoadDS;
	IF cbreak THEN 
		head := 0; tail := 0;
		LEAVE; POPAD; p := Halt; SYSTEM.PUTREG(EBX, p); ModifyEIP; LoadCXWithCS; ModifyCS;
	ELSE
		SYSTEM.PUTREG(EAX, 1100H); KeyboardInt; (* keyboard buffer status; ~ZF{CC(4)} OR (AX = 0) = no key waiting  *)
		SYSTEM.GETREG(EAX, ax);
		IF ~SYSTEM.CC(4) & (ax # 0) (* NZ & ax # 0 *) THEN
			SYSTEM.GETREG(EAX, key); key := SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, key) - {16..31});
			SYSTEM.PUTREG(EAX, 1200H); KeyboardInt; SYSTEM.GETREG(EAX, flags); (* Read keyboard flags *)

			IF ((LAlt IN flags) OR (RAlt IN flags)) & (key = MMEquivScan) THEN
				SYSTEM.PUTREG(EAX, 1000H); KeyboardInt; SYSTEM.GETREG(EAX, key); MMEquiv := TRUE; (* get key press *)
			ELSE
				MMEquiv := FALSE;
				IF head # (tail + 1) MOD LEN(kbd) THEN (* not full *)
					SYSTEM.PUTREG(EAX, 1000H); KeyboardInt; SYSTEM.GETREG(EAX, key);
					key := SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, key) - {16..31});
					kbd[tail].ch := CHR(key MOD 100H); kbd[tail].scancode := CHR(key DIV 100H);
					flags := flags * {RShift..RAlt, SysReq};
					IF (CHR(key MOD 100H) = 0E0X) OR (CHR(key DIV 100H) = 0E0X) THEN INCL(flags, Extended); END;
					kbd[tail].shiftstate := flags;
					tail := (tail + 1) MOD LEN(kbd);
				END;
			END;
		ELSE MMEquiv := FALSE;
		END;
		LEAVE; POPAD; 
	END;
	IRET;
END KeyboardHandler;

PROCEDURE RestoreKeyboard;
VAR CS, err : INTEGER; this : Modules.Module; desc : DPMI.SegmentDesc;
BEGIN
	this := Modules.ThisMod(ModuleName);
	IF this # NIL THEN
		LoadCXWithCS; SYSTEM.GETREG(ECX, CS); DPMI.DecodeSelector(CS, desc);
		DPMI.UnlockRegion(desc.base + this.BB, this.size, err); (* Hardware interrupt handlers are locked *)
		DPMI.SetPMInterrupt(9, OrigKbd.sel, OrigKbd.ofs, err);
		IF err = 0 THEN Kernel.DebugWriteString('Keyboard restored'); Kernel.DebugNL;
		ELSE Kernel.DebugWriteString('Keyboard not restored!'); Kernel.DebugNL;
		END;
	ELSE Kernel.DebugWriteString('No keyboard to restore');
	END;
END RestoreKeyboard;

PROCEDURE GetKeyboard;
VAR 
	err, kbdintsel, CS : INTEGER; 
	ofs : LONGINT; 
	desc : DPMI.SegmentDesc; 
	handler : PROCEDURE;
	this : Modules.Module;

	PROCEDURE ModifyCode(adr : LONGINT; o : SYSTEM.BYTE);
	VAR v, i : LONGINT; d : SYSTEM.BYTE;
	BEGIN
		i := 0;
		LOOP
			SYSTEM.GET(adr, d);
			(* JMP & CallOriginal opcodes *)
			IF d = o THEN
				SYSTEM.GET(adr + 1, v);
				IF v = 12291969H THEN (* a special date *)
					INC(adr);
					SYSTEM.MOVE(SYSTEM.ADR(OrigKbd.ofs), adr, SIZE(LONGINT));
					SYSTEM.MOVE(SYSTEM.ADR(OrigKbd.sel), adr + 4, SIZE(INTEGER));
					Kernel.DebugWriteString('Keyboard trapped!');
					Kernel.DebugWriteHex(SYSTEM.VAL(SHORTINT, o)); Kernel.DebugNL;
					EXIT;
				END;
			END;
			INC(adr);
			INC(i); IF i > 5000 THEN EXIT; END; (* failsafe in case it is not found *)
		END;
	END ModifyCode;

BEGIN
	this := Modules.ThisMod(ModuleName);
	IF this # NIL THEN
		LoadCXWithCS; SYSTEM.GETREG(ECX, CS); DPMI.DecodeSelector(CS, desc);
		DPMI.LockRegion(desc.base + this.BB, this.size, err); (* Hardware interrupt handlers must be locked *)

		handler := KeyboardHandler; 
		DPMI.GetPMInterrupt(9, OrigKbd.sel, OrigKbd.ofs);
		DPMI.SetPMInterrupt(9, CS, SYSTEM.VAL(LONGINT, handler), err);

		IF err = 0 THEN
			(* modify code in the interrupt handler to point at the original INT 9 handler *)
			ModifyCode(SYSTEM.VAL(LONGINT, handler), 09AX); (* modify call code *)
		ELSE
			Kernel.DebugWriteString('Keyboard not trapped!'); Kernel.DebugNL;
		END;
	ELSE Kernel.DebugWriteString('Keyboard not installed');
	END;
END GetKeyboard;

PROCEDURE InitBaseStates;
VAR i : INTEGER;
BEGIN
	i := 0; WHILE i < LEN(base) DO base[i] := Nul; INC(i); END;

	(*base[000] := Nul;*)			base[001] :=  Esc;	base[002] := '1';				base[003] := '2';
	base[004] := '3';				base[005] := '4';		base[006] := '5';				base[007] := '6';
	base[008] := '7';				base[009] := '8';		base[010] := '9';				base[011] := '0';
	base[012] := '-';				base[013] := '=';		base[014] :=  BS;				base[015] := Tab;
	base[016] := 'q';				base[017] := 'w';		base[018] := 'e';				base[019] := 'r';
	base[020] := 't';				base[021] := 'y';		base[022] := 'u';				base[023] := 'i';
	base[024] := 'o';				base[025] := 'p';		base[026] := '[';				base[027] := ']';
	base[028] :=  CR;				(*base[029] := Nul;*)	base[030] := 'a';				base[031] := 's';
	base[032] := 'd';				base[033] := 'f';		base[034] := 'g';				base[035] := 'h';
	base[036] := 'j';				base[037] := 'k';		base[038] := 'l';				base[039] := ';';
	base[040] := "'";				base[041] := '`';		(*base[042] := Nul;*)			base[043] := '\';
	base[044] := 'z';				base[045] := 'x';		base[046] := 'c';				base[047] := 'v';
	base[048] := 'b';				base[049] := 'n';		base[050] := 'm';				base[051] := ',';
	base[052] := '.';				base[053] := '/';		(*base[054] := Nul;*)			base[055] := GreyStar;
	(*base[056] := Nul;*)			base[057] := Space;	(*base[058] := Nul;*)			base[059] :=   F1;
	base[060] :=   F2;			base[061] :=   F3;	base[062] :=   F4;			base[063] :=   F5;
	base[064] :=   F6;			base[065] :=   F7;	base[066] :=   F8;			base[067] :=   F9;
	base[068] :=  F10;			(*base[069] := Nul;*)	(*base[070] := Nul;*)			base[071] := Home;
	base[072] :=   Up;			base[073] := PgUp;	base[074] := GreyMinus;	base[075] := Left;
	base[076] := GreyEnter;	base[077] := Right;	base[078] := GreyPlus;	base[079] :=  End;
	base[080] := Down;			base[081] := PgDn;	base[082] :=  Ins;			base[083] :=  Del;
	(*base[084] := Nul;*)			(*base[085] := Nul;*)	(*base[086] := Nul;*)			(*base[087] := Nul;*)
	(*base[088] := Nul;*)			(*base[089] := Nul;*)	(*base[090] := Nul;*)			(*base[091] := Nul;*)
	(*base[092] := Nul;*)			(*base[093] := Nul;*)	(*base[094] := Nul;*)			(*base[095] := Nul;*)
	(*base[096] := Nul;*)			(*base[097] := Nul;*)	(*base[098] := Nul;*)			(*base[099] := Nul;*)
	(*base[100] := Nul;*)			(*base[101] := Nul;*)	(*base[102] := Nul;*)			(*base[103] := Nul;*)
	base[104] :=   F1;			base[105] :=   F2;	base[106] :=   F3;			base[107] :=   F4;
	base[108] :=   F5;			base[109] :=   F6;	base[110] :=   F7;			base[111] :=   F8;
	base[112] :=   F9;			base[113] :=  F10;	base[114] := SysRq;			base[115] := Left;
	base[116] := Right;			base[117] :=  End;	base[118] := PgDn;			base[119] := Home;
	base[120] := '1';				base[121] := '2';		base[122] := '3';				base[123] := '4';
	base[124] := '5';				base[125] := '6';		base[126] := '7';				base[127] := '8';
	base[128] := '9';				base[129] := '0';		base[130] := '-';				base[131] := '=';
	base[132] := PgUp;			base[133] :=  F11;	base[134] :=  F12;			(*base[135] := Nul;*)
	(*base[136] := Nul;*)			(*base[137] := Nul;*)	(*base[138] := Nul;*)			base[139] :=  F11;
	base[140] :=  F12;			base[141] :=   Up;	base[142] := '-';				(*base[143] := Nul;*)
	base[144] := '+';				base[145] := Down;	base[146] :=  Ins;			base[147] :=  Del;
	(*base[148] := Nul;*)			base[149] := '/';		base[150] := '*';				base[151] := Home;
	base[152] :=   Up;			base[153] := PgUp;	base[154] := PgDn;			base[155] := Left;
	(*base[156] := Nul;*)			base[157] := Right;	(*base[158] := Nul;*)			base[159] :=  End;
	base[160] := Down;			(*base[161] := Nul;*)	base[162] :=  Ins;			base[163] :=  Del;
	base[164] := GreySlash;	base[165] :=  Tab;	base[166] :=   CR;			(*base[167] := Nul;*)
	(*base[168] := Nul;*)			(*base[169] := Nul;*)	(*base[170] := Nul;*)			(*base[171] := Nul;*)
	(*base[172] := Nul;*)			(*base[173] := Nul;*)	(*base[174] := Nul;*)			(*base[175] := Nul;*)
	(*base[176] := Nul;*)			(*base[177] := Nul;*)	(*base[178] := Nul;*)			(*base[179] := Nul;*)
	(*base[180] := Nul;*)			(*base[181] := Nul;*)	(*base[182] := Nul;*)			(*base[183] := Nul;*)
	(*base[184] := Nul;*)			(*base[185] := Nul;*)	(*base[186] := Nul;*)			(*base[187] := Nul;*)
	(*base[188] := Nul;*)			(*base[189] := Nul;*)	(*base[190] := Nul;*)			(*base[191] := Nul;*)
	(*base[192] := Nul;*)			(*base[193] := Nul;*)	(*base[194] := Nul;*)			(*base[195] := Nul;*)
	(*base[196] := Nul;*)			(*base[197] := Nul;*)	(*base[198] := Nul;*)			(*base[199] := Nul;*)
	(*base[200] := Nul;*)			(*base[201] := Nul;*)	(*base[202] := Nul;*)			(*base[203] := Nul;*)
	(*base[204] := Nul;*)			(*base[205] := Nul;*)	(*base[206] := Nul;*)			(*base[207] := Nul;*)
	(*base[208] := Nul;*)			(*base[209] := Nul;*)	(*base[210] := Nul;*)			(*base[211] := Nul;*)
	(*base[212] := Nul;*)			(*base[213] := Nul;*)	(*base[214] := Nul;*)			(*base[215] := Nul;*)
	(*base[216] := Nul;*)			(*base[217] := Nul;*)	(*base[218] := Nul;*)			(*base[219] := Nul;*)
	(*base[220] := Nul;*)			(*base[221] := Nul;*)	(*base[222] := Nul;*)			(*base[223] := Nul;*)
	base[224] :=   CR;			(*base[225] := Nul;*)	(*base[226] := Nul;*)			(*base[227] := Nul;*)
	(*base[228] := Nul;*)			(*base[229] := Nul;*)	(*base[230] := Nul;*)			(*base[231] := Nul;*)
	(*base[232] := Nul;*)			(*base[233] := Nul;*)	(*base[234] := Nul;*)			(*base[235] := Nul;*)
	(*base[236] := Nul;*)			(*base[237] := Nul;*)	(*base[238] := Nul;*)			(*base[239] := Nul;*)
	(*base[240] := Nul;*)			(*base[241] := Nul;*)	(*base[242] := Nul;*)			(*base[243] := Nul;*)
	(*base[244] := Nul;*)			(*base[245] := Nul;*)	(*base[246] := Nul;*)			(*base[247] := Nul;*)
	(*base[248] := Nul;*)			(*base[249] := Nul;*)	(*base[250] := Nul;*)			(*base[251] := Nul;*)
	(*base[252] := Nul;*)			(*base[253] := Nul;*)	(*base[254] := Nul;*)			(*base[255] := Nul;*)
END InitBaseStates;

PROCEDURE Init;
VAR t : Kernel.Terminator;
BEGIN
	GetKeyboard; MMEquiv := FALSE; head := 0; tail := 0;
	NEW(t); (* assume memory available *) t.proc := RestoreKeyboard; Kernel.RegisterTermination(t);
	InitBaseStates;
END Init;

BEGIN Init;
END IBMPCKey.
