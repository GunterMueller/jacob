MODULE EdiT; (* gri 5.9.90 / jt 10.9.90 / 28.10.91	this module shows how to extend the standard Oberon text editor by additional commands and a special message handler *)
	IMPORT		Display, Fonts, Viewers, Texts, TextFrames, MenuViewers, Input, Oberon, Files;	CONST		BS = 8X; HT = 9X; LF = 0AX; CR = 0DX;		Left = 0C4X; Right = 0C3X;		Menu = "System.Close  System.Copy  System.Grow  EdiT.Search  EdiT.Replace All  Edit.Store";	TYPE		EdiTMsg = RECORD(Display.FrameMsg)			text: Texts.Text;			beg, end: LONGINT;			time: LONGINT		END;	VAR		W: Texts.Writer;		search: RECORD time*: LONGINT; len*: INTEGER; buf*: ARRAY 128 OF CHAR; d: ARRAY 128 OF SHORTINT END; (* KMP search buffer *)		replace: RECORD time*: LONGINT; buf*: Texts.Buffer END; (* replace buffer *)	PROCEDURE Max (i, j: LONGINT): LONGINT;	BEGIN IF i >= j THEN RETURN i ELSE RETURN j END	END Max;	PROCEDURE FlushKB;		VAR ch: CHAR;	BEGIN WHILE Input.Available() > 0 DO Input.Read(ch) END	END FlushKB;		PROCEDURE BegOfLine(text: Texts.Text; pos: LONGINT): LONGINT;		VAR r: Texts.Reader; ch: CHAR;	BEGIN		LOOP			DEC(pos);			IF pos < 0 THEN RETURN 0 END;			Texts.OpenReader(r, text, pos); Texts.Read(r, ch);			IF ch = CR THEN RETURN pos+1 END		END	END BegOfLine;		PROCEDURE Select(text: Texts.Text; beg, end: LONGINT);		VAR msg: EdiTMsg;	BEGIN		msg.text := text; msg.beg := beg; msg.end := end; msg.time := Oberon.Time();		Viewers.Broadcast(msg)	END Select;		PROCEDURE Move(f: TextFrames.Frame; dx: INTEGER);		VAR text: Texts.Text; beg, end, time, pos: LONGINT; r: Texts.Reader; ch: CHAR;	BEGIN		Oberon.GetSelection(text, beg, end, time);		IF (time >= 0) & (f.text = text) THEN (* move selection *)			beg := BegOfLine(text, beg); pos := beg;			WHILE pos < end DO				Texts.OpenReader(r, text, pos); Texts.Read(r, ch);				IF dx < 0 THEN					IF (ch <= " ") & (ch # CR) THEN Texts.Delete(text, pos, pos+1); DEC(end) END				ELSE					IF (ch <= " ") & (ch # CR) THEN Texts.Write(W, ch) ELSE Texts.Write(W, HT) END; (* first char extension *)					Texts.Insert(text, pos, W.buf); INC(end); INC(pos)				END;				Texts.OpenReader(r, text, pos);				REPEAT Texts.Read(r, ch) UNTIL r.eot OR (ch = CR);				pos := Texts.Pos(r)			END;			Select(text, beg, pos)		ELSIF f.car > 0 THEN (* move caret *)			pos := f.carloc.pos+dx;			IF pos < 0 THEN pos := 0 ELSIF pos > f.text.len THEN pos := f.text.len END;			TextFrames.RemoveCaret(f);			TextFrames.SetCaret(f, pos)		END	END Move;		PROCEDURE BackSpace(f: TextFrames.Frame);		VAR r: Texts.Reader; ch: CHAR; pos: LONGINT;	BEGIN		pos := f.carloc.org-1; IF pos < 0 THEN pos := 0 END;		Texts.OpenReader(r, f.text, pos); Texts.Read(r, ch);		WHILE ~r.eot & (Texts.Pos(r) <= f.carloc.pos) DO (* search white space begin *)			IF ch > " " THEN pos := Texts.Pos(r) END;			Texts.Read(r, ch)		END;		IF pos < f.carloc.pos THEN			Texts.Delete(f.text, pos, f.carloc.pos);			TextFrames.SetCaret(f, pos)		END	END BackSpace;		PROCEDURE NewLine(f: TextFrames.Frame);		VAR r: Texts.Reader; n, car: LONGINT; ch: CHAR;	BEGIN		Texts.Write(W, CR); car := f.carloc.pos+1; Texts.OpenReader(r, f.text, f.carloc.org); Texts.Read(r, ch);		WHILE (Texts.Pos(r) <= f.carloc.pos) & (ch <= " ") DO Texts.Write(W, ch); INC(car); Texts.Read(r, ch) END;		Texts.Insert(f.text, f.carloc.pos, W.buf); TextFrames.SetCaret(f, car)	END NewLine;					PROCEDURE ShowPos(f: TextFrames.Frame; car: LONGINT);		VAR m: INTEGER;	BEGIN		IF f.car > 0 THEN TextFrames.RemoveCaret(f) END;		IF f.sel > 0 THEN TextFrames.RemoveSelection(f) END;		Oberon.RemoveMarks(f.X, f.Y, f.W, f.H); m := 200;		WHILE (car < f.org) OR (TextFrames.Pos(f, f.X+f.W, f.Y) < car) DO			TextFrames.Show(f, BegOfLine(f.text, car-m));			DEC(m, 20)		END;		TextFrames.SetCaret(f, car)	END ShowPos;			PROCEDURE KMPsearch(text: Texts.Text; beg: LONGINT): LONGINT;		VAR R: Texts.Reader; ch: CHAR; k: SHORTINT;	BEGIN		IF search.len > 0 THEN			Texts.OpenReader(R, text, beg); Texts.Read(R, ch);			k := 0;			WHILE ~R.eot DO				IF ch = search.buf[k] THEN k := k + 1;					IF k = search.len THEN RETURN Texts.Pos(R) - k + search.len					ELSE Texts.Read(R, ch)					END ;				ELSIF k = 0 THEN Texts.Read(R, ch)				ELSE k := k - search.d[k]				END			END		END;		RETURN -1	END KMPsearch;	PROCEDURE Check(text: Texts.Text; beg: LONGINT): BOOLEAN;		VAR r: Texts.Reader; ch: CHAR; i: INTEGER;	BEGIN		IF search.len > 0 THEN			Texts.OpenReader(r, text, beg); Texts.Read(r, ch); i := 0;			WHILE ~r.eot & (i < search.len) & (ch = search.buf[i]) DO Texts.Read(r, ch); INC(i) END;			RETURN i = search.len		ELSE RETURN FALSE		END	END Check;				PROCEDURE SetReplBuf;		VAR text: Texts.Text; beg, end, time: LONGINT;	BEGIN		Oberon.GetSelection(text, beg, end, time);		IF time > replace.time THEN			replace.time := time;			Texts.OpenBuf(replace.buf); Texts.Save(text, beg, end, replace.buf)		END	END SetReplBuf;		PROCEDURE ReplaceAndFind(text: Texts.Text; beg: LONGINT): LONGINT;		VAR end: LONGINT;	BEGIN		end := beg+replace.buf.len;		Texts.Delete(text, beg, beg+search.len);		IF replace.buf.len > 0 THEN Texts.Insert(text, beg, replace.buf); Texts.Save(text, beg, end, replace.buf) END;		RETURN KMPsearch(text, end)	END ReplaceAndFind;	PROCEDURE Scroll(F: TextFrames.Frame; X, Y: INTEGER);		VAR pos, i: LONGINT; keysum: SET;			R: Texts.Reader; ch: CHAR;	BEGIN		TextFrames.TrackLine(F, X, Y, pos, keysum);		IF (pos >= 0) & (keysum # {0, 1, 2}) THEN			IF 1 IN keysum THEN (* scroll back i lines *)				i := (F.Y + F.H - F.top - Oberon.Mouse.Y - 1) DIV F.lsp;				pos := F.org;				WHILE (i >= 0) & (pos > 0) DO DEC(pos);					Texts.OpenReader(R, F.text, pos); Texts.Read(R, ch);					IF ch = 0DX THEN DEC(i) END				END ;				IF i < 0 THEN INC(pos) END			END ;			TextFrames.RemoveCaret(F); TextFrames.RemoveSelection(F); Oberon.RemoveMarks(F.X, F.Y, F.W, F.H);			TextFrames.Show(F, pos)		END	END Scroll;	PROCEDURE Handle*(F: Display.Frame; VAR M: Display.FrameMsg);	BEGIN		WITH F: TextFrames.Frame DO			WITH M: Oberon.InputMsg DO				IF M.id = Oberon.consume THEN					IF M.ch = Left THEN Move(F, -1); FlushKB					ELSIF M.ch = Right THEN Move(F, 1); FlushKB					ELSIF F.car > 0 THEN (* caret set *)						IF M.ch = BS THEN BackSpace(F)						ELSIF M.ch = LF THEN NewLine(F)						ELSE TextFrames.Handle(F, M)						END					END				ELSIF (M.id = Oberon.track) & (2 IN M.keys) & (M.X < F.X + TextFrames.barW) THEN Scroll(F, M.X, M.Y)				ELSE TextFrames.Handle(F, M)				END			| M: EdiTMsg DO					IF (F.text = M.text) & (F.sel = 0) THEN TextFrames.SetSelection(F, M.beg, M.end); F.time := M.time END			ELSE				TextFrames.Handle(F, M)			END		END	END Handle;(* ------------------------------------- arguments ------------------------------------- *)	PROCEDURE Focus(): TextFrames.Frame;		VAR f: Display.Frame;	BEGIN		IF Oberon.FocusViewer.state > 1 THEN			f := Oberon.FocusViewer.dsc;			IF (f # NIL) & (f.next # NIL) & (f.next IS TextFrames.Frame) THEN RETURN f.next(TextFrames.Frame) END		END;		RETURN NIL	END Focus;(* ------------------------------------- commands ------------------------------------- *)	PROCEDURE Open*;			(* like Edit.Open, but installs the EdiT message handler *)		VAR par: Oberon.ParList;			T: Texts.Text;			S: Texts.Scanner;			V: Viewers.Viewer;			X, Y: INTEGER;			beg, end, time: LONGINT;	BEGIN		par := Oberon.Par;		Texts.OpenScanner(S, par.text, par.pos); Texts.Scan(S);		IF (S.class = Texts.Char) & (S.c = "^") OR (S.line # 0) THEN			Oberon.GetSelection(T, beg, end, time);			IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S) END		END;		IF S.class = Texts.Name THEN			Oberon.AllocateUserViewer(par.vwr.X, X, Y);			V := MenuViewers.New(				TextFrames.NewMenu(S.s, Menu),				TextFrames.NewText(TextFrames.Text(S.s), 0),				TextFrames.menuH,				X, Y);			V.dsc.next.handle := Handle		END	END Open;	PROCEDURE StoreAscii*;			(* store text as Ascii file; no backup *)		VAR par: Oberon.ParList;			V: Viewers.Viewer;			T: Texts.Text;			S: Texts.Scanner;			TF: TextFrames.Frame;			ch: CHAR;			beg, end, time, len: LONGINT;			R: Texts.Reader;			F: Files.File;			O: Files.Rider;	BEGIN		Texts.WriteString(W, "EdiT.StoreAscii ");		par := Oberon.Par; 		IF par.frame = par.vwr.dsc THEN			V := par.vwr; Texts.OpenScanner(S, V.dsc(TextFrames.Frame).text, 0)		ELSE V := Oberon.MarkedViewer(); Texts.OpenScanner(S, par.text, par.pos)		END;		Texts.Scan(S);		IF (S.class = Texts.Char) & (S.c = "^") THEN			Oberon.GetSelection(T, beg, end, time);			IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S) END		ELSIF (S.class = Texts.Char) & (S.c = "*") THEN Texts.OpenScanner(S, V.dsc(TextFrames.Frame).text, 0); Texts.Scan(S)		END;		IF (S.class = Texts.Name) & (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN			TF := V.dsc.next(TextFrames.Frame);			TextFrames.Mark(TF, -1);			Texts.WriteString(W, S.s); Texts.WriteLn(W);			Texts.Append(Oberon.Log, W.buf);			Texts.OpenReader(R, TF.text, 0);			F := Files.New(S.s); Files.Set(O, F, 0); Texts.Read(R, ch);			WHILE ~R.eot DO				IF ch = CR THEN ch := 0AX END ;				Files.Write(O, ch); Texts.Read(R, ch)			END ;			Files.Register(F);			TextFrames.Mark(TF, 1)		END	END StoreAscii;	PROCEDURE Search*;		VAR			text: Texts.Text;			beg, end, time: LONGINT;			r: Texts.Reader;			ch: CHAR;			i: INTEGER;			f: TextFrames.Frame;		PROCEDURE CompileDk;			VAR d, k, l: SHORTINT;		BEGIN k := 1; d := 1;			WHILE k < search.len DO				l := 0;				WHILE (d + l < search.len) & (search.buf[l] = search.buf[d + l]) DO l := l + 1 END ;				WHILE k <= d + l DO search.d[k] := d; k := k + 1 END ;				d := d + 1			END		END CompileDk;	BEGIN		Oberon.GetSelection(text, beg, end, time);		IF time > search.time THEN			search.time := time;			IF end-beg >= LEN(search.buf) THEN search.len := LEN(search.buf)-1 ELSE search.len := SHORT(end-beg) END;			Texts.OpenReader(r, text, beg); i := 0;			REPEAT Texts.Read(r, ch); search.buf[i] := ch; INC(i) UNTIL i = search.len;			IF r.eot THEN DEC(search.len) END ;			CompileDk;		END;		f := Focus();		IF (f # NIL) & (search.len > 0) THEN			IF f.car > 0 THEN end := f.carloc.pos ELSE end := 0 END;			beg := KMPsearch(f.text, end);			IF beg >= 0 THEN ShowPos(f, beg) ELSE TextFrames.RemoveCaret(f) END		END	END Search;	PROCEDURE Replace*;		VAR			f: TextFrames.Frame;			beg, end: LONGINT;	BEGIN		SetReplBuf; f := Focus();		IF (f # NIL) & (f.car > 0) THEN			end := f.carloc.pos; beg := end-search.len;			IF Check(f.text, beg) THEN end := ReplaceAndFind(f.text, beg) ELSE end := KMPsearch(f.text, end) END;			IF end >= 0 THEN ShowPos(f, end) END		END	END Replace;		PROCEDURE ReplaceAll*;		VAR			f: TextFrames.Frame;			beg, end: LONGINT;	BEGIN		SetReplBuf; f := Focus();		IF (f # NIL) & (f.car > 0) THEN			end := f.carloc.pos; beg := end-search.len;			IF Check(f.text, beg) THEN end := ReplaceAndFind(f.text, beg) ELSE end := KMPsearch(f.text, end) END;			WHILE end >= 0 DO end := ReplaceAndFind(f.text, end-search.len) END		END	END ReplaceAll;		PROCEDURE LocateLine*;					(* locate caret at specified line number *)		VAR par: Oberon.ParList;			V: Viewers.Viewer;			F: TextFrames.Frame;			T: Texts.Text;			S: Texts.Scanner;			R: Texts.Reader;			line: LONGINT;			beg, end, time, len: LONGINT;			ch: CHAR;	BEGIN		par := Oberon.Par; 		V := Oberon.FocusViewer;		Texts.OpenScanner(S, par.text, par.pos); Texts.Scan(S); 	   IF (S.class = Texts.Char) & (S.c = "^") OR (S.line # 0) THEN   	   Oberon.GetSelection(T, beg, end, time);   	    IF time >= 0 THEN Texts.OpenScanner(S, T, beg); Texts.Scan(S) END 	   END;		WHILE (S.class < Texts.Int) & (S.line = 0) DO Texts.Scan(S) END ;	(*skip names*)	    IF (S.class = Texts.Int) & (V.state > 1) & (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN			F := V.dsc.next(TextFrames.Frame);			Texts.OpenReader(R, F.text, 0); line := 1; Texts.Read(R, ch);			WHILE ~R.eot & (line < S.i) DO				IF ch = CR THEN INC(line) END ;				Texts.Read(R, ch)			END ;			ShowPos(F, Texts.Pos(R)-1)		END	END LocateLine;	PROCEDURE Match*;	(* select text between matching brackets *)		CONST			selLength = 32;		VAR			R:Texts.Reader;			V: Viewers.Viewer;			F: TextFrames.Frame;			len, i, lev: LONGINT;			ch: CHAR;			lpar, rpar, tx: ARRAY selLength OF CHAR;	BEGIN		V := Oberon.MarkedViewer();		IF (V.dsc # NIL) & (V.dsc.next IS TextFrames.Frame) THEN			F := V.dsc.next(TextFrames.Frame);			IF (F.sel > 0) & (F.selend.pos - F.selbeg.pos < selLength) THEN				i := 0; len := F.selend.pos - F.selbeg.pos;				Texts.OpenReader(R, F.text, F.selbeg.pos);				WHILE i < len DO					Texts.Read(R, ch); lpar[i] := ch;					IF ch = "(" THEN ch := ")"					ELSIF ch = "[" THEN ch := "]"					ELSIF ch = "{" THEN ch := "}"					ELSIF ch = "<" THEN ch := ">"					END ;					INC(i); rpar[len - i] := ch				END ;				lpar[len] := 0X; rpar[len] := 0X; tx[len] := 0X; lev := 1;				LOOP i := 0;					WHILE (i < len) & ~R.eot DO Texts.Read(R, tx[i]); INC(i) END ;					IF R.eot THEN RETURN					ELSIF tx = rpar THEN DEC(lev);						IF lev = 0 THEN EXIT END					ELSIF tx = lpar THEN INC(lev)					ELSE Texts.OpenReader(R, F.text, Texts.Pos(R) - len + 1)					END				END ;				TextFrames.SetSelection(F, F.selbeg.pos, Texts.Pos(R))			END		END	END Match;PROCEDURE SearchDiff*;	(*search for the first difference starting at the last two text selections*)	VAR		f1, f2: TextFrames.Frame;		p1, p2: LONGINT;		r1, r2: Texts.Reader;		ch1, ch2: CHAR;		PROCEDURE GetSelection(VAR F: TextFrames.Frame; VAR pos: LONGINT);		VAR time: LONGINT; v: Viewers.Viewer; x: INTEGER; f: TextFrames.Frame;	BEGIN		time := -1; x := 0; F := NIL;		WHILE x < Display.Width DO			v := Viewers.This(x, 0);			WHILE v.state > 1 DO				IF v.dsc.next IS TextFrames.Frame THEN					f := v.dsc.next(TextFrames.Frame); 					IF (f.sel > 0) & (f.time > time) THEN F := f; pos := f.selbeg.pos; time := f.time END;				END;				v := Viewers.Next(v)			END;			x := x + v.W		END;		IF F # NIL THEN TextFrames.RemoveSelection(F); TextFrames.RemoveCaret(F) END	END GetSelection;		PROCEDURE ShowSelection(f: TextFrames.Frame; pos: LONGINT);		VAR x: LONGINT;	BEGIN		IF pos > TextFrames.Pos(f, f.X + f.W - 1, f.Y) THEN 			x := pos - 150; IF x < 0 THEN x := 0 END;			TextFrames.Show(f, x)		END;		TextFrames.SetSelection(f, pos, pos+1)	END ShowSelection;	BEGIN	GetSelection(f1, p1); GetSelection(f2, p2);	IF (f1 # NIL) & (f2 # NIL) THEN		Texts.OpenReader(r1, f1.text, p1); 		Texts.OpenReader(r2, f2.text, p2); 		REPEAT			Texts.Read(r1, ch1); INC(p1); Texts.Read(r2, ch2); INC(p2);		UNTIL (ch1 # ch2) OR (ch1 = 0X);		IF (ch1 = 0X) OR (ch2 = 0X) THEN DEC(p1); DEC(p2) END;		ShowSelection(f1, p1-1); ShowSelection(f2, p2-1)	ENDEND SearchDiff;BEGIN	Texts.OpenWriter(W);	search.time := -1; search.len := 0; search.buf[0] := 0X;	replace.time := -1; NEW(replace.buf); Texts.OpenBuf(replace.buf)END EdiT.